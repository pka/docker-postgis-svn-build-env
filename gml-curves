Index: postgis-2.1.2+dfsg/liblwgeom/cunit/cu_out_gml.c
===================================================================
--- postgis-2.1.2+dfsg.orig/liblwgeom/cunit/cu_out_gml.c	2012-11-09 00:09:35.000000000 +0000
+++ postgis-2.1.2+dfsg/liblwgeom/cunit/cu_out_gml.c	2014-10-30 16:48:01.502705836 +0000
@@ -550,25 +550,26 @@
 	    "<gml:MultiGeometry><gml:geometryMember><gml:Point><gml:pos srsDimension=\"2\">0 1</gml:pos></gml:Point></gml:geometryMember><gml:geometryMember><gml:MultiGeometry><gml:geometryMember><gml:Curve><gml:segments><gml:LineStringSegment><gml:posList srsDimension=\"2\">2 3 4 5</gml:posList></gml:LineStringSegment></gml:segments></gml:Curve></gml:geometryMember></gml:MultiGeometry></gml:geometryMember></gml:MultiGeometry>",
 	    NULL, 0, 0);
 
-
-
 	/* GML2 - CircularString */
 	do_gml2_unsupported(
 	    "CIRCULARSTRING(-2 0,0 2,2 0,0 2,2 4)",
 	    "lwgeom_to_gml2: 'CircularString' geometry type not supported");
 	/* GML3 - CircularString */
-	do_gml3_unsupported(
-	    "CIRCULARSTRING(-2 0,0 2,2 0,0 2,2 4)",
-	    "lwgeom_to_gml3: 'CircularString' geometry type not supported");
+    do_gml3_test(
+                "CIRCULARSTRING(-2 0,0 2,2 0,0 2,2 4)",
+                "<gml:Curve><gml:segments><gml:ArcString><gml:posList srsDimension=\"2\">-2 0 0 2 2 0 0 2 2 4</gml:posList></gml:ArcString></gml:segments></gml:Curve>",
+                NULL, 0, 0 );
 
 	/* GML2 - CompoundCurve */
 	do_gml2_unsupported(
 	    "COMPOUNDCURVE(CIRCULARSTRING(0 0,1 1,1 0),(1 0,0 1))",
 	    "lwgeom_to_gml2: 'CompoundCurve' geometry type not supported");
 	/* GML3 - CompoundCurve */
-	do_gml3_unsupported(
-	    "COMPOUNDCURVE(CIRCULARSTRING(0 0,1 1,1 0),(1 0,0 1))",
-	    "lwgeom_to_gml3: 'CompoundCurve' geometry type not supported");
+
+    do_gml3_test(
+       "COMPOUNDCURVE(CIRCULARSTRING(0 0,1 1,1 0),(1 0,0 1))",
+                "<gml:Curve><gml:segments><gml:ArcString><gml:posList srsDimension=\"2\">0 0 1 1 1 0</gml:posList></gml:ArcString><gml:LineStringSegment><gml:posList srsDimension=\"2\">1 0 0 1</gml:posList></gml:LineStringSegment></gml:segments></gml:Curve>",
+                NULL, 0, 0 );
 
 	/* GML2 - CurvePolygon */
 	do_gml2_unsupported(
@@ -576,10 +577,13 @@
 	    "lwgeom_to_gml2: 'CurvePolygon' geometry type not supported");
 
 	/* GML3 - CurvePolygon */
-	do_gml3_unsupported(
-	    "CURVEPOLYGON(CIRCULARSTRING(-2 0,-1 -1,0 0,1 -1,2 0,0 2,-2 0),(-1 0,0 0.5,1 0,0 1,-1 0))",
-	    "lwgeom_to_gml3: 'CurvePolygon' geometry type not supported");
-
+    do_gml3_test(
+        "CURVEPOLYGON(CIRCULARSTRING(-2 0,-1 -1,0 0,1 -1,2 0,0 2,-2 0),(-1 0,0 0.5,1 0,0 1,-1 0))",
+                "<gml:Polygon><gml:exterior><gml:curveMember><gml:Curve><gml:segments><gml:ArcString><gml:posList srsDimension=\"2\">-2 0 -1 -1 0 0 1 -1 2 0 0 2 -2 0</gml:posList></gml:ArcString></gml:segments></gml:Curve></gml:curveMember></gml:exterior><gml:interior><gml:LinearRing><gml:posList srsDimension=\"2\">-1 0 0 0.5 1 0 0 1 -1 0</gml:posList></gml:LinearRing></gml:interior></gml:Polygon>",
+                NULL, 1, 0 );
+	do_gml3_test(
+		"CURVEPOLYGON(COMPOUNDCURVE((763650.600000001 189057.100000001,7636.35 189045.199999999, 763650.548999999 189057.844000001,763650.600000001 189057.100000001)))","<gml:Polygon><gml:exterior><gml:curveMember><gml:Curve><gml:segments><gml:LineStringSegment><gml:posList srsDimension=\"2\">763650.6 189057.1 7636.35 189045.2 763650.549 189057.844 763650.6 189057.1</gml:posList></gml:LineStringSegment></gml:segments></gml:Curve></gml:curveMember></gml:exterior></gml:Polygon>",
+				NULL, 7, 0 );
 
 	/* GML2 - MultiCurve */
 	do_gml2_unsupported(
@@ -587,9 +591,10 @@
 	    "lwgeom_to_gml2: 'MultiCurve' geometry type not supported");
 
 	/* GML3 - MultiCurve */
-	do_gml3_unsupported(
-	    "MULTICURVE((5 5,3 5,3 3,0 3),CIRCULARSTRING(0 0,2 1,2 2))",
-	    "lwgeom_to_gml3: 'MultiCurve' geometry type not supported");
+    do_gml3_test(
+         "MULTICURVE((5 5,3 5,3 3,0 3),CIRCULARSTRING(0 0,2 1,2 2))",
+                "<gml:MultiCurve><gml:curveMember><gml:Curve><gml:segments><gml:LineStringSegment><gml:posList srsDimension=\"2\">5 5 3 5 3 3 0 3</gml:posList></gml:LineStringSegment></gml:segments></gml:Curve></gml:curveMember><gml:curveMember><gml:Curve><gml:segments><gml:ArcString><gml:posList srsDimension=\"2\">0 0 2 1 2 2</gml:posList></gml:ArcString></gml:segments></gml:Curve></gml:curveMember></gml:MultiCurve>",
+                NULL, 0, 0 );
 
 	/* GML2 - MultiSurface */
 	do_gml2_unsupported(
@@ -597,9 +602,10 @@
 	    "lwgeom_to_gml2: 'MultiSurface' geometry type not supported");
 
 	/* GML3 - MultiSurface */
-	do_gml3_unsupported(
-	    "MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(-2 0,-1 -1,0 0,1 -1,2 0,0 2,-2 0),(-1 0,0 0.5,1 0,0 1,-1 0)),((7 8,10 10,6 14,4 11,7 8)))",
-	    "lwgeom_to_gml3: 'MultiSurface' geometry type not supported");
+    do_gml3_test(
+                "MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(-2 0,-1 -1,0 0,1 -1,2 0,0 2,-2 0),(-1 0,0 0.5,1 0,0 1,-1 0)),((7 8,10 10,6 14,4 11,7 8)))",
+                "<gml:MultiSurface><gml:Polygon><gml:exterior><gml:curveMember><gml:Curve><gml:segments><gml:ArcString><gml:posList srsDimension=\"2\">-2 0 -1 -1 0 0 1 -1 2 0 0 2 -2 0</gml:posList></gml:ArcString></gml:segments></gml:Curve></gml:curveMember></gml:exterior><gml:interior><gml:LinearRing><gml:posList srsDimension=\"2\">-1 0 0 0.5 1 0 0 1 -1 0</gml:posList></gml:LinearRing></gml:interior></gml:Polygon><gml:Polygon><gml:exterior><gml:LinearRing><gml:posList srsDimension=\"2\">7 8 10 10 6 14 4 11 7 8</gml:posList></gml:LinearRing></gml:exterior></gml:Polygon></gml:MultiSurface>",
+                NULL, 1, 0 );
 
 	/* GML2 - PolyhedralSurface */
 	do_gml2_unsupported(
Index: postgis-2.1.2+dfsg/liblwgeom/lwout_gml.c
===================================================================
--- postgis-2.1.2+dfsg.orig/liblwgeom/lwout_gml.c	2012-05-21 21:17:59.000000000 +0000
+++ postgis-2.1.2+dfsg/liblwgeom/lwout_gml.c	2014-10-30 16:48:01.502705836 +0000
@@ -39,8 +39,10 @@
 static char *asgml3_point(const LWPOINT *point, const char *srs, int precision, int opts, const char *prefix, const char *id);
 static size_t asgml3_line_size(const LWLINE *line, const char *srs, int precision, int opts, const char *prefix, const char *id);
 static char *asgml3_line(const LWLINE *line, const char *srs, int precision, int opts, const char *prefix, const char *id);
+static char *asgml3_circstring( const LWCIRCSTRING *circ, const char *srs, int precision, int opts, const char *prefix, const char *id );
 static size_t asgml3_poly_size(const LWPOLY *poly, const char *srs, int precision, int opts, const char *prefix, const char *id);
 static char *asgml3_poly(const LWPOLY *poly, const char *srs, int precision, int opts, int is_patch, const char *prefix, const char *id);
+static char * asgml3_curvepoly(const LWCURVEPOLY* poly, const char *srs, int precision, int opts, const char *prefix, const char *id);
 static size_t asgml3_triangle_size(const LWTRIANGLE *triangle, const char *srs, int precision, int opts, const char *prefix, const char *id);
 static char *asgml3_triangle(const LWTRIANGLE *triangle, const char *srs, int precision, int opts, const char *prefix, const char *id);
 static size_t asgml3_multi_size(const LWCOLLECTION *col, const char *srs, int precision, int opts, const char *prefix, const char *id);
@@ -49,20 +51,25 @@
 static char *asgml3_tin(const LWTIN *tin, const char *srs, int precision, int opts, const char *prefix, const char *id);
 static size_t asgml3_collection_size(const LWCOLLECTION *col, const char *srs, int precision, int opts, const char *prefix, const char *id);
 static char *asgml3_collection(const LWCOLLECTION *col, const char *srs, int precision, int opts, const char *prefix, const char *id);
+static char *asgml3_compound(const LWCOMPOUND *col, const char *srs, int precision, int opts, const char *prefix, const char *id );
+static char *asgml3_multicurve( const LWMCURVE* cur, const char *srs, int precision, int opts, const char *prefix, const char *id );
+static char *asgml3_multisurface(const LWMSURFACE *sur, const char *srs, int precision, int opts, const char *prefix, const char *id);
 static size_t pointArray_toGML3(POINTARRAY *pa, char *buf, int precision, int opts);
 
+
 static size_t pointArray_GMLsize(POINTARRAY *pa, int precision);
 
 static char *
 gbox_to_gml2(const GBOX *bbox, const char *srs, int precision, const char *prefix)
 {
 	int size;
-        POINT4D pt;
-        POINTARRAY *pa;
+	POINT4D pt;
+	POINTARRAY *pa;
 	char *ptr, *output;
 	size_t prefixlen = strlen(prefix);
 
-	if ( ! bbox ) {
+	if ( ! bbox )
+	{
 		size = ( sizeof("<Box>/") + (prefixlen*2) ) * 2;
 		if ( srs ) size += strlen(srs) + sizeof(" srsName=..");
 
@@ -77,17 +84,17 @@
 		return output;
 	}
 
-        pa = ptarray_construct_empty(FLAGS_GET_Z(bbox->flags), 0, 2);
+	pa = ptarray_construct_empty(FLAGS_GET_Z(bbox->flags), 0, 2);
 
-        pt.x = bbox->xmin; 
-        pt.y = bbox->ymin; 
-        if (FLAGS_GET_Z(bbox->flags)) pt.z = bbox->zmin; 
-        ptarray_append_point(pa, &pt, LW_TRUE);
-    
-        pt.x = bbox->xmax; 
-        pt.y = bbox->ymax; 
-        if (FLAGS_GET_Z(bbox->flags)) pt.z = bbox->zmax; 
-        ptarray_append_point(pa, &pt, LW_TRUE);
+	pt.x = bbox->xmin;
+	pt.y = bbox->ymin;
+	if (FLAGS_GET_Z(bbox->flags)) pt.z = bbox->zmin;
+	ptarray_append_point(pa, &pt, LW_TRUE);
+
+	pt.x = bbox->xmax;
+	pt.y = bbox->ymax;
+	if (FLAGS_GET_Z(bbox->flags)) pt.z = bbox->zmax;
+	ptarray_append_point(pa, &pt, LW_TRUE);
 
 	size = pointArray_GMLsize(pa, precision);
 	size += ( sizeof("<Box><coordinates>/") + (prefixlen*2) ) * 2;
@@ -102,7 +109,7 @@
 	ptr += pointArray_toGML2(pa, ptr, precision);
 	ptr += sprintf(ptr, "</%scoordinates></%sBox>", prefix, prefix);
 
-        ptarray_free(pa);
+	ptarray_free(pa);
 
 	return output;
 }
@@ -111,13 +118,14 @@
 gbox_to_gml3(const GBOX *bbox, const char *srs, int precision, int opts, const char *prefix)
 {
 	int size;
-        POINT4D pt;
-        POINTARRAY *pa;
+	POINT4D pt;
+	POINTARRAY *pa;
 	char *ptr, *output;
 	size_t prefixlen = strlen(prefix);
 	int dimension = 2;
 
-	if ( ! bbox ) {
+	if ( ! bbox )
+	{
 		size = ( sizeof("<Envelope>/") + (prefixlen*2) ) * 2;
 		if ( srs ) size += strlen(srs) + sizeof(" srsName=..");
 
@@ -131,14 +139,14 @@
 		return output;
 	}
 
-        if (FLAGS_GET_Z(bbox->flags)) dimension = 3;
+	if (FLAGS_GET_Z(bbox->flags)) dimension = 3;
 
-        pa = ptarray_construct_empty(FLAGS_GET_Z(bbox->flags), 0, 1);
+	pa = ptarray_construct_empty(FLAGS_GET_Z(bbox->flags), 0, 1);
 
-        pt.x = bbox->xmin;
-        pt.y = bbox->ymin; 
-        if (FLAGS_GET_Z(bbox->flags)) pt.z = bbox->zmin; 
-        ptarray_append_point(pa, &pt, LW_TRUE);
+	pt.x = bbox->xmin;
+	pt.y = bbox->ymin;
+	if (FLAGS_GET_Z(bbox->flags)) pt.z = bbox->zmin;
+	ptarray_append_point(pa, &pt, LW_TRUE);
 
 	size = pointArray_GMLsize(pa, precision) * 2;
 	size += ( sizeof("<Envelope><lowerCorner><upperCorner>//") + (prefixlen*3) ) * 2;
@@ -156,11 +164,11 @@
 	ptr += pointArray_toGML3(pa, ptr, precision, opts);
 	ptr += sprintf(ptr, "</%slowerCorner>", prefix);
 
-        ptarray_remove_point(pa, 0);
-        pt.x = bbox->xmax;
-        pt.y = bbox->ymax; 
-        if (FLAGS_GET_Z(bbox->flags)) pt.z = bbox->zmax; 
-        ptarray_append_point(pa, &pt, LW_TRUE);
+	ptarray_remove_point(pa, 0);
+	pt.x = bbox->xmax;
+	pt.y = bbox->ymax;
+	if (FLAGS_GET_Z(bbox->flags)) pt.z = bbox->zmax;
+	ptarray_append_point(pa, &pt, LW_TRUE);
 
 	ptr += sprintf(ptr, "<%supperCorner>", prefix);
 	ptr += pointArray_toGML3(pa, ptr, precision, opts);
@@ -168,7 +176,7 @@
 
 	ptr += sprintf(ptr, "</%sEnvelope>", prefix);
 
-        ptarray_free(pa);
+	ptarray_free(pa);
 
 	return output;
 }
@@ -178,31 +186,31 @@
 lwgeom_extent_to_gml2(const LWGEOM *geom, const char *srs, int precision, const char *prefix)
 {
 	const GBOX* bbox = lwgeom_get_bbox(geom);
-/*
-	if ( ! bbox ) {
-		lwerror("lwgeom_extent_to_gml2: empty geometry doesn't have a bounding box");
-		return NULL;
-	}
-*/
+	/*
+		if ( ! bbox ) {
+			lwerror("lwgeom_extent_to_gml2: empty geometry doesn't have a bounding box");
+			return NULL;
+		}
+	*/
 	char *ret = gbox_to_gml2(bbox, srs, precision, prefix);
 	return ret;
 }
-	
+
 
 extern char *
 lwgeom_extent_to_gml3(const LWGEOM *geom, const char *srs, int precision, int opts, const char *prefix)
 {
 	const GBOX* bbox = lwgeom_get_bbox(geom);
-/*
-	if ( ! bbox ) {
-		lwerror("lwgeom_extent_to_gml3: empty geometry doesn't have a bounding box");
-		return NULL;
-	}
-*/
+	/*
+		if ( ! bbox ) {
+			lwerror("lwgeom_extent_to_gml3: empty geometry doesn't have a bounding box");
+			return NULL;
+		}
+	*/
 	return gbox_to_gml3(bbox, srs, precision, opts, prefix);
 }
-	
-	
+
+
 /**
  *  @brief VERSION GML 2
  *  	takes a GEOMETRY and returns a GML2 representation
@@ -240,7 +248,7 @@
 	case TINTYPE:
 		lwerror("Cannot convert %s to GML2. Try ST_AsGML(3, <geometry>) to generate GML3.", lwtype_name(type));
 		return NULL;
-		
+
 	default:
 		lwerror("lwgeom_to_gml2: '%s' geometry type not supported", lwtype_name(type));
 		return NULL;
@@ -266,7 +274,8 @@
 
 	ptr += sprintf(ptr, "<%sPoint", prefix);
 	if ( srs ) ptr += sprintf(ptr, " srsName=\"%s\"", srs);
-	if ( lwpoint_is_empty(point) ) {
+	if ( lwpoint_is_empty(point) )
+	{
 		ptr += sprintf(ptr, "/>");
 		return (ptr-output);
 	}
@@ -311,7 +320,8 @@
 	ptr += sprintf(ptr, "<%sLineString", prefix);
 	if ( srs ) ptr += sprintf(ptr, " srsName=\"%s\"", srs);
 
-	if ( lwline_is_empty(line) ) {
+	if ( lwline_is_empty(line) )
+	{
 		ptr += sprintf(ptr, "/>");
 		return (ptr-output);
 	}
@@ -345,7 +355,7 @@
 
 	size = sizeof("<polygon></polygon>") + prefixlen*2;
 	if ( srs ) size += strlen(srs) + sizeof(" srsName=..");
-	if ( lwpoly_is_empty(poly) ) 
+	if ( lwpoly_is_empty(poly) )
 		return size;
 	size += ( sizeof("<outerboundaryis><linearring><coordinates>/") + ( prefixlen*3) ) * 2;
 	size += ( sizeof("<innerboundaryis><linearring><coordinates>/") + ( prefixlen*2) ) * 2 * poly->nrings;
@@ -365,13 +375,14 @@
 
 	ptr += sprintf(ptr, "<%sPolygon", prefix);
 	if ( srs ) ptr += sprintf(ptr, " srsName=\"%s\"", srs);
-	if ( lwpoly_is_empty(poly) ) {
+	if ( lwpoly_is_empty(poly) )
+	{
 		ptr += sprintf(ptr, "/>");
 		return (ptr-output);
 	}
 	ptr += sprintf(ptr, ">");
 	ptr += sprintf(ptr, "<%souterBoundaryIs><%sLinearRing><%scoordinates>",
-		       prefix, prefix, prefix);
+	               prefix, prefix, prefix);
 	ptr += pointArray_toGML2(poly->rings[0], ptr, precision);
 	ptr += sprintf(ptr, "</%scoordinates></%sLinearRing></%souterBoundaryIs>", prefix, prefix, prefix);
 	for (i=1; i<poly->nrings; i++)
@@ -463,7 +474,8 @@
 	ptr += sprintf(ptr, "<%s%s", prefix, gmltype);
 	if ( srs ) ptr += sprintf(ptr, " srsName=\"%s\"", srs);
 
-	if (!col->ngeoms) {
+	if (!col->ngeoms)
+	{
 		ptr += sprintf(ptr, "/>");
 		return (ptr-output);
 	}
@@ -535,7 +547,7 @@
 	for (i=0; i<col->ngeoms; i++)
 	{
 		subgeom = col->geoms[i];
-		
+
 		size += ( sizeof("<geometryMember>/") + prefixlen ) * 2;
 		if ( subgeom->type == POINTTYPE)
 		{
@@ -570,14 +582,15 @@
 	char *ptr;
 	int i;
 	LWGEOM *subgeom;
-	
+
 	ptr = output;
 
 	/* Open outmost tag */
 	ptr += sprintf(ptr, "<%sMultiGeometry", prefix);
 	if ( srs ) ptr += sprintf(ptr, " srsName=\"%s\"", srs);
 
-	if (!col->ngeoms) {
+	if (!col->ngeoms)
+	{
 		ptr += sprintf(ptr, "/>");
 		return (ptr-output);
 	}
@@ -585,7 +598,7 @@
 
 	for (i=0; i<col->ngeoms; i++)
 	{
- 		subgeom = col->geoms[i];
+		subgeom = col->geoms[i];
 
 		ptr += sprintf(ptr, "<%sgeometryMember>", prefix);
 		if (subgeom->type == POINTTYPE)
@@ -724,9 +737,15 @@
 	case LINETYPE:
 		return asgml3_line((LWLINE*)geom, srs, precision, opts, prefix, id);
 
+	case CIRCSTRINGTYPE:
+		return asgml3_circstring((LWCIRCSTRING*)geom, srs, precision, opts, prefix, id );
+
 	case POLYGONTYPE:
 		return asgml3_poly((LWPOLY*)geom, srs, precision, opts, 0, prefix, id);
 
+	case CURVEPOLYTYPE:
+		return asgml3_curvepoly((LWCURVEPOLY*)geom, srs, precision, opts, prefix, id);
+
 	case TRIANGLETYPE:
 		return asgml3_triangle((LWTRIANGLE*)geom, srs, precision, opts, prefix, id);
 
@@ -744,6 +763,15 @@
 	case COLLECTIONTYPE:
 		return asgml3_collection((LWCOLLECTION*)geom, srs, precision, opts, prefix, id);
 
+	case COMPOUNDTYPE:
+		return asgml3_compound( (LWCOMPOUND*)geom, srs, precision, opts, prefix, id );
+
+	case MULTICURVETYPE:
+		return asgml3_multicurve( (LWMCURVE*)geom, srs, precision, opts, prefix, id );
+
+	case MULTISURFACETYPE:
+		return asgml3_multisurface( (LWMSURFACE*)geom, srs, precision, opts, prefix, id );
+
 	default:
 		lwerror("lwgeom_to_gml3: '%s' geometry type not supported", lwtype_name(type));
 		return NULL;
@@ -775,7 +803,8 @@
 	ptr += sprintf(ptr, "<%sPoint", prefix);
 	if ( srs ) ptr += sprintf(ptr, " srsName=\"%s\"", srs);
 	if ( id )  ptr += sprintf(ptr, " %sid=\"%s\"", prefix, id);
-	if ( lwpoint_is_empty(point) ) {
+	if ( lwpoint_is_empty(point) )
+	{
 		ptr += sprintf(ptr, "/>");
 		return (ptr-output);
 	}
@@ -812,16 +841,16 @@
 	if ( opts & LW_GML_SHORTLINE )
 	{
 		size += (
-		  sizeof("<LineString><posList>/") +
-		  ( prefixlen * 2 )
-		) * 2;
+		            sizeof("<LineString><posList>/") +
+		            ( prefixlen * 2 )
+		        ) * 2;
 	}
 	else
 	{
 		size += (
-		  sizeof("<Curve><segments><LineStringSegment><posList>/") +
-		  ( prefixlen * 4 )
-		) * 2;
+		            sizeof("<Curve><segments><LineStringSegment><posList>/") +
+		            ( prefixlen * 4 )
+		        ) * 2;
 	}
 	if (srs) size += strlen(srs) + sizeof(" srsName=..");
 	if (id)  size += strlen(id) + strlen(prefix) + sizeof(" id=..");
@@ -838,30 +867,38 @@
 
 	if (FLAGS_GET_Z(line->flags)) dimension = 3;
 
-	if ( shortline ) {
+	if ( shortline )
+	{
 		ptr += sprintf(ptr, "<%sLineString", prefix);
-	} else {
+	}
+	else
+	{
 		ptr += sprintf(ptr, "<%sCurve", prefix);
 	}
 
 	if (srs) ptr += sprintf(ptr, " srsName=\"%s\"", srs);
 	if (id)  ptr += sprintf(ptr, " %sid=\"%s\"", prefix, id);
 
-	if ( lwline_is_empty(line) ) {
+	if ( lwline_is_empty(line) )
+	{
 		ptr += sprintf(ptr, "/>");
 		return (ptr-output);
 	}
 	ptr += sprintf(ptr, ">");
 
-	if ( ! shortline ) {
+	if ( ! shortline )
+	{
 		ptr += sprintf(ptr, "<%ssegments>", prefix);
 		ptr += sprintf(ptr, "<%sLineStringSegment>", prefix);
 	}
 
-	if (IS_DIMS(opts)) {
+	if (IS_DIMS(opts))
+	{
 		ptr += sprintf(ptr, "<%sposList srsDimension=\"%d\">",
-			prefix, dimension);
-	} else {
+		               prefix, dimension);
+	}
+	else
+	{
 		ptr += sprintf(ptr, "<%sposList>", prefix);
 	}
 
@@ -869,9 +906,12 @@
 
 	ptr += sprintf(ptr, "</%sposList>", prefix);
 
-	if ( shortline ) {
+	if ( shortline )
+	{
 		ptr += sprintf(ptr, "</%sLineString>", prefix);
-	} else {
+	}
+	else
+	{
 		ptr += sprintf(ptr, "</%sLineStringSegment>", prefix);
 		ptr += sprintf(ptr, "</%ssegments>", prefix);
 		ptr += sprintf(ptr, "</%sCurve>", prefix);
@@ -894,6 +934,71 @@
 
 
 static size_t
+asgml3_circstring_size(const LWCIRCSTRING *circ, const char *srs, int precision, int opts, const char *prefix, const char *id)
+{
+	int size = pointArray_GMLsize( circ->points, precision );
+	size_t prefixlen = strlen(prefix);
+	size += 2 * ( sizeof( "<Curve><segments>/" ) + 2 * prefixlen );
+	size += 2 * ( sizeof( "<ArcString><posList>/" ) + 2 * prefixlen );
+	if (srs) size += strlen(srs) + sizeof(" srsName=..");
+	if (id)  size += strlen(id) + strlen(prefix) + sizeof(" id=..");
+	if (IS_DIMS(opts)) size += sizeof(" srsDimension='x'");
+	return size;
+}
+
+static size_t
+asgml3_circstring_buf(const LWCIRCSTRING *circ, const char *srs, char *output, int precision, int opts, const char *prefix, const char *id)
+{
+	char* ptr = output;
+	int dimension=2;
+
+	if (FLAGS_GET_Z(circ->flags))
+	{
+		dimension = 3;
+	}
+
+	ptr += sprintf(ptr, "<%sCurve", prefix);
+	if (srs)
+	{
+		ptr += sprintf(ptr, " srsName=\"%s\"", srs);
+	}
+	if (id)
+	{
+		ptr += sprintf(ptr, " %sid=\"%s\"", prefix, id);
+	}
+	ptr += sprintf(ptr, ">");
+	ptr += sprintf(ptr, "<%ssegments>", prefix);
+	ptr += sprintf(ptr, "<%sArcString>", prefix);
+	ptr += sprintf(ptr, "<%sposList", prefix);
+
+	if (IS_DIMS(opts))
+	{
+		ptr += sprintf(ptr, " srsDimension=\"%d\"", dimension);
+	}
+	ptr += sprintf(ptr, ">");
+
+	ptr += pointArray_toGML3(circ->points, ptr, precision, opts);
+	ptr += sprintf(ptr, "</%sposList>", prefix);
+	ptr += sprintf(ptr, "</%sArcString>", prefix);
+	ptr += sprintf(ptr, "</%ssegments>", prefix);
+	ptr += sprintf(ptr, "</%sCurve>", prefix);
+	return (ptr-output);
+}
+
+static char *
+asgml3_circstring( const LWCIRCSTRING *circ, const char *srs, int precision, int opts, const char *prefix, const char *id )
+{
+	char *output;
+	int size;
+
+	size = asgml3_circstring_size(circ, srs, precision, opts, prefix, id);
+	output = lwalloc( size );
+	asgml3_circstring_buf(circ, srs, output, precision, opts, prefix, id);
+	return output;
+}
+
+
+static size_t
 asgml3_poly_size(const LWPOLY *poly, const char *srs, int precision, int opts, const char *prefix, const char *id)
 {
 	size_t size;
@@ -934,7 +1039,8 @@
 	if (srs) ptr += sprintf(ptr, " srsName=\"%s\"", srs);
 	if (id)  ptr += sprintf(ptr, " %sid=\"%s\"", prefix, id);
 
-	if ( lwpoly_is_empty(poly) ) {
+	if ( lwpoly_is_empty(poly) )
+	{
 		ptr += sprintf(ptr, "/>");
 		return (ptr-output);
 	}
@@ -974,6 +1080,250 @@
 	return output;
 }
 
+static size_t asgml3_compound_size(const LWCOMPOUND *col, const char *srs, int precision, int opts, const char *prefix, const char *id )
+{
+	int i;
+	size_t size;
+	LWGEOM *subgeom;
+	size_t prefixlen = strlen(prefix);
+
+	size = ( sizeof( "<Curve></Curve>" ) + 2 * prefixlen );
+
+	if (srs) size += strlen(srs) + sizeof(" srsName=..");
+	if (id)  size += strlen(id) + strlen(prefix) + sizeof(" id=..");
+
+	size += ( sizeof("<segments></segments>") + 2 * prefixlen );
+
+	for(i= 0; i < col->ngeoms; ++i )
+	{
+		subgeom = col->geoms[i];
+		if ( subgeom->type == LINETYPE )
+		{
+
+			size += sizeof( "<LineStringSegment></LineStringSegment" ) + 2 * prefixlen;
+			size += sizeof( "<posList></posList" ) + 2 * prefixlen;
+			size += pointArray_GMLsize( ((LWLINE*)subgeom)->points, precision );
+		}
+		else if( subgeom->type == CIRCSTRINGTYPE )
+		{
+			size += sizeof( "<ArcString><posList></ArcString></posList>") + 4 * prefixlen;
+			size += pointArray_GMLsize( ((LWCIRCSTRING*)subgeom)->points, precision );
+		}
+		else
+		{
+			continue;
+		}
+		if (IS_DIMS(opts))
+		{
+			size += sizeof(" srsDimension='x'");
+		}
+	}
+	return size;
+}
+
+static size_t asgml3_compound_buf(const LWCOMPOUND *col, const char *srs, char *output, int precision, int opts, const char *prefix, const char *id)
+{
+	LWGEOM *subgeom;
+	int i;
+	char* ptr = output;
+	int dimension=2;
+
+	if (FLAGS_GET_Z(col->flags))
+	{
+		dimension = 3;
+	}
+
+	ptr += sprintf( ptr, "<%sCurve", prefix );
+	if (srs)
+	{
+		ptr += sprintf(ptr, " srsName=\"%s\"", srs);
+	}
+	if (id)
+	{
+		ptr += sprintf(ptr, " %sid=\"%s\"", prefix, id );
+	}
+	ptr += sprintf( ptr, ">" );
+	ptr += sprintf( ptr, "<%ssegments>", prefix );
+
+	for( i = 0; i < col->ngeoms; ++i )
+	{
+		subgeom = col->geoms[i];
+		if( subgeom->type != LINETYPE && subgeom->type != CIRCSTRINGTYPE )
+		{
+			continue;
+		}
+
+		if ( subgeom->type == LINETYPE )
+		{
+			ptr += sprintf( ptr, "<%sLineStringSegment><%sposList", prefix, prefix );
+			if (IS_DIMS(opts))
+			{
+				ptr += sprintf(ptr, " srsDimension=\"%d\"", dimension);
+			}
+			ptr += sprintf(ptr, ">");
+			ptr += pointArray_toGML3(((LWCIRCSTRING*)subgeom)->points, ptr, precision, opts);
+			ptr += sprintf( ptr, "</%sposList></%sLineStringSegment>", prefix, prefix );
+		}
+		else if( subgeom->type == CIRCSTRINGTYPE )
+		{
+			ptr += sprintf( ptr, "<%sArcString><%sposList" , prefix, prefix );
+			if (IS_DIMS(opts))
+			{
+				ptr += sprintf(ptr, " srsDimension=\"%d\"", dimension);
+			}
+			ptr += sprintf(ptr, ">");
+			ptr += pointArray_toGML3(((LWLINE*)subgeom)->points, ptr, precision, opts);
+			ptr += sprintf( ptr, "</%sposList></%sArcString>", prefix, prefix );
+		}
+	}
+
+	ptr += sprintf( ptr, "</%ssegments>", prefix );
+	ptr += sprintf( ptr, "</%sCurve>", prefix );
+	return ( ptr - output );
+}
+
+static char *asgml3_compound(const LWCOMPOUND *col, const char *srs, int precision, int opts, const char *prefix, const char *id )
+{
+	char* gml;
+	size_t size;
+
+	size = asgml3_compound_size( col, srs, precision, opts, prefix, id );
+	gml = lwalloc( size );
+	asgml3_compound_buf( col, srs, gml, precision, opts, prefix, id );
+	return gml;
+}
+
+static size_t asgml3_curvepoly_size(const LWCURVEPOLY* poly, const char *srs, int precision, int opts, const char *prefix, const char *id)
+{
+	size_t prefixlen = strlen(prefix);
+	LWGEOM* subgeom;
+	size_t size = sizeof( "<Polygon></Polygon" ) + 2 * prefixlen;
+	if (srs) size += strlen(srs) + sizeof(" srsName=..");
+	if (id)  size += strlen(id) + strlen(prefix) + sizeof(" id=..");
+	int i;
+
+	for( i = 0; i < poly->nrings; ++i )
+	{
+		if( i == 0 )
+		{
+			size += sizeof( "<exterior></exterior>" ) + 2 * prefixlen;
+		}
+		else
+		{
+			size += sizeof( "<interior></interior>" ) + 2 * prefixlen;
+		}
+		subgeom = poly->rings[i];
+
+		if ( subgeom->type == LINETYPE )
+		{
+			size += sizeof("<LinearRing></LinearRing>") + 2 * prefixlen;
+			size += sizeof("<posList></posList") + 2 * prefixlen;
+			if (IS_DIMS(opts))
+			{
+				size += sizeof(" srsDimension='x'");
+			}
+			size += pointArray_GMLsize( ((LWLINE*)subgeom)->points, precision );
+		}
+		else if( subgeom->type == CIRCSTRINGTYPE )
+		{
+			size += sizeof("<CurveMember></CurveMember>") + 2 * prefixlen;
+			size += asgml3_circstring_size((LWCIRCSTRING*)subgeom, srs, precision, opts, prefix, id);
+		}
+		else if( subgeom->type == COMPOUNDTYPE )
+		{
+			size += sizeof("<curveMember></curveMember>") + 2 * prefixlen;
+			size += asgml3_compound_size( (LWCOMPOUND*)subgeom, srs, precision, opts, prefix, id );
+		}
+	}
+	return size;
+}
+
+static size_t asgml3_curvepoly_buf(const LWCURVEPOLY* poly, const char *srs, char *output, int precision, int opts, const char *prefix, const char *id)
+{
+	int i;
+	LWGEOM* subgeom;
+	char *ptr=output;
+	int dimension=2;
+
+	if (FLAGS_GET_Z(poly->flags))
+	{
+		dimension = 3;
+	}
+
+	ptr += sprintf( ptr, "<%sPolygon", prefix );
+	if (srs)
+	{
+		ptr += sprintf(ptr, " srsName=\"%s\"", srs);
+	}
+	if (id)
+	{
+		ptr += sprintf(ptr, " %sid=\"%s\"", prefix, id );
+	}
+	ptr += sprintf(ptr, ">");
+
+	for( i = 0; i < poly->nrings; ++i )
+	{
+		if( i == 0 )
+		{
+			ptr += sprintf( ptr, "<%sexterior>", prefix);
+		}
+		else
+		{
+			ptr += sprintf( ptr, "<%sinterior>", prefix);
+		}
+
+		subgeom = poly->rings[i];
+		if ( subgeom->type == LINETYPE )
+		{
+			ptr += sprintf( ptr, "<%sLinearRing>", prefix );
+			ptr += sprintf( ptr, "<%sposList", prefix );
+			if (IS_DIMS(opts))
+			{
+				ptr += sprintf(ptr, " srsDimension=\"%d\"", dimension);
+			}
+			ptr += sprintf( ptr, ">" );
+			ptr += pointArray_toGML3(((LWLINE*)subgeom)->points, ptr, precision, opts);
+			ptr += sprintf( ptr, "</%sposList>", prefix );
+			ptr += sprintf( ptr, "</%sLinearRing>", prefix );
+		}
+		else if( subgeom->type == CIRCSTRINGTYPE )
+		{
+			ptr += sprintf( ptr, "<%scurveMember>", prefix );
+			ptr += asgml3_circstring_buf( (LWCIRCSTRING*)subgeom, srs, ptr, precision, opts, prefix, id );
+			ptr += sprintf( ptr, "</%scurveMember>", prefix );
+		}
+		else if( subgeom->type == COMPOUNDTYPE )
+		{
+			ptr += sprintf( ptr, "<%scurveMember>", prefix );
+			ptr += asgml3_compound_buf( (LWCOMPOUND*)subgeom, srs, ptr, precision, opts, prefix, id );
+			ptr += sprintf( ptr, "</%scurveMember>", prefix );
+		}
+
+		if( i == 0 )
+		{
+			ptr += sprintf( ptr, "</%sexterior>", prefix);
+		}
+		else
+		{
+			ptr += sprintf( ptr, "</%sinterior>", prefix);
+		}
+	}
+
+	ptr += sprintf( ptr, "</%sPolygon>", prefix );
+	return (ptr - output);
+}
+
+static char* asgml3_curvepoly(const LWCURVEPOLY* poly, const char *srs, int precision, int opts, const char *prefix, const char *id)
+{
+	char* gml;
+	size_t size;
+
+	size = asgml3_curvepoly_size( poly, srs, precision, opts, prefix, id );
+	gml = lwalloc( size );
+	asgml3_curvepoly_buf( poly, srs, gml, precision, opts, prefix, id );
+	return gml;
+}
+
 
 static size_t
 asgml3_triangle_size(const LWTRIANGLE *triangle, const char *srs, int precision, int opts, const char *prefix, const char *id)
@@ -1095,7 +1445,8 @@
 	if (srs) ptr += sprintf(ptr, " srsName=\"%s\"", srs);
 	if (id)  ptr += sprintf(ptr, " %sid=\"%s\"", prefix, id);
 
-	if (!col->ngeoms) {
+	if (!col->ngeoms)
+	{
 		ptr += sprintf(ptr, "/>");
 		return (ptr-output);
 	}
@@ -1329,7 +1680,8 @@
 	if (srs) ptr += sprintf(ptr, " srsName=\"%s\"", srs);
 	if (id)  ptr += sprintf(ptr, " %sid=\"%s\"", prefix, id);
 
-	if (!col->ngeoms) {
+	if (!col->ngeoms)
+	{
 		ptr += sprintf(ptr, "/>");
 		return (ptr-output);
 	}
@@ -1358,9 +1710,9 @@
 			else
 				ptr += asgml3_multi_buf((LWCOLLECTION*)subgeom, 0, ptr, precision, opts, prefix, id);
 		}
-		else 
+		else
 			lwerror("asgml3_collection_buf: unknown geometry type");
-			
+
 		ptr += sprintf(ptr, "</%sgeometryMember>", prefix);
 	}
 
@@ -1385,6 +1737,149 @@
 	return gml;
 }
 
+static size_t asgml3_multicurve_size( const LWMCURVE* cur, const char *srs, int precision, int opts, const char *prefix, const char *id )
+{
+	size_t prefixlen = strlen(prefix);
+	size_t size = sizeof( "<MultiCurve></MultiCurve>" ) + 2 * prefixlen;
+	if (srs) size += strlen(srs) + sizeof(" srsName=..");
+	if (id)  size += strlen(id) + strlen(prefix) + sizeof(" id=..");
+	LWGEOM* subgeom;
+	int i;
+
+	for( i = 0; i < cur->ngeoms; ++i )
+	{
+		size += sizeof( "<curveMember></curveMember>" ) + 2 * prefixlen;
+		subgeom = cur->geoms[i];
+		if ( subgeom->type == LINETYPE )
+		{
+			size += asgml3_line_size( (LWLINE*)subgeom, srs, precision, opts, prefix, id );
+		}
+		else if( subgeom->type == CIRCSTRINGTYPE )
+		{
+			size += asgml3_circstring_size( (LWCIRCSTRING*)subgeom, srs, precision, opts, prefix, id );
+		}
+		else if( subgeom->type == COMPOUNDTYPE )
+		{
+			size += asgml3_compound_size( (LWCOMPOUND*)subgeom, srs, precision, opts, prefix, id );
+		}
+	}
+	return size;
+}
+
+static size_t asgml3_multicurve_buf( const LWMCURVE* cur, const char *srs, char *output, int precision, int opts, const char *prefix, const char *id )
+{
+	char* ptr = output;
+	LWGEOM* subgeom;
+	int i;
+
+	ptr += sprintf(ptr, "<%sMultiCurve", prefix );
+	if (srs)
+	{
+		ptr += sprintf(ptr, " srsName=\"%s\"", srs);
+	}
+	if (id)
+	{
+		ptr += sprintf(ptr, " %sid=\"%s\"", prefix, id );
+	}
+	ptr += sprintf( ptr, ">");
+
+	for( i = 0; i < cur->ngeoms; ++i )
+	{
+		ptr += sprintf(ptr, "<%scurveMember>", prefix );
+		subgeom = cur->geoms[i];
+		if ( subgeom->type == LINETYPE )
+		{
+			ptr += asgml3_line_buf( (LWLINE*)subgeom, srs, ptr, precision, opts, prefix, id );
+		}
+		else if( subgeom->type == CIRCSTRINGTYPE )
+		{
+			ptr += asgml3_circstring_buf( (LWCIRCSTRING*)subgeom, srs, ptr, precision, opts, prefix, id );
+		}
+		else if( subgeom->type == COMPOUNDTYPE )
+		{
+			ptr += asgml3_compound_buf( (LWCOMPOUND*)subgeom, srs, ptr, precision, opts, prefix, id );
+		}
+		ptr += sprintf(ptr, "</%scurveMember>", prefix );
+	}
+	ptr += sprintf(ptr, "</%sMultiCurve>", prefix );
+	return (ptr - output);
+}
+
+static char *asgml3_multicurve( const LWMCURVE* cur, const char *srs, int precision, int opts, const char *prefix, const char *id )
+{
+	char* gml;
+	size_t size =asgml3_multicurve_size( cur, srs, precision, opts, prefix, id );
+	gml = lwalloc( size );
+	asgml3_multicurve_buf( cur, srs, gml, precision, opts, prefix, id );
+	return gml;
+}
+
+static size_t asgml3_multisurface_size(const LWMSURFACE *sur, const char *srs, int precision, int opts, const char *prefix, const char *id)
+{
+	size_t prefixlen = strlen(prefix);
+	size_t size = sizeof( "<MultiSurface></MultiSurface>" ) + 2 * prefixlen;
+	if (srs) size += strlen(srs) + sizeof(" srsName=..");
+	if (id)  size += strlen(id) + strlen(prefix) + sizeof(" id=..");
+	LWGEOM* subgeom;
+	int i;
+
+	for( i = 0; i < sur->ngeoms; ++i )
+	{
+		subgeom = sur->geoms[i];
+		if( subgeom->type == POLYGONTYPE )
+		{
+			size += asgml3_poly_size( (LWPOLY*)sur->geoms[i], srs, precision, opts, prefix, id );
+		}
+		else if( subgeom->type == CURVEPOLYTYPE )
+		{
+			size += asgml3_curvepoly_size( (LWCURVEPOLY*)sur->geoms[i], srs, precision, opts, prefix, id );
+		}
+	}
+	return size;
+}
+
+static size_t asgml3_multisurface_buf(const LWMSURFACE *sur, const char *srs, char *output, int precision, int opts, const char *prefix, const char *id)
+{
+	char* ptr = output;
+	int i;
+	LWGEOM* subgeom;
+
+	ptr += sprintf( ptr, "<%sMultiSurface", prefix );
+	if (srs)
+	{
+		ptr += sprintf(ptr, " srsName=\"%s\"", srs);
+	}
+	if (id)
+	{
+		ptr += sprintf(ptr, " %sid=\"%s\"", prefix, id );
+	}
+	ptr += sprintf( ptr, ">" );
+
+	for( i = 0; i < sur->ngeoms; ++i )
+	{
+		subgeom = sur->geoms[i];
+		if( subgeom->type == POLYGONTYPE )
+		{
+			ptr += asgml3_poly_buf( (LWPOLY*)sur->geoms[i], srs, ptr, precision, opts, 0, prefix, id );
+		}
+		else if( subgeom->type == CURVEPOLYTYPE )
+		{
+			ptr += asgml3_curvepoly_buf( (LWCURVEPOLY*)sur->geoms[i], srs, ptr, precision, opts, prefix, id );
+		}
+	}
+	ptr += sprintf( ptr, "</%sMultiSurface>", prefix );
+	return ptr - output;
+}
+
+static char *asgml3_multisurface(const LWMSURFACE *sur, const char *srs, int precision, int opts, const char *prefix, const char *id)
+{
+	char* gml;
+	size_t size = asgml3_multisurface_size( sur, srs, precision, opts, prefix, id );
+	gml = lwalloc( size );
+	asgml3_multisurface_buf( sur, srs, gml, precision, opts, prefix, id );
+	return gml;
+}
+
 
 /* In GML3, inside <posList> or <pos>, coordinates are separated by a space separator
  * In GML3 also, lat/lon are reversed for geocentric data
Index: postgis-2.1.2+dfsg/regress/out_geometry.sql
===================================================================
--- postgis-2.1.2+dfsg.orig/regress/out_geometry.sql	2012-09-28 17:03:46.000000000 +0000
+++ postgis-2.1.2+dfsg/regress/out_geometry.sql	2014-10-30 16:47:57.298705901 +0000
@@ -50,6 +50,13 @@
 SELECT 'gml_shortline_03', ST_AsGML(3, GeomFromEWKT('MULTILINESTRING((1 2, 3 4), (5 6, 7 8))'), 0, 6, '');
 SELECT 'gml_shortline_04', ST_AsGML(3, GeomFromEWKT('MULTILINESTRING((1 2, 3 4), (5 6, 7 8))'), 0, 2, '');
 
+-- CIRCULARSTRING / COMPOUNDCURVE / CURVEPOLYGON / MULTISURFACE / MULTICURVE
+SELECT 'gml_out_curve_01', ST_AsGML( 3, GeomFromEWKT('CIRCULARSTRING(-2 0,0 2,2 0,0 2,2 4)'));
+SELECT 'gml_out_curve_02', ST_ASGML( 3, GeomFromEWKT('COMPOUNDCURVE(CIRCULARSTRING(0 0,1 1,1 0),(1 0,0 1))'));
+SELECT 'gml_out_curve_03', ST_AsGML( 3, GeomFromEWKT('CURVEPOLYGON(CIRCULARSTRING(-2 0,-1 -1,0 0,1 -1,2 0,0 2,-2 0),(-1 0,0 0.5,1 0,0 1,-1 0))'));
+SELECT 'gml_out_curve_04', ST_AsGML( 3, GeomFromEWKT('MULTICURVE((5 5,3 5,3 3,0 3),CIRCULARSTRING(0 0,2 1,2 2))'));
+SELECT 'gml_out_curve_05', ST_AsGML( 3, GeomFromEWKT('MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(-2 0,-1 -1,0 0,1 -1,2 0,0 2,-2 0),(-1 0,0 0.5,1 0,0 1,-1 0)),((7 8,10 10,6 14,4 11,7 8)))'));
+
 --
 -- KML
 --
Index: postgis-2.1.2+dfsg/regress/out_geometry_expected
===================================================================
--- postgis-2.1.2+dfsg.orig/regress/out_geometry_expected	2012-09-28 17:03:46.000000000 +0000
+++ postgis-2.1.2+dfsg/regress/out_geometry_expected	2014-10-30 16:47:57.298705901 +0000
@@ -22,6 +22,11 @@
 gml_shortline_02|<Curve><segments><LineStringSegment><posList>1 2 3 4</posList></LineStringSegment></segments></Curve>
 gml_shortline_03|<MultiCurve><curveMember><LineString><posList>1 2 3 4</posList></LineString></curveMember><curveMember><LineString><posList>5 6 7 8</posList></LineString></curveMember></MultiCurve>
 gml_shortline_04|<MultiCurve><curveMember><Curve><segments><LineStringSegment><posList>1 2 3 4</posList></LineStringSegment></segments></Curve></curveMember><curveMember><Curve><segments><LineStringSegment><posList>5 6 7 8</posList></LineStringSegment></segments></Curve></curveMember></MultiCurve>
+gml_out_curve_01|<gml:Curve><gml:segments><gml:ArcString><gml:posList srsDimension="2">-2 0 0 2 2 0 0 2 2 4</gml:posList></gml:ArcString></gml:segments></gml:Curve>
+gml_out_curve_02|<gml:Curve><gml:segments><gml:ArcString><gml:posList srsDimension="2">0 0 1 1 1 0</gml:posList></gml:ArcString><gml:LineStringSegment><gml:posList srsDimension="2">1 0 0 1</gml:posList></gml:LineStringSegment></gml:segments></gml:Curve>
+gml_out_curve_03|<gml:Polygon><gml:exterior><gml:curveMember><gml:Curve><gml:segments><gml:ArcString><gml:posList srsDimension="2">-2 0 -1 -1 0 0 1 -1 2 0 0 2 -2 0</gml:posList></gml:ArcString></gml:segments></gml:Curve></gml:curveMember></gml:exterior><gml:interior><gml:LinearRing><gml:posList srsDimension="2">-1 0 0 0.5 1 0 0 1 -1 0</gml:posList></gml:LinearRing></gml:interior></gml:Polygon>
+gml_out_curve_04|<gml:MultiCurve><gml:curveMember><gml:Curve><gml:segments><gml:LineStringSegment><gml:posList srsDimension="2">5 5 3 5 3 3 0 3</gml:posList></gml:LineStringSegment></gml:segments></gml:Curve></gml:curveMember><gml:curveMember><gml:Curve><gml:segments><gml:ArcString><gml:posList srsDimension="2">0 0 2 1 2 2</gml:posList></gml:ArcString></gml:segments></gml:Curve></gml:curveMember></gml:MultiCurve>
+gml_out_curve_05|<gml:MultiSurface><gml:Polygon><gml:exterior><gml:curveMember><gml:Curve><gml:segments><gml:ArcString><gml:posList srsDimension="2">-2 0 -1 -1 0 0 1 -1 2 0 0 2 -2 0</gml:posList></gml:ArcString></gml:segments></gml:Curve></gml:curveMember></gml:exterior><gml:interior><gml:LinearRing><gml:posList srsDimension="2">-1 0 0 0.5 1 0 0 1 -1 0</gml:posList></gml:LinearRing></gml:interior></gml:Polygon><gml:Polygon><gml:exterior><gml:LinearRing><gml:posList srsDimension="2">7 8 10 10 6 14 4 11 7 8</gml:posList></gml:LinearRing></gml:exterior></gml:Polygon></gml:MultiSurface>
 ERROR:  GetProj4StringSPI: Cannot find SRID (10) in spatial_ref_sys
 ERROR:  Input geometry has unknown (0) SRID
 kml_empty_geom|
