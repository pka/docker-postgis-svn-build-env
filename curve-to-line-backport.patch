diff --git a/Version.config b/Version.config
index 6c55767..ffe17d7 100644
--- a/Version.config
+++ b/Version.config
@@ -5,7 +5,7 @@
 
 POSTGIS_MAJOR_VERSION=2
 POSTGIS_MINOR_VERSION=2
-POSTGIS_MICRO_VERSION=6dev
+POSTGIS_MICRO_VERSION=6dev-curve-to-line-backport
 
 # Liblwgeom interface versioning, reset to 0:0:0 (cur:age:rev)
 # when changing POSTGIS_MINOR_VERSION
diff --git a/liblwgeom/liblwgeom.h.in b/liblwgeom/liblwgeom.h.in
index a2b8edb..37aae15 100644
--- a/liblwgeom/liblwgeom.h.in
+++ b/liblwgeom/liblwgeom.h.in
@@ -2045,6 +2045,73 @@ int lwgeom_has_arc(const LWGEOM *geom);
 LWGEOM *lwgeom_stroke(const LWGEOM *geom, uint32_t perQuad);
 LWGEOM *lwgeom_unstroke(const LWGEOM *geom);
 
+/**
+ * Semantic of the `tolerance` argument passed to
+ * lwcurve_linearize
+ */
+typedef enum {
+	/**
+	 * Tolerance expresses the number of segments to use
+	 * for each quarter of circle (quadrant). Must be
+	 * an integer.
+	 */
+	LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD = 0,
+	/**
+	 * Tolerance expresses the maximum distance between
+	 * an arbitrary point on the curve and the closest
+	 * point to it on the resulting approximation, in
+	 * cartesian units.
+	 */
+	LW_LINEARIZE_TOLERANCE_TYPE_MAX_DEVIATION = 1,
+	/**
+	 * Tolerance expresses the maximum angle between
+	 * the radii generating approximation line vertices,
+	 * given in radiuses. A value of 1 would result
+	 * in an approximation of a semicircle composed by
+	 * 180 segments
+	 */
+	LW_LINEARIZE_TOLERANCE_TYPE_MAX_ANGLE = 2
+} LW_LINEARIZE_TOLERANCE_TYPE;
+
+typedef enum {
+  /**
+   * Symmetric linearization means that the output
+   * vertices would be the same no matter the order
+   * of the points defining the input curve.
+   */
+	LW_LINEARIZE_FLAG_SYMMETRIC = 1 << 0,
+
+  /**
+   * Retain angle instructs the engine to try its best
+   * to retain the requested angle between generating
+   * radii (where angle can be given explicitly with
+   * LW_LINEARIZE_TOLERANCE_TYPE_MAX_ANGLE or implicitly
+   * with LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD or
+   * LW_LINEARIZE_TOLERANCE_TYPE_MAX_DEVIATION).
+   *
+   * It only makes sense with LW_LINEARIZE_FLAG_SYMMETRIC
+   * which would otherwise reduce the angle as needed to
+   * keep it constant among all radiis so that all
+   * segments are of the same length.
+   *
+   * When this flag is set, the first and last generating
+   * angles (and thus the first and last segments) may
+   * instead be smaller (shorter) than the others.
+   *
+   */
+	LW_LINEARIZE_FLAG_RETAIN_ANGLE = 1 << 1
+} LW_LINEARIZE_FLAGS;
+
+/**
+ * @param geom input geometry
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags bitwise OR of operational flags, see LW_LINEARIZE_FLAGS
+ *
+ * @return a newly allocated LWGEOM
+ */
+extern LWGEOM* lwcurve_linearize(const LWGEOM *geom, double tol, LW_LINEARIZE_TOLERANCE_TYPE type, int flags);
+
 /*******************************************************************************
  * GEOS proxy functions on LWGEOM
  ******************************************************************************/
diff --git a/liblwgeom/lwstroke.c b/liblwgeom/lwstroke.c
index 6e4f7bd..af89f4c 100644
--- a/liblwgeom/lwstroke.c
+++ b/liblwgeom/lwstroke.c
@@ -2,13 +2,28 @@
  *
  * PostGIS - Spatial Types for PostgreSQL
  * http://postgis.net
- * Copyright 2001-2006 Refractions Research Inc.
  *
- * This is free software; you can redistribute and/or modify it under
- * the terms of the GNU General Public Licence. See the COPYING file.
+ * PostGIS is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * PostGIS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with PostGIS.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ **********************************************************************
+ *
+ * Copyright (C) 2001-2006 Refractions Research Inc.
+ * Copyright (C) 2017      Sandro Santilli <strk@kbt.io>
  *
  **********************************************************************/
 
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
@@ -16,15 +31,11 @@
 
 #include "liblwgeom_internal.h"
 
-/* #define POSTGIS_DEBUG_LEVEL 4 */
+/*#define POSTGIS_DEBUG_LEVEL 3*/
 
 #include "lwgeom_log.h"
 
 
-LWMLINE* lwmcurve_stroke(const LWMCURVE *mcurve, uint32_t perQuad);
-LWMPOLY* lwmsurface_stroke(const LWMSURFACE *msurface, uint32_t perQuad);
-LWCOLLECTION* lwcollection_stroke(const LWCOLLECTION *collection, uint32_t perQuad);
-
 LWGEOM* pta_unstroke(const POINTARRAY *points, int type, int srid);
 LWGEOM* lwline_unstroke(const LWLINE *line);
 LWGEOM* lwpolygon_unstroke(const LWPOLY *poly);
@@ -64,7 +75,7 @@ lwgeom_has_arc(const LWGEOM *geom)
 		col = (LWCOLLECTION *)geom;
 		for (i=0; i<col->ngeoms; i++)
 		{
-			if (lwgeom_has_arc(col->geoms[i]) == LW_TRUE) 
+			if (lwgeom_has_arc(col->geoms[i]) == LW_TRUE)
 				return LW_TRUE;
 		}
 		return LW_FALSE;
@@ -98,8 +109,25 @@ static double interpolate_arc(double angle, double a1, double a2, double a3, dou
 	}
 }
 
-static POINTARRAY *
-lwcircle_stroke(const POINT4D *p1, const POINT4D *p2, const POINT4D *p3, uint32_t perQuad)
+/**
+ * Segmentize an arc
+ *
+ * @param to POINTARRAY to append segmentized vertices to
+ * @param p1 first point defining the arc
+ * @param p2 second point defining the arc
+ * @param p3 third point defining the arc
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags LW_LINEARIZE_FLAGS
+ *
+ * @return number of points appended (0 if collinear),
+ *         or -1 on error (lwerror would be called).
+ */
+static int
+lwarc_linearize(POINTARRAY *to,
+                 const POINT4D *p1, const POINT4D *p2, const POINT4D *p3,
+                 double tol, LW_LINEARIZE_TOLERANCE_TYPE tolerance_type,
+                 int flags)
 {
 	POINT2D center;
 	POINT2D *t1 = (POINT2D*)p1;
@@ -110,41 +138,126 @@ lwcircle_stroke(const POINT4D *p1, const POINT4D *p2, const POINT4D *p3, uint32_
 	int clockwise = LW_TRUE;
 	double radius; /* Arc radius */
 	double increment; /* Angle per segment */
+	double angle_shift = 0;
 	double a1, a2, a3, angle;
-	POINTARRAY *pa;
+	POINTARRAY *pa = to;
 	int is_circle = LW_FALSE;
+	int points_added = 0;
 
-	LWDEBUG(2, "lwcircle_calculate_gbox called.");
+	LWDEBUG(2, "lwarc_linearize called.");
 
 	radius = lw_arc_center(t1, t2, t3, &center);
+	LWDEBUGF(2, " center is POINT(%.15g %.15g) - radius:%g", center.x, center.y, radius);
 	p2_side = lw_segment_side(t1, t3, t2);
 
 	/* Matched start/end points imply circle */
 	if ( p1->x == p3->x && p1->y == p3->y )
 		is_circle = LW_TRUE;
-	
+
 	/* Negative radius signals straight line, p1/p2/p3 are colinear */
 	if ( (radius < 0.0 || p2_side == 0) && ! is_circle )
-	    return NULL;
-		
-	/* The side of the p1/p3 line that p2 falls on dictates the sweep  
+	    return 0;
+
+	/* The side of the p1/p3 line that p2 falls on dictates the sweep
 	   direction from p1 to p3. */
 	if ( p2_side == -1 )
 		clockwise = LW_TRUE;
 	else
 		clockwise = LW_FALSE;
-		
-	increment = fabs(M_PI_2 / perQuad);
-	
+
+	if ( tolerance_type == LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD )
+	{{
+		int perQuad = rint(tol);
+		// error out if tol != perQuad ? (not-round)
+		if ( perQuad != tol )
+		{
+			lwerror("lwarc_linearize: segments per quadrant must be an integer value, got %.15g", tol, perQuad);
+			return -1;
+		}
+		if ( perQuad < 1 )
+		{
+			lwerror("lwarc_linearize: segments per quadrant must be at least 1, got %d", perQuad);
+			return -1;
+		}
+		increment = fabs(M_PI_2 / perQuad);
+		LWDEBUGF(2, "lwarc_linearize: perQuad:%d, increment:%g (%g degrees)", perQuad, increment, increment*180/M_PI);
+
+	}}
+	else if ( tolerance_type == LW_LINEARIZE_TOLERANCE_TYPE_MAX_DEVIATION )
+	{{
+		double halfAngle;
+		if ( tol <= 0 )
+		{
+			lwerror("lwarc_linearize: max deviation must be bigger than 0, got %.15g", tol);
+			return -1;
+		}
+		halfAngle = acos( -tol / radius + 1 );
+		increment = 2 * halfAngle;
+		LWDEBUGF(2, "lwarc_linearize: maxDiff:%g, radius:%g, halfAngle:%g, increment:%g (%g degrees)", tol, radius, halfAngle, increment, increment*180/M_PI);
+	}}
+	else if ( tolerance_type == LW_LINEARIZE_TOLERANCE_TYPE_MAX_ANGLE )
+	{
+		increment = tol;
+		if ( increment <= 0 )
+		{
+			lwerror("lwarc_linearize: max angle must be bigger than 0, got %.15g", tol);
+			return -1;
+		}
+	}
+	else
+	{
+		lwerror("lwarc_linearize: unsupported tolerance type %d", tolerance_type);
+		return LW_FALSE;
+	}
+
 	/* Angles of each point that defines the arc section */
 	a1 = atan2(p1->y - center.y, p1->x - center.x);
 	a2 = atan2(p2->y - center.y, p2->x - center.x);
 	a3 = atan2(p3->y - center.y, p3->x - center.x);
 
+	LWDEBUGF(2, "lwarc_linearize A1:%g A2:%g A3:%g",
+		a1*180/M_PI, a2*180/M_PI, a3*180/M_PI);
+
+	if ( flags & LW_LINEARIZE_FLAG_SYMMETRIC )
+	{{
+		/* Calculate total arc angle, in radians */
+		double angle = clockwise ? a1 - a3 : a3 - a1;
+		if ( angle < 0 ) angle += M_PI * 2;
+		LWDEBUGF(2, "lwarc_linearize SYMMETRIC requested - total angle %g deg",
+			         angle * 180 / M_PI);
+		if ( flags & LW_LINEARIZE_FLAG_RETAIN_ANGLE )
+		{{
+			/* Number of steps */
+			int steps = trunc(angle / increment);
+			/* Angle reminder */
+			double angle_reminder = angle - ( increment * steps );
+			angle_shift = angle_reminder / 2.0;
+
+			LWDEBUGF(2, "lwarc_linearize RETAIN_ANGLE operation requested - "
+			         "total angle %g, steps %d, increment %g, reminder %g",
+			         angle * 180 / M_PI, steps, increment * 180 / M_PI,
+			         angle_reminder * 180 / M_PI);
+		}}
+		else
+		{{
+			/* Number of segments in output */
+			int segs = ceil(angle / increment);
+			/* Tweak increment to be regular for all the arc */
+			increment = angle/segs;
+
+			LWDEBUGF(2, "lwarc_linearize SYMMETRIC operation requested - "
+							"total angle %g degrees - LINESTRING(%g %g,%g %g,%g %g) - S:%d -   I:%g",
+							angle*180/M_PI, p1->x, p1->y, center.x, center.y, p3->x, p3->y,
+							segs, increment*180/M_PI);
+		}}
+	}}
+
 	/* p2 on left side => clockwise sweep */
 	if ( clockwise )
 	{
+		LWDEBUG(2, " Clockwise sweep");
 		increment *= -1;
+		angle_shift *= -1;
 		/* Adjust a3 down so we can decrement from a1 to a3 cleanly */
 		if ( a3 > a1 )
 			a3 -= 2.0 * M_PI;
@@ -154,13 +267,14 @@ lwcircle_stroke(const POINT4D *p1, const POINT4D *p2, const POINT4D *p3, uint32_
 	/* p2 on right side => counter-clockwise sweep */
 	else
 	{
+		LWDEBUG(2, " Counterclockwise sweep");
 		/* Adjust a3 up so we can increment from a1 to a3 cleanly */
 		if ( a3 < a1 )
 			a3 += 2.0 * M_PI;
 		if ( a2 < a1 )
 			a2 += 2.0 * M_PI;
 	}
-	
+
 	/* Override angles for circle case */
 	if( is_circle )
 	{
@@ -169,59 +283,69 @@ lwcircle_stroke(const POINT4D *p1, const POINT4D *p2, const POINT4D *p3, uint32_
 		increment = fabs(increment);
 		clockwise = LW_FALSE;
 	}
-	
-	/* Initialize point array */
-	pa = ptarray_construct_empty(1, 1, 32);
+
+	LWDEBUGF(2, "lwarc_linearize angle_shift:%g, increment:%g",
+		angle_shift * 180/M_PI, increment * 180/M_PI);
 
 	/* Sweep from a1 to a3 */
 	ptarray_append_point(pa, p1, LW_FALSE);
-	for ( angle = a1 + increment; clockwise ? angle > a3 : angle < a3; angle += increment ) 
+	++points_added;
+	if ( angle_shift ) angle_shift -= increment;
+	LWDEBUGF(2, "a1:%g (%g deg), a3:%g (%g deg), inc:%g, shi:%g, cw:%d",
+		a1, a1 * 180 / M_PI, a3, a3 * 180 / M_PI, increment, angle_shift, clockwise);
+	for ( angle = a1 + increment + angle_shift; clockwise ? angle > a3 : angle < a3; angle += increment )
 	{
+		LWDEBUGF(2, " SA: %g ( %g deg )", angle, angle*180/M_PI);
 		pt.x = center.x + radius * cos(angle);
 		pt.y = center.y + radius * sin(angle);
 		pt.z = interpolate_arc(angle, a1, a2, a3, p1->z, p2->z, p3->z);
 		pt.m = interpolate_arc(angle, a1, a2, a3, p1->m, p2->m, p3->m);
 		ptarray_append_point(pa, &pt, LW_FALSE);
-	}	
-	return pa;
+		++points_added;
+		angle_shift = 0;
+	}
+	return points_added;
 }
 
-LWLINE *
-lwcircstring_stroke(const LWCIRCSTRING *icurve, uint32_t perQuad)
+/*
+ * @param icurve input curve
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWLINE
+ */
+static LWLINE *
+lwcircstring_linearize(const LWCIRCSTRING *icurve, double tol,
+                        LW_LINEARIZE_TOLERANCE_TYPE tolerance_type,
+                        int flags)
 {
 	LWLINE *oline;
 	POINTARRAY *ptarray;
-	POINTARRAY *tmp;
 	uint32_t i, j;
 	POINT4D p1, p2, p3, p4;
+	int ret;
 
-	LWDEBUGF(2, "lwcircstring_stroke called., dim = %d", icurve->points->flags);
+	LWDEBUGF(2, "lwcircstring_linearize called., dim = %d", icurve->points->flags);
 
 	ptarray = ptarray_construct_empty(FLAGS_GET_Z(icurve->points->flags), FLAGS_GET_M(icurve->points->flags), 64);
 
 	for (i = 2; i < icurve->points->npoints; i+=2)
 	{
-		LWDEBUGF(3, "lwcircstring_stroke: arc ending at point %d", i);
+		LWDEBUGF(3, "lwcircstring_linearize: arc ending at point %d", i);
 
 		getPoint4d_p(icurve->points, i - 2, &p1);
 		getPoint4d_p(icurve->points, i - 1, &p2);
 		getPoint4d_p(icurve->points, i, &p3);
-		tmp = lwcircle_stroke(&p1, &p2, &p3, perQuad);
 
-		if (tmp)
+		ret = lwarc_linearize(ptarray, &p1, &p2, &p3, tol, tolerance_type, flags);
+		if ( ret > 0 )
 		{
-			LWDEBUGF(3, "lwcircstring_stroke: generated %d points", tmp->npoints);
-
-			for (j = 0; j < tmp->npoints; j++)
-			{
-				getPoint4d_p(tmp, j, &p4);
-				ptarray_append_point(ptarray, &p4, LW_TRUE);
-			}
-			ptarray_free(tmp);
+			LWDEBUGF(3, "lwcircstring_linearize: generated %d points", ptarray->npoints);
 		}
-		else
+		else if ( ret == 0 )
 		{
-			LWDEBUG(3, "lwcircstring_stroke: points are colinear, returning curve points as line");
+			LWDEBUG(3, "lwcircstring_linearize: points are colinear, returning curve points as line");
 
 			for (j = i - 2 ; j < i ; j++)
 			{
@@ -229,17 +353,32 @@ lwcircstring_stroke(const LWCIRCSTRING *icurve, uint32_t perQuad)
 				ptarray_append_point(ptarray, &p4, LW_TRUE);
 			}
 		}
-
+		else
+		{
+			/* An error occurred, lwerror should have been called by now */
+			ptarray_free(ptarray);
+			return NULL;
+		}
 	}
 	getPoint4d_p(icurve->points, icurve->points->npoints-1, &p1);
 	ptarray_append_point(ptarray, &p1, LW_TRUE);
-		
+
 	oline = lwline_construct(icurve->srid, NULL, ptarray);
 	return oline;
 }
 
-LWLINE *
-lwcompound_stroke(const LWCOMPOUND *icompound, uint32_t perQuad)
+/*
+ * @param icompound input compound curve
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWLINE
+ */
+static LWLINE *
+lwcompound_linearize(const LWCOMPOUND *icompound, double tol,
+                      LW_LINEARIZE_TOLERANCE_TYPE tolerance_type,
+                      int flags)
 {
 	LWGEOM *geom;
 	POINTARRAY *ptarray = NULL, *ptarray_out = NULL;
@@ -256,7 +395,7 @@ lwcompound_stroke(const LWCOMPOUND *icompound, uint32_t perQuad)
 		geom = icompound->geoms[i];
 		if (geom->type == CIRCSTRINGTYPE)
 		{
-			tmp = lwcircstring_stroke((LWCIRCSTRING *)geom, perQuad);
+			tmp = lwcircstring_linearize((LWCIRCSTRING *)geom, tol, tolerance_type, flags);
 			for (j = 0; j < tmp->points->npoints; j++)
 			{
 				getPoint4d_p(tmp->points, j, &p);
@@ -285,8 +424,26 @@ lwcompound_stroke(const LWCOMPOUND *icompound, uint32_t perQuad)
 	return lwline_construct(icompound->srid, NULL, ptarray_out);
 }
 
-LWPOLY *
-lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
+/* Kept for backward compatibility - TODO: drop */
+LWLINE *
+lwcompound_stroke(const LWCOMPOUND *icompound, uint32_t perQuad)
+{
+		return lwcompound_linearize(icompound, perQuad, LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD, 0);
+}
+
+
+/*
+ * @param icompound input curve polygon
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWPOLY
+ */
+static LWPOLY *
+lwcurvepoly_linearize(const LWCURVEPOLY *curvepoly, double tol,
+                       LW_LINEARIZE_TOLERANCE_TYPE tolerance_type,
+                       int flags)
 {
 	LWPOLY *ogeom;
 	LWGEOM *tmp;
@@ -294,7 +451,7 @@ lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
 	POINTARRAY **ptarray;
 	int i;
 
-	LWDEBUG(2, "lwcurvepoly_stroke called.");
+	LWDEBUG(2, "lwcurvepoly_linearize called.");
 
 	ptarray = lwalloc(sizeof(POINTARRAY *)*curvepoly->nrings);
 
@@ -303,7 +460,7 @@ lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
 		tmp = curvepoly->rings[i];
 		if (tmp->type == CIRCSTRINGTYPE)
 		{
-			line = lwcircstring_stroke((LWCIRCSTRING *)tmp, perQuad);
+			line = lwcircstring_linearize((LWCIRCSTRING *)tmp, tol, tolerance_type, flags);
 			ptarray[i] = ptarray_clone_deep(line->points);
 			lwline_free(line);
 		}
@@ -314,7 +471,7 @@ lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
 		}
 		else if (tmp->type == COMPOUNDTYPE)
 		{
-			line = lwcompound_stroke((LWCOMPOUND *)tmp, perQuad);
+			line = lwcompound_linearize((LWCOMPOUND *)tmp, tol, tolerance_type, flags);
 			ptarray[i] = ptarray_clone_deep(line->points);
 			lwline_free(line);
 		}
@@ -329,14 +486,32 @@ lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
 	return ogeom;
 }
 
-LWMLINE *
-lwmcurve_stroke(const LWMCURVE *mcurve, uint32_t perQuad)
+/* Kept for backward compatibility - TODO: drop */
+LWPOLY *
+lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
+{
+		return lwcurvepoly_linearize(curvepoly, perQuad, LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD, 0);
+}
+
+
+/**
+ * @param mcurve input compound curve
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWMLINE
+ */
+static LWMLINE *
+lwmcurve_linearize(const LWMCURVE *mcurve, double tol,
+                    LW_LINEARIZE_TOLERANCE_TYPE type,
+                    int flags)
 {
 	LWMLINE *ogeom;
 	LWGEOM **lines;
 	int i;
 
-	LWDEBUGF(2, "lwmcurve_stroke called, geoms=%d, dim=%d.", mcurve->ngeoms, FLAGS_NDIMS(mcurve->flags));
+	LWDEBUGF(2, "lwmcurve_linearize called, geoms=%d, dim=%d.", mcurve->ngeoms, FLAGS_NDIMS(mcurve->flags));
 
 	lines = lwalloc(sizeof(LWGEOM *)*mcurve->ngeoms);
 
@@ -345,7 +520,7 @@ lwmcurve_stroke(const LWMCURVE *mcurve, uint32_t perQuad)
 		const LWGEOM *tmp = mcurve->geoms[i];
 		if (tmp->type == CIRCSTRINGTYPE)
 		{
-			lines[i] = (LWGEOM *)lwcircstring_stroke((LWCIRCSTRING *)tmp, perQuad);
+			lines[i] = (LWGEOM *)lwcircstring_linearize((LWCIRCSTRING *)tmp, tol, type, flags);
 		}
 		else if (tmp->type == LINETYPE)
 		{
@@ -353,7 +528,7 @@ lwmcurve_stroke(const LWMCURVE *mcurve, uint32_t perQuad)
 		}
 		else if (tmp->type == COMPOUNDTYPE)
 		{
-			lines[i] = (LWGEOM *)lwcompound_stroke((LWCOMPOUND *)tmp, perQuad);
+			lines[i] = (LWGEOM *)lwcompound_linearize((LWCOMPOUND *)tmp, tol, type, flags);
 		}
 		else
 		{
@@ -366,8 +541,18 @@ lwmcurve_stroke(const LWMCURVE *mcurve, uint32_t perQuad)
 	return ogeom;
 }
 
-LWMPOLY *
-lwmsurface_stroke(const LWMSURFACE *msurface, uint32_t perQuad)
+/**
+ * @param msurface input multi surface
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWMPOLY
+ */
+static LWMPOLY *
+lwmsurface_linearize(const LWMSURFACE *msurface, double tol,
+                      LW_LINEARIZE_TOLERANCE_TYPE type,
+                      int flags)
 {
 	LWMPOLY *ogeom;
 	LWGEOM *tmp;
@@ -376,7 +561,7 @@ lwmsurface_stroke(const LWMSURFACE *msurface, uint32_t perQuad)
 	POINTARRAY **ptarray;
 	int i, j;
 
-	LWDEBUG(2, "lwmsurface_stroke called.");
+	LWDEBUG(2, "lwmsurface_linearize called.");
 
 	polys = lwalloc(sizeof(LWGEOM *)*msurface->ngeoms);
 
@@ -385,7 +570,7 @@ lwmsurface_stroke(const LWMSURFACE *msurface, uint32_t perQuad)
 		tmp = msurface->geoms[i];
 		if (tmp->type == CURVEPOLYTYPE)
 		{
-			polys[i] = (LWGEOM *)lwcurvepoly_stroke((LWCURVEPOLY *)tmp, perQuad);
+			polys[i] = (LWGEOM *)lwcurvepoly_linearize((LWCURVEPOLY *)tmp, tol, type, flags);
 		}
 		else if (tmp->type == POLYGONTYPE)
 		{
@@ -402,15 +587,25 @@ lwmsurface_stroke(const LWMSURFACE *msurface, uint32_t perQuad)
 	return ogeom;
 }
 
-LWCOLLECTION *
-lwcollection_stroke(const LWCOLLECTION *collection, uint32_t perQuad)
+/**
+ * @param collection input geometry collection
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWCOLLECTION
+ */
+static LWCOLLECTION *
+lwcollection_linearize(const LWCOLLECTION *collection, double tol,
+                    LW_LINEARIZE_TOLERANCE_TYPE type,
+                    int flags)
 {
 	LWCOLLECTION *ocol;
 	LWGEOM *tmp;
 	LWGEOM **geoms;
 	int i;
 
-	LWDEBUG(2, "lwcollection_stroke called.");
+	LWDEBUG(2, "lwcollection_linearize called.");
 
 	geoms = lwalloc(sizeof(LWGEOM *)*collection->ngeoms);
 
@@ -420,18 +615,18 @@ lwcollection_stroke(const LWCOLLECTION *collection, uint32_t perQuad)
 		switch (tmp->type)
 		{
 		case CIRCSTRINGTYPE:
-			geoms[i] = (LWGEOM *)lwcircstring_stroke((LWCIRCSTRING *)tmp, perQuad);
+			geoms[i] = (LWGEOM *)lwcircstring_linearize((LWCIRCSTRING *)tmp, tol, type, flags);
 			break;
 		case COMPOUNDTYPE:
-			geoms[i] = (LWGEOM *)lwcompound_stroke((LWCOMPOUND *)tmp, perQuad);
+			geoms[i] = (LWGEOM *)lwcompound_linearize((LWCOMPOUND *)tmp, tol, type, flags);
 			break;
 		case CURVEPOLYTYPE:
-			geoms[i] = (LWGEOM *)lwcurvepoly_stroke((LWCURVEPOLY *)tmp, perQuad);
+			geoms[i] = (LWGEOM *)lwcurvepoly_linearize((LWCURVEPOLY *)tmp, tol, type, flags);
 			break;
 		case MULTICURVETYPE:
 		case MULTISURFACETYPE:
 		case COLLECTIONTYPE:
-			geoms[i] = (LWGEOM *)lwcollection_stroke((LWCOLLECTION *)tmp, perQuad);
+			geoms[i] = (LWGEOM *)lwcollection_linearize((LWCOLLECTION *)tmp, tol, type, flags);
 			break;
 		default:
 			geoms[i] = lwgeom_clone(tmp);
@@ -443,28 +638,30 @@ lwcollection_stroke(const LWCOLLECTION *collection, uint32_t perQuad)
 }
 
 LWGEOM *
-lwgeom_stroke(const LWGEOM *geom, uint32_t perQuad)
+lwcurve_linearize(const LWGEOM *geom, double tol,
+                  LW_LINEARIZE_TOLERANCE_TYPE type,
+                  int flags)
 {
 	LWGEOM * ogeom = NULL;
 	switch (geom->type)
 	{
 	case CIRCSTRINGTYPE:
-		ogeom = (LWGEOM *)lwcircstring_stroke((LWCIRCSTRING *)geom, perQuad);
+		ogeom = (LWGEOM *)lwcircstring_linearize((LWCIRCSTRING *)geom, tol, type, flags);
 		break;
 	case COMPOUNDTYPE:
-		ogeom = (LWGEOM *)lwcompound_stroke((LWCOMPOUND *)geom, perQuad);
+		ogeom = (LWGEOM *)lwcompound_linearize((LWCOMPOUND *)geom, tol, type, flags);
 		break;
 	case CURVEPOLYTYPE:
-		ogeom = (LWGEOM *)lwcurvepoly_stroke((LWCURVEPOLY *)geom, perQuad);
+		ogeom = (LWGEOM *)lwcurvepoly_linearize((LWCURVEPOLY *)geom, tol, type, flags);
 		break;
 	case MULTICURVETYPE:
-		ogeom = (LWGEOM *)lwmcurve_stroke((LWMCURVE *)geom, perQuad);
+		ogeom = (LWGEOM *)lwmcurve_linearize((LWMCURVE *)geom, tol, type, flags);
 		break;
 	case MULTISURFACETYPE:
-		ogeom = (LWGEOM *)lwmsurface_stroke((LWMSURFACE *)geom, perQuad);
+		ogeom = (LWGEOM *)lwmsurface_linearize((LWMSURFACE *)geom, tol, type, flags);
 		break;
 	case COLLECTIONTYPE:
-		ogeom = (LWGEOM *)lwcollection_stroke((LWCOLLECTION *)geom, perQuad);
+		ogeom = (LWGEOM *)lwcollection_linearize((LWCOLLECTION *)geom, tol, type, flags);
 		break;
 	default:
 		ogeom = lwgeom_clone(geom);
@@ -472,6 +669,13 @@ lwgeom_stroke(const LWGEOM *geom, uint32_t perQuad)
 	return ogeom;
 }
 
+/* Kept for backward compatibility - TODO: drop */
+LWGEOM *
+lwgeom_stroke(const LWGEOM *geom, uint32_t perQuad)
+{
+	return lwcurve_linearize(geom, perQuad, LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD, 0);
+}
+
 /**
  * Return ABC angle in radians
  * TODO: move to lwalgorithm
@@ -516,9 +720,9 @@ static int pt_continues_arc(const POINT4D *a1, const POINT4D *a2, const POINT4D
 	b_distance = distance2d_pt_pt(tb, &center);
 	diff = fabs(radius - b_distance);
 	LWDEBUGF(4, "circle_radius=%g, b_distance=%g, diff=%g, percentage=%g", radius, b_distance, diff, diff/radius);
-	
+
 	/* Is the point b on the circle? */
-	if ( diff < EPSILON_SQLMM ) 
+	if ( diff < EPSILON_SQLMM )
 	{
 		int a2_side = lw_segment_side(t1, t3, t2);
 		int b_side  = lw_segment_side(t1, t3, tb);
@@ -528,7 +732,7 @@ static int pt_continues_arc(const POINT4D *a1, const POINT4D *a2, const POINT4D
 		/* Is the angle similar to the previous one ? */
 		diff = fabs(angle1 - angle2);
 		LWDEBUGF(4, " angle1: %g, angle2: %g, diff:%g", angle1, angle2, diff);
-		if ( diff > EPSILON_SQLMM ) 
+		if ( diff > EPSILON_SQLMM )
 		{
 			return LW_FALSE;
 		}
@@ -551,7 +755,7 @@ linestring_from_pa(const POINTARRAY *pa, int srid, int start, int end)
 	for( i = start; i < end + 2; i++ )
 	{
 		getPoint4d_p(pa, i, &p);
-		ptarray_set_point4d(pao, j++, &p);	
+		ptarray_set_point4d(pao, j++, &p);
 	}
 	return lwline_as_lwgeom(lwline_construct(srid, NULL, pao));
 }
@@ -559,16 +763,16 @@ linestring_from_pa(const POINTARRAY *pa, int srid, int start, int end)
 static LWGEOM*
 circstring_from_pa(const POINTARRAY *pa, int srid, int start, int end)
 {
-	
+
 	POINT4D p0, p1, p2;
 	POINTARRAY *pao = ptarray_construct(ptarray_has_z(pa), ptarray_has_m(pa), 3);
 	LWDEBUGF(4, "srid=%d, start=%d, end=%d", srid, start, end);
 	getPoint4d_p(pa, start, &p0);
-	ptarray_set_point4d(pao, 0, &p0);	
+	ptarray_set_point4d(pao, 0, &p0);
 	getPoint4d_p(pa, (start+end+1)/2, &p1);
-	ptarray_set_point4d(pao, 1, &p1);	
+	ptarray_set_point4d(pao, 1, &p1);
 	getPoint4d_p(pa, end+1, &p2);
-	ptarray_set_point4d(pao, 2, &p2);	
+	ptarray_set_point4d(pao, 2, &p2);
 	return lwcircstring_as_lwgeom(lwcircstring_construct(srid, NULL, pao));
 }
 
@@ -605,19 +809,19 @@ pta_unstroke(const POINTARRAY *points, int type, int srid)
 	/* Null on empty input? */
 	if ( points->npoints == 0 )
 		return NULL;
-	
+
 	/* We can't desegmentize anything shorter than four points */
 	if ( points->npoints < 4 )
 	{
 		/* Return a linestring here*/
 		lwerror("pta_unstroke needs implementation for npoints < 4");
 	}
-	
+
 	/* Allocate our result array of vertices that are part of arcs */
 	num_edges = points->npoints - 1;
 	edges_in_arcs = lwalloc(num_edges + 1);
 	memset(edges_in_arcs, 0, num_edges + 1);
-	
+
 	/* We make a candidate arc of the first two edges, */
 	/* And then see if the next edge follows it */
 	while( i < num_edges-2 )
@@ -675,7 +879,7 @@ pta_unstroke(const POINTARRAY *points, int type, int srid)
 				lw_arc_center((POINT2D*)&first, (POINT2D*)&b, (POINT2D*)&a1, (POINT2D*)&center);
 				angle = lw_arc_angle((POINT2D*)&first, (POINT2D*)&center, (POINT2D*)&b);
         int p2_side = lw_segment_side((POINT2D*)&first, (POINT2D*)&a1, (POINT2D*)&b);
-        if ( p2_side >= 0 ) angle = -angle; 
+        if ( p2_side >= 0 ) angle = -angle;
 
 				if ( angle < 0 ) angle = 2 * M_PI + angle;
 				num_quadrants = ( 4 * angle ) / ( 2 * M_PI );
@@ -697,7 +901,7 @@ pta_unstroke(const POINTARRAY *points, int type, int srid)
 			i = i+1;
 		}
 	}
-	
+
 #if POSTGIS_DEBUG_LEVEL > 3
 	{
 		char *edgestr = lwalloc(num_edges+1);
@@ -732,7 +936,7 @@ pta_unstroke(const POINTARRAY *points, int type, int srid)
 	/* Roll out last item */
 	end = num_edges - 1;
 	lwcollection_add_lwgeom(outcol, geom_from_pa(points, srid, edge_type, start, end));
-	
+
 	/* Strip down to singleton if only one entry */
 	if ( outcol->ngeoms == 1 )
 	{
@@ -810,7 +1014,7 @@ lwmline_unstroke(const LWMLINE *mline)
 	return (LWGEOM *)lwcollection_construct(MULTICURVETYPE, mline->srid, NULL, mline->ngeoms, geoms);
 }
 
-LWGEOM * 
+LWGEOM *
 lwmpolygon_unstroke(const LWMPOLY *mpoly)
 {
 	LWGEOM **geoms;
diff --git a/postgis/lwgeom_sqlmm.c b/postgis/lwgeom_sqlmm.c
index af59249..ea1c9d3 100644
--- a/postgis/lwgeom_sqlmm.c
+++ b/postgis/lwgeom_sqlmm.c
@@ -48,6 +48,8 @@ Datum LWGEOM_has_arc(PG_FUNCTION_ARGS)
  * Curve centers are determined by projecting the defining points into the 2d
  * plane.  Z and M values are assigned by linear interpolation between
  * defining points.
+ *
+ * TODO: drop, use ST_CurveToLine instead
  */
 PG_FUNCTION_INFO_V1(LWGEOM_curve_segmentize);
 Datum LWGEOM_curve_segmentize(PG_FUNCTION_ARGS)
@@ -70,10 +72,37 @@ Datum LWGEOM_curve_segmentize(PG_FUNCTION_ARGS)
 	igeom = lwgeom_from_gserialized(geom);
 	ogeom = lwgeom_stroke(igeom, perQuad);
 	lwgeom_free(igeom);
-	
-	if (ogeom == NULL) 
+
+	if (ogeom == NULL)
 		PG_RETURN_NULL();
-		
+
+	ret = geometry_serialize(ogeom);
+	lwgeom_free(ogeom);
+	PG_FREE_IF_COPY(geom, 0);
+	PG_RETURN_POINTER(ret);
+}
+
+PG_FUNCTION_INFO_V1(ST_CurveToLine);
+Datum ST_CurveToLine(PG_FUNCTION_ARGS)
+{
+	GSERIALIZED *geom = PG_GETARG_GSERIALIZED_P(0);
+	double tol = PG_GETARG_FLOAT8(1);
+	int toltype = PG_GETARG_INT32(2);
+	int flags = PG_GETARG_INT32(3);
+	GSERIALIZED *ret;
+	LWGEOM *igeom = NULL, *ogeom = NULL;
+
+	POSTGIS_DEBUG(2, "ST_CurveToLine called.");
+
+	POSTGIS_DEBUGF(3, "tol = %g, typ = %d, flg = %d", tol, toltype, flags);
+
+	igeom = lwgeom_from_gserialized(geom);
+	ogeom = lwcurve_linearize(igeom, tol, toltype, flags);
+	lwgeom_free(igeom);
+
+	if (ogeom == NULL)
+		PG_RETURN_NULL();
+
 	ret = geometry_serialize(ogeom);
 	lwgeom_free(ogeom);
 	PG_FREE_IF_COPY(geom, 0);
diff --git a/postgis/postgis.sql.in b/postgis/postgis.sql.in
index 8ef71c3..0295441 100644
--- a/postgis/postgis.sql.in
+++ b/postgis/postgis.sql.in
@@ -5215,15 +5215,36 @@ CREATE OR REPLACE FUNCTION ST_CoordDim(Geometry geometry)
 --
 -- SQL-MM
 --
+-- ST_CurveToLine(Geometry geometry, Tolerance float8, ToleranceType integer, Flags integer)
+--
+-- Converts a given geometry to a linear geometry.  Each curveed
+-- geometry or segment is converted into a linear approximation using
+-- the given tolerance.
+--
+-- Semantic of tolerance depends on the `toltype` argument, which can be:
+--    0: Tolerance is number of segments per quadrant
+--    1: Tolerance is max distance between curve and line
+--    2: Tolerance is max angle between radii defining line vertices
+--
+-- Supported flags:
+--    1: Symmetric output (result in same vertices when inverting the curve)
+--
+CREATE OR REPLACE FUNCTION ST_CurveToLine(geom geometry, tol float8, toltype integer, flags integer)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME', 'ST_CurveToLine'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+--
+-- SQL-MM
+--
 -- ST_CurveToLine(Geometry geometry, SegmentsPerQuarter integer)
 --
 -- Converts a given geometry to a linear geometry.  Each curveed
 -- geometry or segment is converted into a linear approximation using
 -- the given number of segments per quarter circle.
+--
 CREATE OR REPLACE FUNCTION ST_CurveToLine(geometry, integer)
-	RETURNS geometry
-	AS 'MODULE_PATHNAME', 'LWGEOM_curve_segmentize'
-	LANGUAGE 'c' IMMUTABLE STRICT;
+	RETURNS geometry AS 'SELECT ST_CurveToLine($1, $2::float8, 0, 0)'
+	LANGUAGE 'sql' IMMUTABLE STRICT;
 --
 -- SQL-MM
 --
@@ -5233,7 +5254,7 @@ CREATE OR REPLACE FUNCTION ST_CurveToLine(geometry, integer)
 -- geometry or segment is converted into a linear approximation using
 -- the default value of 32 segments per quarter circle
 CREATE OR REPLACE FUNCTION ST_CurveToLine(geometry)
-	RETURNS geometry AS 'SELECT ST_CurveToLine($1, 32)'
+	RETURNS geometry AS 'SELECT ST_CurveToLine($1, 32::integer)'
 	LANGUAGE 'sql' IMMUTABLE STRICT;
 
 CREATE OR REPLACE FUNCTION ST_HasArc(Geometry geometry)
diff --git a/regress/Makefile.in b/regress/Makefile.in
index f7e8ae8..ee6f8bc 100644
--- a/regress/Makefile.in
+++ b/regress/Makefile.in
@@ -81,6 +81,7 @@ TESTS = \
 	cluster \
 	concave_hull\
 	ctors \
+	curvetoline \
 	dump \
 	dumppoints \
 	empty \
diff --git a/regress/curvetoline.sql b/regress/curvetoline.sql
new file mode 100644
index 0000000..00a7ca4
--- /dev/null
+++ b/regress/curvetoline.sql
@@ -0,0 +1,64 @@
+
+
+-- Semantic of tolerance depends on the `toltype` argument, which can be:
+--    0: Tolerance is number of segments per quadrant
+--    1: Tolerance is max distance between curve and line
+--    2: Tolerance is max angle between radii defining line vertices
+--
+-- Supported flags:
+--    1: Symmetric output (result in same vertices when inverting the curve)
+
+SELECT 'semicircle1', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	3, -- Tolerance
+	0, -- Above is number of segments per quadrant
+	0  -- no flags
+), 2));
+
+SELECT 'semicircle2', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	20, -- Tolerance
+	1, -- Above is max distance between curve and line
+	0  -- no flags
+), 2));
+
+SELECT 'semicircle2.sym', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	20, -- Tolerance
+	1, -- Above is max distance between curve and line
+	1  -- Symmetric flag
+), 2));
+
+SELECT 'semicircle3', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	radians(40), -- Tolerance
+	2, -- Above is max angle between generating radii
+	0  -- no flags
+), 2));
+
+SELECT 'semicircle3.sym', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	radians(40), -- Tolerance
+	2, -- Above is max angle between generating radii
+	1  -- Symmetric flag
+), 2));
+SELECT 'semicircle3.sym.ret', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	radians(40), -- Tolerance
+	2, -- Above is max angle between generating radii
+	3  -- Symmetric and RetainAngle flags
+), 2));
+SELECT 'multiarc1', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0,400 200,600 0)'::geometry,
+	radians(45), -- Tolerance
+	2, -- Above is max angle between generating radii
+	3  -- Symmetric and RetainAngle flags
+), 2));
+SELECT 'multiarc1.maxerr20.sym', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0,400 200,600 0)'::geometry,
+	20, -- Tolerance
+	1, -- Above is max distance between curve and line
+	1  -- Symmetric
+), 2));
+
+
diff --git a/regress/curvetoline_expected b/regress/curvetoline_expected
new file mode 100644
index 0000000..115897e
--- /dev/null
+++ b/regress/curvetoline_expected
@@ -0,0 +1,8 @@
+semicircle1|LINESTRING(0 0,14 -50,50 -86,100 -100,150 -86,186 -50,200 0)
+semicircle2|LINESTRING(0 0,72 -96,184 -54,200 0)
+semicircle2.sym|LINESTRING(0 0,50 -86,150 -86,200 0)
+semicircle3|LINESTRING(0 0,24 -64,82 -98,150 -86,194 -34,200 0)
+semicircle3.sym|LINESTRING(0 0,20 -58,70 -96,130 -96,180 -58,200 0)
+semicircle3.sym.ret|LINESTRING(0 0,2 -18,36 -76,100 -100,164 -76,198 -18,200 0)
+multiarc1|LINESTRING(0 0,30 -70,100 -100,170 -70,200 0,258 142,400 200,542 142,600 0)
+multiarc1.maxerr20.sym|LINESTRING(0 0,50 -86,150 -86,200 0,258 142,400 200,542 142,600 0)
