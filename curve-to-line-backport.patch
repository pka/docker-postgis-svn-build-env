diff --git a/.drone.yml b/.drone.yml
new file mode 100644
index 0000000..b3b7b5b
--- /dev/null
+++ b/.drone.yml
@@ -0,0 +1,27 @@
+# See http://readme.drone.io/0.5/usage/overview
+
+env:
+  global:
+    - RUNTESTFLAGS=-v
+
+# See https://git.osgeo.org/gogs/postgis/postgis-docker
+test-image: &test-image docker.kbt.io/postgis/build-test:trisquel
+
+pipeline:
+  clone:
+    image: plugins/git
+    depth: 20
+    recursive: false
+  build:
+    image: *test-image
+    commands:
+      - ./autogen.sh
+      - ./configure CFLAGS="-O0 -Wall"
+      - make
+  check:
+    image: *test-image
+    commands:
+      - service postgresql start
+      - make check
+      - make install
+      - utils/check_all_upgrades.sh 2.4.0dev
diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 00d73a8..4736e5a 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -1,7 +1,6 @@
 test:
   script:
-    - apt-get update -qq
-    - apt-get install -y
+    - apt-get update -qq && apt-get install -y
         postgresql-9.4 postgresql-server-dev-9.4
         build-essential autoconf libtool libcunit1-dev
         xsltproc docbook-xsl docbook-mathml dblatex
diff --git a/ChangeLog b/ChangeLog
index e5ef074..1b57a61 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,512 @@
+2017-01-07 08:59  Regina Obe <lr@pcorp.us>
+
+	* [r15286] NEWS, postgis/gserialized_gist_2d.c,
+	  regress/knn_recheck.sql, regress/knn_recheck_expected: KNN
+	  recheck in 9.5+ fails with index returned tuples in wrong order
+	  closes #3418 for PostGIS 2.2
+	  add NEWS note for missing GRANT in upgrade
+	  references #3680
+
+2016-12-20 03:24  Regina Obe <lr@pcorp.us>
+
+	* [r15279] utils/postgis_proc_upgrade.pl: PostGIS upgrade scripts
+	  missing GRANT for views
+	  closes #3680 for PostGIS 2.2
+	  also correct strk's email
+
+2016-11-26 21:25  Regina Obe <lr@pcorp.us>
+
+	* [r15259] Version.config: Bump to 2.2.5dev
+
+2016-11-26 21:19  Regina Obe <lr@pcorp.us>
+
+	* [r15257] ChangeLog, NEWS, README.postgis, Version.config,
+	  doc/release_notes.xml: Prep for 2.2.4 release
+
+2016-11-26 18:54  Regina Obe <lr@pcorp.us>
+
+	* [r15254] NEWS, raster/rt_pg/rtpostgis.sql.in: add raster
+	  constraint max extent exceeds array size limit
+	  closes #3501 for 2.2.4
+
+2016-11-26 15:20  Regina Obe <lr@pcorp.us>
+
+	* [r15251] doc/reference_measure.xml: ST_Equals documentation does
+	  not describe current behavior
+	  closes #3566 for 2.2.4
+
+2016-11-26 15:00  Regina Obe <lr@pcorp.us>
+
+	* [r15248] doc/extras_topology.xml: Incorrect parameter name for
+	  CreateTopology
+	  closes #3509 for 2.2.4
+
+2016-10-31 15:35  Regina Obe <lr@pcorp.us>
+
+	* [r15221] NEWS, postgis/postgis.sql.in: st_concavehull() returns
+	  sometimes empty geometry collection
+	  closes #1973 for PostGIS 2.2
+
+2016-10-28 15:41  Sandro Santilli <strk@keybit.net>
+
+	* [r15217] .drone.yml: Update drone yml to 0.5 version
+	  
+	  See https://git.osgeo.org/gogs/sac/gogs-service/issues/14
+
+2016-10-16 05:36  Regina Obe <lr@pcorp.us>
+
+	* [r15210] NEWS, raster/rt_pg/rtpostgis.c: raster GUC -
+	  boot_postgis_gdal_enabled_drivers should use TopMemoryContext
+	  instead of CurrentMemoryContext
+	  Closes #3659 for 2.2 (PostGIS 2.2.4) patch provided by manaeem
+
+2016-10-10 20:24  Sandro Santilli <strk@keybit.net>
+
+	* [r15201] liblwgeom/lwgeom_geos.c: Fix typo in error message about
+	  ClipByBox availability
+
+2016-10-10 19:46  Sandro Santilli <strk@keybit.net>
+
+	* [r15199] .drone.yml: Be verbose in running tests
+
+2016-10-08 09:04  Sandro Santilli <strk@keybit.net>
+
+	* [r15193] .drone.yml, NEWS, postgis/postgis.sql.in,
+	  utils/check_all_upgrades.sh: Fix aggregates upgrade
+	  
+	  Fixes #3656 (aggregate upgrades)
+	  
+	  Enables automated ugprade testing
+
+2016-10-06 17:31  Sandro Santilli <strk@keybit.net>
+
+	* [r15181] doc/doxygen.cfg.in: Remove hard-coded version in Doxygen
+	  project name
+
+2016-10-06 15:53  Regina Obe <lr@pcorp.us>
+
+	* [r15176] NEWS: last patch fix was missing from news
+
+2016-10-06 15:34  Regina Obe <lr@pcorp.us>
+
+	* [r15173] NEWS, Version.config,
+	  extensions/upgradeable_versions.mk: bump to 2.2.4dev
+
+2016-10-06 13:37  Regina Obe <lr@pcorp.us>
+
+	* [r15171] ChangeLog, NEWS, Version.config, doc/release_notes.xml,
+	  extensions/upgradeable_versions.mk: In prep for 2.2.3 release
+
+2016-10-03 20:20  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r15167] NEWS, liblwgeom/lwstroke.c: #3652, crash on
+	  collection(multicurve(curve))
+
+2016-09-27 08:22  Sandro Santilli <strk@keybit.net>
+
+	* [r15158] NEWS, postgis/postgis_module.c: Do not call printf from
+	  interrupt handler, fixing deadlocks
+	  
+	  Closes #3644 for 2.2 branch
+
+2016-09-25 11:41  Regina Obe <lr@pcorp.us>
+
+	* [r15142] NEWS,
+	  extras/tiger_geocoder/geocode/interpolate_from_address.sql: fix
+	  numeric in interpolate_from_address
+	  Closes #3640 for PostGIS 2.2.3
+
+2016-09-25 11:36  Regina Obe <lr@pcorp.us>
+
+	* [r15141] regress/tickets.sql, regress/tickets_expected: Test to
+	  trap FreeBSD crash on small tables.
+	  References #2985 for PostGIS 2.2.3
+
+2016-09-25 03:54  Regina Obe <lr@pcorp.us>
+
+	* [r15137] NEWS,
+	  extras/tiger_geocoder/normalize/normalize_address.sql,
+	  extras/tiger_geocoder/pagc_normalize/pagc_normalize_address.sql:
+	  tiger normalize, pagc_normalize integer out of range
+	  closes #3641 for PostGIS 2.2.3
+
+2016-09-24 07:22  Regina Obe <lr@pcorp.us>
+
+	* [r15135] extensions/postgis/Makefile.in:
+	  ../../utils/create_spatial_ref_sys_config_dump.pl: not found on
+	  FreeBSD Add $PERL (my freebsd doesn't work without it)
+	  Closes #3639 for PostGIS 2.2.3
+
+2016-09-23 06:39  Regina Obe <lr@pcorp.us>
+
+	* [r15130] NEWS, libpgcommon/Makefile.in, postgis/Makefile.in,
+	  raster/rt_core/Makefile.in, raster/rt_pg/Makefile.in:
+	  pgcommon/Makefile.in orders CFLAGS incorrectly leading to wrong
+	  liblwgeom.h
+	  (Fix to use source version instead of installed)
+	  Patch from Greg Troxel
+	  references #3604 for PostGIS 2.2.3
+
+2016-09-19 04:55  Regina Obe <lr@pcorp.us>
+
+	* [r15119] NEWS, doc/faq_raster.xml, doc/reference_constructor.xml,
+	  doc/reference_raster.xml: doc corrections from ruvyn for PostGIS
+	  2.2.3
+	  closes #3581
+	  closes #3580
+	  closes #3586
+	  closes #3575
+
+2016-09-19 03:20  Regina Obe <lr@pcorp.us>
+
+	* [r15115] NEWS, raster/rt_pg/rtpostgis.sql.in: use ST_Union
+	  instead of ST_Collect to compute raster max extent constraint
+	  References #3501 for PostGIS 2.2.3
+
+2016-09-13 19:14  Daniel Baston <dbaston@gmail.com>
+
+	* [r15107] NEWS, liblwgeom/liblwgeom.h.in,
+	  postgis/lwgeom_functions_basic.c, regress/tickets.sql,
+	  regress/tickets_expected: #3569, Incorrect coordinates returned
+	  by ST_CollectionHomogenize
+
+2016-09-13 19:09  Regina Obe <lr@pcorp.us>
+
+	* [r15106] regress/in_encodedpolyline.sql,
+	  regress/in_encodedpolyline_expected: Add ST_SnapToGrid so 32-bit
+	  and 64-bit answers agree
+	  Closes #3629 for PostGIS 2.2
+
+2016-09-13 08:39  Sandro Santilli <strk@keybit.net>
+
+	* [r15103] topology/sql/populate.sql.in: Fix DEBUG build of
+	  topology
+
+2016-09-09 14:28  Sandro Santilli <strk@keybit.net>
+
+	* [r15093] NEWS, raster/rt_pg/rtpostgis.sql.in,
+	  raster/test/regress/rt_createoverview.sql,
+	  raster/test/regress/rt_createoverview_expected: Fix schema
+	  support in RT_CreateOveriew
+	  
+	  Patch by hypostase
+	  Closes #3615
+	  Include tests
+
+2016-09-09 14:23  Sandro Santilli <strk@keybit.net>
+
+	* [r15091] NEWS: Note ST_SwapOrdinate capital-Y fix
+
+2016-09-09 14:22  Sandro Santilli <strk@keybit.net>
+
+	* [r15090] regress/swapordinates.sql,
+	  regress/swapordinates_expected: Add test for ST_SwapOrdinate fix
+	  (#3628)
+
+2016-09-09 14:02  Sandro Santilli <strk@keybit.net>
+
+	* [r15087] postgis/lwgeom_functions_basic.c: Fix lack of support
+	  for capitalized-Y in SwapOrdinates
+	  
+	  Closes #3628
+
+2016-09-08 16:06  Sandro Santilli <strk@keybit.net>
+
+	* [r15086] topology/postgis_topology.c: Really fix callback reading
+	  Edge data in presence of unexpected NULLs
+
+2016-09-08 15:53  Sandro Santilli <strk@keybit.net>
+
+	* [r15084] topology/postgis_topology.c: Fix callback reading Edge
+	  data in presence of unexpected NULLs
+
+2016-09-07 18:36  Sandro Santilli <strk@keybit.net>
+
+	* [r15082] regress/run_test.pl: Do not require expecting DISCARD
+	  ALL
+	  
+	  .. actually it may be a good idea to run it always after each
+	  test ..
+
+2016-09-07 18:30  Sandro Santilli <strk@keybit.net>
+
+	* [r15081] regress/run_test.pl: Style only: remove trailing
+	  blankspaces
+
+2016-09-06 22:59  Daniel Baston <dbaston@gmail.com>
+
+	* [r15076] NEWS: Add NEWS entry for #3627
+
+2016-09-06 22:57  Daniel Baston <dbaston@gmail.com>
+
+	* [r15075] postgis/lwgeom_export.c,
+	  postgis/lwgeom_in_encoded_polyline.c,
+	  regress/in_encodedpolyline.sql,
+	  regress/in_encodedpolyline_expected,
+	  regress/out_geometry_expected, regress/tickets.sql,
+	  regress/tickets_expected: #3627, Encoded polyline functions
+	  ignore precision parameter
+
+2016-09-06 15:37  Regina Obe <lr@pcorp.us>
+
+	* [r15073] NEWS, regress/run_test.pl: load_outdb related tests fix
+	  for @INC change in perl
+	  patch from Sebastiaan Couwenberg
+	  closes #3624 for PostGIS 2.2
+
+2016-09-06 14:42  Regina Obe <lr@pcorp.us>
+
+	* [r15071] ci/winnie/package_postgis.sh: Fix svnurl export (no
+	  longer trunk)
+
+2016-08-05 14:53  Sandro Santilli <strk@keybit.net>
+
+	* [r15039] NEWS, loader/shp2pgsql-cli.c: Allocate memory for
+	  encoding argument, so it can be safely freed later.
+	  
+	  Fixes #3608 for 2.2 branch
+	  
+	  Patch by Matt Amos <zerebubuth@gmail.com>
+
+2016-08-05 14:11  Sandro Santilli <strk@keybit.net>
+
+	* [r15036] NEWS, liblwgeom/lwlinearreferencing.c,
+	  regress/regress_lrs.sql, regress/regress_lrs_expected: Fix
+	  inconsistency with multilinestring in
+	  ST_LocateBetweenElevations()
+	  
+	  Fixes #3607.
+	  Includes testcase.
+	  
+	  Patch by Artur Zakirov <a.zakirov@postgrespro.ru>
+
+2016-07-30 17:39  Regina Obe <lr@pcorp.us>
+
+	* [r15027] NEWS, extensions/address_standardizer/Makefile.in,
+	  extensions/postgis_sfcgal/Makefile.in,
+	  extensions/postgis_tiger_geocoder/Makefile.in: perl as found by
+	  configure is not used in tiger, sfcgal, or address_standardizer
+	  extensions
+	  closes #3602 for PostGIS 2.2
+	  tiger_data not being backed up and add upgrade test
+	  closes #3515 for PostGIS 2.2
+
+2016-07-21 18:08  Sandro Santilli <strk@keybit.net>
+
+	* [r15020] .drone.yml: Update .drone.yml from trunk
+
+2016-07-21 17:42  Sandro Santilli <strk@keybit.net>
+
+	* [r15017] .drone.yml: Use -O0 for test builds, add reference to
+	  postgis-docker
+	  
+	  Removing the optimization flag reduces build time from ~40s to
+	  ~30s
+
+2016-07-21 11:32  Sandro Santilli <strk@keybit.net>
+
+	* [r15009] .drone.yml, docker/build-test/Dockerfile.trisquel,
+	  docker/build-test/Makefile: Remove docker config, update drone
+	  
+	  Docker project moved to:
+	  http://git.osgeo.org/gogs/postgis/postgis-docker
+
+2016-07-19 21:45  Sandro Santilli <strk@keybit.net>
+
+	* [r15001] README.md: Add Dronie badge
+
+2016-07-19 21:45  Sandro Santilli <strk@keybit.net>
+
+	* [r15000] .drone.yml, docker, docker/build-test,
+	  docker/build-test/Dockerfile.trisquel,
+	  docker/build-test/Makefile: Add drone and docker config
+
+2016-07-05 10:51  Sandro Santilli <strk@keybit.net>
+
+	* [r14992] .gitlab-ci.yml: apt-get update && install on the same
+	  line
+	  
+	  This avoids attempts to install outdated packages due to cached
+	  steps
+
+2016-07-02 16:33  Regina Obe <lr@pcorp.us>
+
+	* [r14982] doc/extras_tigergeocoder.xml: documentation corrections
+	  from ruvyn for tiger geocoder
+	  Closes #3593 for PostGIS 2.2
+
+2016-06-20 01:45  Regina Obe <lr@pcorp.us>
+
+	* [r14975] doc/reference_raster.xml: Doco fixes
+	  closes #3584 for PostGIS 2.2
+	  closes #3582 for PostGIS 2.2
+
+2016-06-20 01:31  Regina Obe <lr@pcorp.us>
+
+	* [r14973] doc/reference_raster.xml: typo geometries should be
+	  rasters
+	  closes #3585 for 2.2
+
+2016-06-15 20:37  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14956] NEWS, liblwgeom/lwgeom_geos.c, regress/tickets.sql,
+	  regress/tickets_expected: #3579, crash in LWGEOM2GEOS
+
+2016-06-07 22:11  Daniel Baston <dbaston@gmail.com>
+
+	* [r14942] regress/knn_recheck.sql, regress/knn_recheck_expected,
+	  regress/tickets.sql, regress/tickets_expected: Make test for
+	  #3573 run only on PG 9.5+
+
+2016-06-07 13:49  Daniel Baston <dbaston@gmail.com>
+
+	* [r14940] NEWS, postgis/gserialized_gist_nd.c,
+	  regress/tickets.sql, regress/tickets_expected: #3573, operator
+	  <<->> incorrectly calculates m distance
+
+2016-06-04 18:18  Regina Obe <lr@pcorp.us>
+
+	* [r14933] NEWS, loader/Makefile.in, loader/icons,
+	  loader/icons/hicolor, loader/icons/hicolor/16x16,
+	  loader/icons/hicolor/16x16/apps,
+	  loader/icons/hicolor/16x16/apps/shp2pgsql-gui.png,
+	  loader/icons/hicolor/22x22, loader/icons/hicolor/22x22/apps,
+	  loader/icons/hicolor/22x22/apps/shp2pgsql-gui.png,
+	  loader/icons/hicolor/24x24, loader/icons/hicolor/24x24/apps,
+	  loader/icons/hicolor/24x24/apps/shp2pgsql-gui.png,
+	  loader/icons/hicolor/32x32, loader/icons/hicolor/32x32/apps,
+	  loader/icons/hicolor/32x32/apps/shp2pgsql-gui.png,
+	  loader/icons/hicolor/36x36, loader/icons/hicolor/36x36/apps,
+	  loader/icons/hicolor/36x36/apps/shp2pgsql-gui.png,
+	  loader/icons/hicolor/40x40, loader/icons/hicolor/40x40/apps,
+	  loader/icons/hicolor/40x40/apps/shp2pgsql-gui.png,
+	  loader/icons/hicolor/42x42, loader/icons/hicolor/42x42/apps,
+	  loader/icons/hicolor/42x42/apps/shp2pgsql-gui.png,
+	  loader/icons/hicolor/48x48, loader/icons/hicolor/48x48/apps,
+	  loader/icons/hicolor/48x48/apps/shp2pgsql-gui.png,
+	  loader/icons/hicolor/64x64, loader/icons/hicolor/64x64/apps,
+	  loader/icons/hicolor/64x64/apps/shp2pgsql-gui.png,
+	  loader/icons/hicolor/8x8, loader/icons/hicolor/8x8/apps,
+	  loader/icons/hicolor/8x8/apps/shp2pgsql-gui.png,
+	  loader/shp2pgsql-gui.desktop: Install desktop file and
+	  application icons for shp2pgsql-gui (Sebastiaan Couwenberg)
+	  Closes #3571 for PostGIS 2.2
+
+2016-05-25 17:28  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14920] NEWS, postgis/lwgeom_functions_basic.c,
+	  regress/tickets.sql, regress/tickets_expected: #3565, st_setpoint
+	  crashes database
+
+2016-05-12 19:11  Regina Obe <lr@pcorp.us>
+
+	* [r14900] extras/tiger_geocoder/geocode/reverse_geocode.sql:
+	  Closes #3552 for PostGIS 2.2.3
+
+2016-05-12 18:58  Regina Obe <lr@pcorp.us>
+
+	* [r14898] extras/tiger_geocoder/geocode/geocode_address.sql: fix
+	  regexp mistake need to cast to text.
+
+2016-05-12 09:44  Sandro Santilli <strk@keybit.net>
+
+	* [r14896] README.md: Fix winnie image link
+
+2016-05-12 09:19  Sandro Santilli <strk@keybit.net>
+
+	* [r14895] README.md: Update debbie and winnie links to use https
+
+2016-05-04 22:02  Daniel Baston <dbaston@gmail.com>
+
+	* [r14884] postgis/lwgeom_accum.c, postgis/lwgeom_geos.c,
+	  regress/tickets.sql, regress/tickets_expected: #3470,
+	  ST_Polygonize doesn't accept NULL geometries
+
+2016-05-01 16:23  Daniel Baston <dbaston@gmail.com>
+
+	* [r14874] doc/reference_measure.xml, regress/tickets.sql,
+	  regress/tickets_expected: #3119, Wrong documented behavior for
+	  ST_LengthSpheroid
+
+2016-04-27 12:12  Daniel Baston <dbaston@gmail.com>
+
+	* [r14865] doc/reference_raster.xml: #3218, ST_PixelAsCentroid
+	  documentation has incorrect names
+
+2016-04-27 12:06  Daniel Baston <dbaston@gmail.com>
+
+	* [r14862] doc/reference_raster.xml: #3217, ST_Value documentation
+	  has incorrect parameter names
+
+2016-04-18 08:42  Sandro Santilli <strk@keybit.net>
+
+	* [r14852] README.md: Fix gilab-ci badge
+
+2016-04-17 21:45  Regina Obe <lr@pcorp.us>
+
+	* [r14849] extras/tiger_geocoder/geocode/geocode.sql,
+	  extras/tiger_geocoder/geocode/geocode_address.sql,
+	  extras/tiger_geocoder/geocode/geocode_intersection.sql: Schema
+	  qualify calls and prevent error when tiger street number is not a
+	  number (just return first number part)
+	  References #3531 #3451 for PostGIS 2.2.3
+
+2016-04-17 20:38  Regina Obe <lr@pcorp.us>
+
+	* [r14848] extras/tiger_geocoder/geocode/geocode_intersection.sql:
+	  Minor cleanup, change to schema qualify tables,
+	  change to use tiger node ids overlap instead of intersects for
+	  determining intersections
+	  Closes #3530 for PostGIS 2.2.3
+	  References #3451
+
+2016-04-13 16:53  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14840] regress/subdivide.sql, regress/subdivide_expected,
+	  regress/tickets.sql: #3529, move test to subdivide.sql
+
+2016-04-13 15:57  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14837] regress/tickets.sql, regress/tickets_expected: Don't run
+	  online test for GEOS 3.5 feature
+
+2016-04-12 21:39  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14834] NEWS, liblwgeom/cunit/cu_clip_by_rect.c,
+	  liblwgeom/lwgeom.c, regress/tickets.sql,
+	  regress/tickets_expected: #3522, handle POINT and MULTIPOINT
+	  correctly in ST_Subdivide
+
+2016-04-12 19:19  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14831] NEWS, liblwgeom/lwgeodetic.c: #3524, add
+	  interruptibility to geography brute force distance calculation
+
+2016-04-11 18:40  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14829] spatial_ref_sys.sql: #1851, spatial_ref_sys entries for
+	  Pulkovo_1942_58, to_wgs84
+
+2016-03-22 19:57  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14801] NEWS, doc/release_notes.xml: Fix rel notes on
+	  ST_Intersects
+
+2016-03-22 18:23  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14798] NEWS, README.postgis, Version.config: Bump working
+	  versions to 2.2.3dev
+
+2016-03-22 17:51  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14796] ChangeLog, NEWS, README.postgis, Version.config,
+	  doc/release_notes.xml, extensions/upgradeable_versions.mk:
+	  Version bumps, release notes for 2.2.2
+
+2016-03-22 16:43  Paul Ramsey <pramsey@cleverelephant.ca>
+
+	* [r14795] postgis, raster/rt_pg: Ignore built artifacts
+
 2016-03-20 05:07  Regina Obe <lr@pcorp.us>
 
 	* [r14791] doc/reference_output.xml: fix typo in last commit
diff --git a/NEWS b/NEWS
index aa2bc98..df92c90 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,64 @@
+PostGIS 2.2.5
+2017/01/29
+
+ * Bug Fixes *
+ - #3418, KNN recheck in 9.5+ fails with index returned tuples in wrong order
+ - #3680, PostGIS upgrade scripts missing GRANT for views
+
+PostGIS 2.2.4
+2016/11/26
+
+ * Bug Fixes *
+
+ - #1973, st_concavehull() returns sometimes empty geometry collection
+          Fix from gde
+ - #3656, Fix upgrade of aggregates from 2.2 or lower version
+ - #3501, add raster constraint max extent exceeds array size limit
+        for large tables, change to use ST_Extent
+ - #3659, Crash caused by raster GUC define after CREATE EXTENSION
+     using wrong memory context. (manaeem)
+
+
+PostGIS 2.2.3
+2016/10/06
+
+ * Bug Fixes *
+
+  - #3615, Fix schema support in RT_CreateOveriew (Cait Smith)
+  - #3628, Fix lack of support for capitalized-Y in SwapOrdinates
+  - #3524, Add interruptibility to geography brute-force distance 
+           calculation
+  - #3522, Handle POINT and MULTIPOINT correctly in ST_Subdivide
+  - #3565, ST_SetPoint can crash backend
+  - #3571, Install desktop file and application icons 
+           for shp2pgsql-gui (Sebastiaan Couwenberg)
+  - #3573, Operator <<->> incorrectly calculates m distance
+  - #3579, Crash in LWGEOM2GEOS
+  - #3515, tiger_data not being backed up
+  - #3569, Incorrect coordinates returned by ST_CollectionHomogenize
+           (Dan Baston)
+  - #3602, perl as found by configure is not used 
+           in tiger extension, postgis_sfcgal, address_standardizer
+  - #3604, pgcommon/Makefile.in orders CFLAGS leads to installed liblwgeom.h
+          (Greg Troxel)
+  - #3607, Fix inconsistency with multilinestring in
+           ST_LocateBetweenElevations (Artur Zakirov)
+  - #3608, Fix crash passing -W UTF-8 to shp2pgsql (Matt Amos)
+  - #3624, [raster] load_outdb related tests fail 
+           for 2.2.2 & 2.3.0-beta1 on Debian unstable
+           perl @INC fix (Sebastiaan Couwenberg)
+  - #3627, Encoded polyline functions ignore precision parameter
+           (Christian Quest / Dan Baston)
+  - #3501, use ST_Union instead of ST_Collect to compute 
+          raster max extent constraint
+  - #3640, Interpolate_from_address sometimes results in "" invalid for numeric
+  - #3641, Tiger normalize, pagc_normalize integer out of range
+  - #3644, Deadlock on interrupt
+  - #3542, Crash on Geometry(MultiCurve())
+  - Numerous documentation corrections from ruvyn
+  - #3652, Segmentation fault during operations on GEOMETRYCOLLECTION 
+     with MULTICURVE geometry inside
+
 PostGIS 2.2.2
 2016/03/22
 
@@ -10,15 +71,15 @@ PostGIS 2.2.2
   - #3433, ST_ClusterIntersecting incorrect for MultiPoints
   - #3435, ST_AsX3D fix rendering of concave geometries
   - #3436, memory handling mistake in ptarray_clone_deep
-  - #3437, ST_ClusterIntersecting incorrect for MultiPoints
+  - #3437, ST_Intersects incorrect for MultiPoints
   - #3461, ST_GeomFromKML crashes Postgres when there are 
            innerBoundaryIs and no outerBoundaryIs
   - #3429, upgrading to 2.3 or from 2.1 can cause loop/hang on some 
            platforms
   - #3460, ST_ClusterWithin 'Tolerance not defined' error after upgrade
   - #3490, Raster data restore issues, materialized views
-  		   Scripts postgis_proc_set_search_path.sql, rtpostgis_proc_set_search_path.sql
-  		   refere to http://postgis.net/docs/manual-2.2/RT_FAQ.html#faq_raster_data_not_restore
+           Scripts postgis_proc_set_search_path.sql, rtpostgis_proc_set_search_path.sql
+           refere to http://postgis.net/docs/manual-2.2/RT_FAQ.html#faq_raster_data_not_restore
   - #3426, failing POINT EMPTY tests on fun architectures
 
 PostGIS 2.2.1
@@ -198,7 +259,7 @@ PostGIS 2.2.0
            max extent constraint
   - #3018, GROUP BY geography sometimes returns duplicate rows
   - #3020, ST_AddBand out-db bug where height using width value
-  - #3048, shp2pgsql - illegal number format when specific system locale set
+  - #3084, shp2pgsql - illegal number format when specific system locale set
   - #3061, Allow duplicate points in JSON, GML, GML ST_GeomFrom* functions
   - #3086, ST_DumpValues() crashes backend on cleanup with invalid
            band indexes
@@ -241,7 +302,7 @@ PostGIS 2.1.6
 
   - #3000, Ensure edge splitting and healing algorithms use indexes
   - #3048, Speed up geometry simplification (J.Santana @ CartoDB)
-  - #3050, Speep up geometry type reading (J.Santana @ CartoDB)
+  - #3050, Speed up geometry type reading (J.Santana @ CartoDB)
 
  * Bug Fixes *
 
diff --git a/README.md b/README.md
index 5faf506..a52aa7e 100644
--- a/README.md
+++ b/README.md
@@ -1,15 +1,18 @@
+Debbie:
+ [![Build Status](https://debbie.postgis.net/buildStatus/icon?job=PostGIS_2.2)]
+ (https://debbie.postgis.net/view/PostGIS/job/PostGIS_2.2/)
+Winnie:
+ [![Build Status](https://debbie.postgis.net:444/buildStatus/icon?job=PostGIS_2.2)]
+ (https://debbie.postgis.net:444/view/PostGIS/job/PostGIS_2.2/)
+Dronie:
+ [![Build Status](https://drone.osgeo.org/api/badges/postgis/postgis/status.svg?branch=svn-2.2)]
+ (https://drone.osgeo.org/postgis/postgis?branch=svn-2.2)
 Travis:
  [![Build Status](https://secure.travis-ci.org/postgis/postgis.png?branch=svn-2.2)]
  (http://travis-ci.org/postgis/postgis)
-Debbie:
- [![Build Status](http://debbie.postgis.net:8080/buildStatus/icon?job=PostGIS_2.2)]
- (http://debbie.postgis.net:8080/view/PostGIS/job/PostGIS_2.2/)
-Winnie:
- [![Build Status](http://winnie.postgis.net:1500/buildStatus/icon?job=PostGIS_2.2)]
- (http://winnie.postgis.net:1500/view/PostGIS/job/PostGIS_2.2/)
 GitLab-CI:
- [![Build Status](http://gitlab.com/ci/projects/3944/status.png?ref=svn-2.2)]
- (http://gitlab.com/ci/projects/3944?ref=svn-2.2)
+ [![Gitlab-CI](https://gitlab.com/postgis/postgis/badges/svn-2.2/build.svg)]
+ (https://gitlab.com/postgis/postgis/commits/svn-2.2)
 
 This file is here to play nicely with modern code repository facilities.
 Actual readme is [here](README.postgis).
diff --git a/README.postgis b/README.postgis
index 0858d7a..6824356 100644
--- a/README.postgis
+++ b/README.postgis
@@ -1,8 +1,8 @@
 PostGIS - Geographic Information Systems Extensions to PostgreSQL
 =================================================================
 
-:Version: 2.2.2
-:Date: 2016-03-22
+:Version: 2.2.5
+:Date: 2017-01-29
 :Website: http://postgis.net
 
 This distribution contains a module which implements GIS simple features, ties
diff --git a/Version.config b/Version.config
index f21f2d8..ffe17d7 100644
--- a/Version.config
+++ b/Version.config
@@ -5,7 +5,7 @@
 
 POSTGIS_MAJOR_VERSION=2
 POSTGIS_MINOR_VERSION=2
-POSTGIS_MICRO_VERSION=2
+POSTGIS_MICRO_VERSION=6dev-curve-to-line-backport
 
 # Liblwgeom interface versioning, reset to 0:0:0 (cur:age:rev)
 # when changing POSTGIS_MINOR_VERSION
diff --git a/ci/winnie/package_postgis.sh b/ci/winnie/package_postgis.sh
index 118828f..0c9cded 100644
--- a/ci/winnie/package_postgis.sh
+++ b/ci/winnie/package_postgis.sh
@@ -55,9 +55,6 @@ else
 	export svnurl="http://svn.osgeo.org/postgis/tags/${POSTGIS_MINOR_VER}.${POSTGIS_MICRO_VERSION}"
 fi;
 
-if [[ "$POSTGIS_MINOR_VER"  == 2.2 ]] ; then
-	export svnurl="http://svn.osgeo.org/postgis/branches/trunk"
-fi;
 #export POSTGIS_SRC=${PROJECTS}/postgis/trunk
 #POSTGIS_SVN_REVISION=will_be_passed_in_by_bot
 export GDAL_DATA="${PROJECTS}/gdal/rel-${GDAL_VER}w${OS_BUILD}${GCC_TYPE}/share/gdal"
@@ -129,7 +126,6 @@ if [ "$POSTGIS_MAJOR_VERSION" == "2" ] ; then
   if [ "$POSTGIS_MINOR_VERSION" > "0" ] ; then
     ## only copy pagc standardizer components for 2.1+
     cp -p ${PROJECTS}/pcre/rel-${PCRE_VER}w${OS_BUILD}${GCC_TYPE}/bin/libpcre-1*.dll $outdir/bin
-    cp -p ${PGPATH}/lib/address*.dll $outdir/lib
     # cp -p ${PGPATH}/share/extension/address*.* $outdir/share/extension
     # cp -p ${PGPATH}/share/extension/us-*.sql $outdir/share/extension
   fi;
@@ -189,6 +185,7 @@ cp topology/topology_upgrade_*.sql ${RELDIR}/${RELVERDIR}/share/contrib/postgis-
 #cp extras/* ${RELDIR}/${RELVERDIR}/share/contrib/postgis-${POSTGIS_MINOR_VER}/extras
 cp -r extensions/*/sql/* ${RELDIR}/${RELVERDIR}/share/extension
 cp -r extensions/*/*.control ${RELDIR}/${RELVERDIR}/share/extension
+cp -r extensions/*/*.dll ${RELDIR}/${RELVERDIR}/lib #only address_standardizer in theory has this
 #cp extensions/postgis_topology/sql/* ${RELDIR}/${RELVERDIR}/share/extension
 #cp extensions/postgis_topology/*.control ${RELDIR}/${RELVERDIR}/share/extension
 cp -r ${RELDIR}/packaging_notes/* ${RELDIR}/${RELVERDIR}/
diff --git a/doc/doxygen.cfg.in b/doc/doxygen.cfg.in
index d455dd6..0ee3f09 100644
--- a/doc/doxygen.cfg.in
+++ b/doc/doxygen.cfg.in
@@ -17,7 +17,7 @@
 # The PROJECT_NAME tag is a single word (or a sequence of words surrounded
 # by quotes) that should identify the project.
 
-PROJECT_NAME           = "PostGIS Trunk Doxygen"
+PROJECT_NAME           = "PostGIS"
 
 # The PROJECT_NUMBER tag can be used to enter a project or revision number.
 # This could be handy for archiving the generated documentation or
diff --git a/doc/extras_tigergeocoder.xml b/doc/extras_tigergeocoder.xml
index 36bf005..f67edb4 100644
--- a/doc/extras_tigergeocoder.xml
+++ b/doc/extras_tigergeocoder.xml
@@ -11,28 +11,28 @@
                 prefixed with the state code e.g <varname>ma_addr</varname>, <varname>ma_edges</varname> etc with constraints to enforce only that state data.  Each of these tables inherits from the tables <varname>addr</varname>, <varname>faces</varname>, <varname>edges</varname>, etc located in the <varname>tiger schema</varname>. </para>
             <para>All the geocode functions only reference the base tables, so there is no requirement that the data schema be called <varname>tiger_data</varname> or that data can't be further partitioned into other schemas -- e.g a different schema
             for each state, as long as all the tables inherit from the tables in the <varname>tiger</varname> schema.</para>
-            
-       
-            <para>For instructions on how enable the extension in your database and also to load data using it, refer to Refer to <xref linkend="install_tiger_geocoder_extension" />.</para>
-            
-        
+
+
+            <para>For instructions on how to enable the extension in your database and also to load data using it, refer to <xref linkend="install_tiger_geocoder_extension" />.</para>
+
+
              <para> <note><para>
 If you are using tiger geocoder (tiger_2010),
 you can upgrade the scripts using the accompanying upgrade_geocoder.bat
-/ .sh scripts in extras/tiger.  One major change between <varname>tiger_2010</varname> and <varname>tiger_2011+</varname> is that the county and <varname>county</varname> and <varname>state</varname> tables are no longer broken out by state.    If you have data from tiger_2010 and want replace with tiger_2015 refer to <xref linkend="upgrade_tiger_geocoder" />
+/ .sh scripts in extras/tiger.  One major change between <varname>tiger_2010</varname> and <varname>tiger_2011+</varname> is that the <varname>county</varname> and <varname>state</varname> tables are no longer broken out by state.    If you have data from tiger_2010 and want to replace with tiger_2015, refer to <xref linkend="upgrade_tiger_geocoder" />
               </para></note>
-              
+
               <note>
               <para>New in PostGIS 2.2.0 release is support for Tiger 2015 data and inclusion of Address Standardizer as part of PostGIS.</para>
               <para>New in PostGIS 2.1.0 release is ability to install tiger geocoder with PostgreSQL extension model if you are running PostgreSQL 9.1+. Refer to <xref linkend="install_tiger_geocoder_extension" /> for details.</para></note>
               </para>
-             
-              <para>The <xref linkend="Pagc_Normalize_Address" /> function as a drop in replacement for in-built <xref linkend="Normalize_Address" />. Refer to <xref linkend="installing_pagc_address_standardizer" /> for compile and installation instructions.</para> 
-        
+
+              <para>The <xref linkend="Pagc_Normalize_Address" /> function as a drop in replacement for in-built <xref linkend="Normalize_Address" />. Refer to <xref linkend="installing_pagc_address_standardizer" /> for compile and installation instructions.</para>
+
 
 
             <para>Design:</para>
-            <para>The goal of this project is to build a fully functional geocoder that can process an arbitrary 
+            <para>The goal of this project is to build a fully functional geocoder that can process an arbitrary
             United States address string and using normalized TIGER census data, produce a point geometry and rating reflecting the location of the given address and likeliness of the location. The higher the rating number the worse the result.</para>
             <para>The <varname>reverse_geocode</varname> function, introduced in PostGIS 2.0.0 is useful for deriving the street address and cross streets of a GPS location.</para>
             <para>The geocoder should be simple for anyone familiar with PostGIS to install and use, and should be easily installable and usable on all platforms supported by PostGIS.</para>
@@ -44,15 +44,15 @@ you can upgrade the scripts using the accompanying upgrade_geocoder.bat
         </abstract>
      </sect1info>
     <title>Tiger Geocoder</title>
-     
+
      <para>There are a couple other open source geocoders for PostGIS, that unlike tiger geocoder have the advantage of multi-country geocoding support</para>
      <itemizedlist>
          <listitem><para><ulink url="http://wiki.openstreetmap.org/wiki/Nominatim">Nominatim</ulink>
-     and uses OpenStreetMap gazeteer formatted data.  It requires osm2pgsql for loading the data, PostgreSQL 8.4+ and PostGIS 1.5+ to function.  It is packaged as a webservice interface and seems designed to be called as a webservice.
+     uses OpenStreetMap gazeteer formatted data.  It requires osm2pgsql for loading the data, PostgreSQL 8.4+ and PostGIS 1.5+ to function.  It is packaged as a webservice interface and seems designed to be called as a webservice.
      Just like the tiger geocoder, it has both a geocoder and a reverse geocoder component.  From the documentation, it is unclear if it has a pure SQL interface like the tiger geocoder, or if a good deal of the logic is implemented in the web interface.</para></listitem>
          <listitem><para><ulink url="http://www.gisgraphy.com/">GIS Graphy</ulink> also utilizes PostGIS and like Nominatim works with OpenStreetMap (OSM) data.  It comes with a loader to load OSM data and similar to Nominatim is capable of geocoding not just US. Much like Nominatim, it runs as a webservice and relies on Java 1.5, Servlet apps, Solr. GisGraphy is cross-platform and also has a reverse geocoder among some other neat features.</para></listitem>
      </itemizedlist>
-    
+
     <refentry id="Drop_Indexes_Generate_Script">
       <refnamediv>
         <refname>Drop_Indexes_Generate_Script</refname>
@@ -74,8 +74,8 @@ you can upgrade the scripts using the accompanying upgrade_geocoder.bat
 
         <para>Generates a script that drops all non-primary key and non-unique indexes on tiger schema and user specified schema.  Defaults schema to <varname>tiger_data</varname> if no schema is specified.</para>
         <para>This is useful for minimizing index bloat that may confuse the query planner or take up unnecessary space.  Use in combination with <xref linkend="Install_Missing_Indexes"/> to add just the indexes used by the geocoder.</para>
-    
-        
+
+
         <para>Availability: 2.0.0</para>
 
 
@@ -119,7 +119,7 @@ DROP INDEX tiger_data.idx_tiger_data_ma_county_snd_name;
 :
 :
 </programlisting>
-    
+
       </refsection>
 
       <!-- Optionally add a "See Also" section -->
@@ -128,12 +128,12 @@ DROP INDEX tiger_data.idx_tiger_data_ma_county_snd_name;
         <para><xref linkend="Install_Missing_Indexes"/>, <xref linkend="Missing_Indexes_Generate_Script"/></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Drop_Nation_Tables_Generate_Script">
       <refnamediv>
         <refname>Drop_Nation_Tables_Generate_Script</refname>
 
-        <refpurpose>Generates a script that drops all tables in the specified schema that start with <varname>county_all</varname>, <varname>state_all</varname> or stae code followed by <varname>county</varname> or <varname>state</varname>.</refpurpose>
+        <refpurpose>Generates a script that drops all tables in the specified schema that start with <varname>county_all</varname>, <varname>state_all</varname> or state code followed by <varname>county</varname> or <varname>state</varname>.</refpurpose>
       </refnamediv>
 
       <refsynopsisdiv>
@@ -149,8 +149,8 @@ DROP INDEX tiger_data.idx_tiger_data_ma_county_snd_name;
         <title>Description</title>
 
         <para>Generates a script that drops all tables in the specified schema that start with <varname>county_all</varname>, <varname>state_all</varname> or stae code followed by <varname>county</varname> or <varname>state</varname>.  This is needed if you are upgrading from <varname>tiger_2010</varname> to <varname>tiger_2011</varname> data.</para>
-    
-        
+
+
         <para>Availability: 2.1.0</para>
 
 
@@ -165,7 +165,7 @@ DROP TABLE tiger_data.county_all_lookup;
 DROP TABLE tiger_data.state_all;
 DROP TABLE tiger_data.ma_county;
 DROP TABLE tiger_data.ma_state;</programlisting>
-    
+
       </refsection>
 
       <!-- Optionally add a "See Also" section -->
@@ -174,7 +174,7 @@ DROP TABLE tiger_data.ma_state;</programlisting>
         <para><xref linkend="Loader_Generate_Nation_Script"/></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Drop_State_Tables_Generate_Script">
       <refnamediv>
         <refname>Drop_State_Tables_Generate_Script</refname>
@@ -197,8 +197,8 @@ DROP TABLE tiger_data.ma_state;</programlisting>
 
         <para>Generates a script that drops all tables in the specified schema that are prefixed with the state abbreviation.  Defaults schema to <varname>tiger_data</varname> if no schema is specified.
         This function is useful for dropping tables of a state just before you reload a state in case something went wrong during your previous load.</para>
-    
-        
+
+
         <para>Availability: 2.0.0</para>
 
 
@@ -221,7 +221,7 @@ DROP TABLE tiger_data.pa_zip_lookup_base;
 DROP TABLE tiger_data.pa_zip_state;
 DROP TABLE tiger_data.pa_zip_state_loc;
         </programlisting>
-    
+
       </refsection>
 
       <!-- Optionally add a "See Also" section -->
@@ -234,7 +234,7 @@ DROP TABLE tiger_data.pa_zip_state_loc;
       <refnamediv>
         <refname>Geocode</refname>
 
-        <refpurpose>Takes in an address as a string (or other normalized address) and outputs a set of possible locations which include a point geometry in NAD 83 long lat, a normalized address for each, and the rating.  The lower the rating the more likely the match.  
+        <refpurpose>Takes in an address as a string (or other normalized address) and outputs a set of possible locations which include a point geometry in NAD 83 long lat, a normalized address for each, and the rating.  The lower the rating the more likely the match.
             Results are sorted by lowest rating first. Can optionally pass in maximum results, defaults to 10, and restrict_region (defaults to NULL)</refpurpose>
       </refnamediv>
 
@@ -264,12 +264,12 @@ DROP TABLE tiger_data.pa_zip_state_loc;
       <refsection>
         <title>Description</title>
 
-        <para>Takes in an address as a string (or already normalized address) and outputs a set of possible locations which include a point geometry in NAD 83 long lat, a <varname>normalized_address</varname> (addy) for each, and the rating.  The lower the rating the more likely the match.  
+        <para>Takes in an address as a string (or already normalized address) and outputs a set of possible locations which include a point geometry in NAD 83 long lat, a <varname>normalized_address</varname> (addy) for each, and the rating.  The lower the rating the more likely the match.
             Results are sorted by lowest rating first.  Uses Tiger data (edges,faces,addr), PostgreSQL fuzzy string matching (soundex,levenshtein) and PostGIS line interpolation functions to interpolate address along the Tiger edges. The higher the rating the less likely the geocode is right.
             The geocoded point is defaulted to offset 10 meters from center-line off to side (L/R) of street address is located on.</para>
 
-        <para>Enhanced: 2.0.0 to support Tiger 2010 structured data and revised some logic to improve speed, accuracy of geocoding, and to offset point from centerline to side of street address is located on. New parameter max_results useful for specifying ot just return the best result.</para>
-        
+        <para>Enhanced: 2.0.0 to support Tiger 2010 structured data and revised some logic to improve speed, accuracy of geocoding, and to offset point from centerline to side of street address is located on. The new parameter <varname>max_results</varname> useful for specifying number of best results or just returning the best result.</para>
+
       </refsection>
 
 
@@ -277,29 +277,29 @@ DROP TABLE tiger_data.pa_zip_state_loc;
         <title>Examples: Basic</title>
         <para>The below examples timings are on a 3.0 GHZ single processor Windows 7 machine with 2GB ram running PostgreSQL 9.1rc1/PostGIS 2.0 loaded with all of MA,MN,CA, RI state Tiger data loaded.</para>
         <para>Exact matches are faster to compute (61ms)</para>
-        <programlisting>SELECT g.rating, ST_X(g.geomout) As lon, ST_Y(g.geomout) As lat, 
-    (addy).address As stno, (addy).streetname As street, 
-    (addy).streettypeabbrev As styp, (addy).location As city, (addy).stateabbrev As st,(addy).zip 
-    FROM geocode('75 State Street, Boston MA 02109') As g;  
- rating |        lon        |       lat        | stno | street | styp |  city  | st |  zip  
+        <programlisting>SELECT g.rating, ST_X(g.geomout) As lon, ST_Y(g.geomout) As lat,
+    (addy).address As stno, (addy).streetname As street,
+    (addy).streettypeabbrev As styp, (addy).location As city, (addy).stateabbrev As st,(addy).zip
+    FROM geocode('75 State Street, Boston MA 02109') As g;
+ rating |        lon        |       lat        | stno | street | styp |  city  | st |  zip
 --------+-------------------+------------------+------+--------+------+--------+----+-------
       0 | -71.0556722990239 | 42.3589914927049 |   75 | State  | St   | Boston | MA | 02109
 </programlisting>
         <para>Even if zip is not passed in the geocoder can guess (took about 122-150 ms)</para>
-        <programlisting>SELECT g.rating, ST_AsText(ST_SnapToGrid(g.geomout,0.00001)) As wktlonlat, 
-    (addy).address As stno, (addy).streetname As street, 
-    (addy).streettypeabbrev As styp, (addy).location As city, (addy).stateabbrev As st,(addy).zip 
-    FROM geocode('226 Hanover Street, Boston, MA',1) As g;  
- rating |         wktlonlat         | stno | street  | styp |  city  | st |  zip  
+        <programlisting>SELECT g.rating, ST_AsText(ST_SnapToGrid(g.geomout,0.00001)) As wktlonlat,
+    (addy).address As stno, (addy).streetname As street,
+    (addy).streettypeabbrev As styp, (addy).location As city, (addy).stateabbrev As st,(addy).zip
+    FROM geocode('226 Hanover Street, Boston, MA',1) As g;
+ rating |         wktlonlat         | stno | street  | styp |  city  | st |  zip
 --------+---------------------------+------+---------+------+--------+----+-------
       1 | POINT(-71.05528 42.36316) |  226 | Hanover | St   | Boston | MA | 02113
-</programlisting>     
+</programlisting>
 <para>Can handle misspellings and provides more than one possible solution with ratings and takes longer (500ms).</para>
-<programlisting>SELECT g.rating, ST_AsText(ST_SnapToGrid(g.geomout,0.00001)) As wktlonlat, 
-    (addy).address As stno, (addy).streetname As street, 
-    (addy).streettypeabbrev As styp, (addy).location As city, (addy).stateabbrev As st,(addy).zip 
-    FROM geocode('31 - 37 Stewart Street, Boston, MA 02116') As g; 
- rating |         wktlonlat         | stno | street | styp |  city  | st |  zip  
+<programlisting>SELECT g.rating, ST_AsText(ST_SnapToGrid(g.geomout,0.00001)) As wktlonlat,
+    (addy).address As stno, (addy).streetname As street,
+    (addy).streettypeabbrev As styp, (addy).location As city, (addy).stateabbrev As st,(addy).zip
+    FROM geocode('31 - 37 Stewart Street, Boston, MA 02116') As g;
+ rating |         wktlonlat         | stno | street | styp |  city  | st |  zip
 --------+---------------------------+------+--------+------+--------+----+-------
      70 | POINT(-71.06459 42.35113) |   31 | Stuart | St   | Boston | MA | 02116
     </programlisting>
@@ -315,19 +315,19 @@ VALUES ('529 Main Street, Boston MA, 02129'),
  ('26 Capen Street, Medford, MA'),
  ('124 Mount Auburn St, Cambridge, Massachusetts 02138'),
  ('950 Main Street, Worcester, MA 01610');
- 
+
 -- only update the first 3 addresses (323-704 ms -  there are caching and shared memory effects so first geocode you do is always slower) --
 -- for large numbers of addresses you don't want to update all at once
--- since the whole geocode must commit at once 
--- For this example we rejoin with LEFT JOIN 
--- and set to rating to -1 rating if no match 
--- to ensure we don't regeocode a bad address 
+-- since the whole geocode must commit at once
+-- For this example we rejoin with LEFT JOIN
+-- and set to rating to -1 rating if no match
+-- to ensure we don't regeocode a bad address
 UPDATE addresses_to_geocode
-  SET  (rating, new_address, lon, lat) 
+  SET  (rating, new_address, lon, lat)
     = ( COALESCE((g.geo).rating,-1), pprint_addy((g.geo).addy),
        ST_X((g.geo).geomout)::numeric(8,5), ST_Y((g.geo).geomout)::numeric(8,5) )
-FROM (SELECT addid 
-    FROM addresses_to_geocode 
+FROM (SELECT addid
+    FROM addresses_to_geocode
     WHERE rating IS NULL ORDER BY addid LIMIT 3) As a
     LEFT JOIN (SELECT addid, (geocode(address,1)) As geo
     FROM addresses_to_geocode As ag
@@ -340,7 +340,7 @@ Query returned successfully: 3 rows affected, 480 ms execution time.
 
 SELECT * FROM addresses_to_geocode WHERE rating is not null;
 
- addid |                   address                    |    lon    |   lat    |                new_address                | rating 
+ addid |                   address                    |    lon    |   lat    |                new_address                | rating
 -------+----------------------------------------------+-----------+----------+-------------------------------------------+--------
      1 | 529 Main Street, Boston MA, 02129            | -71.07181 | 42.38359 | 529 Main St, Boston, MA 02129             |      0
      2 | 77 Massachusetts Avenue, Cambridge, MA 02139 | -71.09428 | 42.35988 | 77 Massachusetts Ave, Cambridge, MA 02139 |      0
@@ -350,13 +350,13 @@ SELECT * FROM addresses_to_geocode WHERE rating is not null;
       <refsection>
           <title>Examples: Using Geometry filter</title>
           <programlisting>
-SELECT g.rating, ST_AsText(ST_SnapToGrid(g.geomout,0.00001)) As wktlonlat, 
-    (addy).address As stno, (addy).streetname As street, 
-    (addy).streettypeabbrev As styp, 
-    (addy).location As city, (addy).stateabbrev As st,(addy).zip 
+SELECT g.rating, ST_AsText(ST_SnapToGrid(g.geomout,0.00001)) As wktlonlat,
+    (addy).address As stno, (addy).streetname As street,
+    (addy).streettypeabbrev As styp,
+    (addy).location As city, (addy).stateabbrev As st,(addy).zip
   FROM geocode('100 Federal Street, MA',
-        3, 
-        (SELECT ST_Union(the_geom) 
+        3,
+        (SELECT ST_Union(the_geom)
             FROM place WHERE statefp = '25' AND name = 'Lynn')::geometry
         ) As g;
 
@@ -373,13 +373,12 @@ Total query runtime: 245 ms.
         <para><xref linkend="Normalize_Address" />, <xref linkend="Pprint_Addy" />, <xref linkend="ST_AsText"/>, <xref linkend="ST_SnapToGrid"/>, <xref linkend="ST_X"/>, <xref linkend="ST_Y"/></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Geocode_Intersection">
       <refnamediv>
         <refname>Geocode_Intersection</refname>
 
-        <refpurpose>Takes in 2 streets that intersect and a state, city, zip,  and outputs a set of possible locations on the first cross street that is at the intersection, also includes a point geometry in NAD 83 long lat, a normalized address for each location, and the rating.  The lower the rating the more likely the match.  
-            Results are sorted by lowest rating first. Can optionally pass in maximum results, defaults to 10</refpurpose>
+        <refpurpose>Takes in 2 streets that intersect and a state, city, zip, and outputs a set of possible locations on the first cross street that is at the intersection, also includes a geomout as the point location in NAD 83 long lat, a <varname>normalized_address</varname> (addy) for each location, and the rating. The lower the rating the more likely the match. Results are sorted by lowest rating first. Can optionally pass in maximum results, defaults to 10. Uses Tiger data (edges, faces, addr), PostgreSQL fuzzy string matching (soundex, levenshtein).</refpurpose>
       </refnamediv>
 
       <refsynopsisdiv>
@@ -402,13 +401,13 @@ Total query runtime: 245 ms.
       <refsection>
         <title>Description</title>
 
-        <para>Takes in 2 streets that intersect and a state, city, zip,  and outputs a set of possible locations on the first cross street that is at the intersection, also includes a point geometry in NAD 83 long lat, a normalized address for each location, and the rating.  The lower the rating the more likely the match.  
+        <para>Takes in 2 streets that intersect and a state, city, zip,  and outputs a set of possible locations on the first cross street that is at the intersection, also includes a point geometry in NAD 83 long lat, a normalized address for each location, and the rating.  The lower the rating the more likely the match.
             Results are sorted by lowest rating first. Can optionally pass in maximum results, defaults to 10.
-            Returns <varname>normalized_address</varname> (addy) for each, geomout as the point location in nad 83 long lat, and the rating.  The lower the rating the more likely the match.  
+            Returns <varname>normalized_address</varname> (addy) for each, geomout as the point location in nad 83 long lat, and the rating.  The lower the rating the more likely the match.
             Results are sorted by lowest rating first.  Uses Tiger data (edges,faces,addr), PostgreSQL fuzzy string matching (soundex,levenshtein) </para>
 
         <para>Availability: 2.0.0</para>
-        
+
       </refsection>
 
 
@@ -416,20 +415,20 @@ Total query runtime: 245 ms.
         <title>Examples: Basic</title>
         <para>The below examples timings are on a 3.0 GHZ single processor Windows 7 machine with 2GB ram running PostgreSQL 9.0/PostGIS 1.5 loaded with all of MA state Tiger data loaded. Currently a bit slow (3000 ms)</para>
         <para>Testing on Windows 2003 64-bit 8GB on PostGIS 2.0 PostgreSQL 64-bit Tiger 2011 data loaded -- (41ms)</para>
-        <programlisting>SELECT pprint_addy(addy), st_astext(geomout),rating 
-            FROM geocode_intersection( 'Haverford St','Germania St', 'MA', 'Boston', '02130',1); 
+        <programlisting>SELECT pprint_addy(addy), st_astext(geomout),rating
+            FROM geocode_intersection( 'Haverford St','Germania St', 'MA', 'Boston', '02130',1);
            pprint_addy            |         st_astext          | rating
 ----------------------------------+----------------------------+--------
 98 Haverford St, Boston, MA 02130 | POINT(-71.101375 42.31376) |      0
 </programlisting>
         <para>Even if zip is not passed in the geocoder can guess (took about 3500 ms on the windows 7 box), on the windows 2003 64-bit 741 ms</para>
-        <programlisting>SELECT pprint_addy(addy), st_astext(geomout),rating 
+        <programlisting>SELECT pprint_addy(addy), st_astext(geomout),rating
                 FROM geocode_intersection('Weld', 'School', 'MA', 'Boston');
           pprint_addy          |        st_astext         | rating
 -------------------------------+--------------------------+--------
  98 Weld Ave, Boston, MA 02119 | POINT(-71.099 42.314234) |      3
  99 Weld Ave, Boston, MA 02119 | POINT(-71.099 42.314234) |      3
-</programlisting>     
+</programlisting>
       </refsection>
 
       <!-- Optionally add a "See Also" section -->
@@ -438,7 +437,7 @@ Total query runtime: 245 ms.
         <para><xref linkend="Geocode" />, <xref linkend="Pprint_Addy" />, <xref linkend="ST_AsText"/></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Get_Geocode_Setting">
       <refnamediv>
         <refname>Get_Geocode_Setting</refname>
@@ -465,14 +464,14 @@ Total query runtime: 245 ms.
  debug_geocode_intersection     | false   | boolean | debug     | outputs debug information in notice log such as queries when geocode_intersection is called if true
  debug_normalize_address        | false   | boolean | debug     | outputs debug information in notice log such as queries and intermediate expressions when normalize_address is called if true
  debug_reverse_geocode          | false   | boolean | debug     | if true, outputs debug information in notice log such as queries and intermediate expressions when reverse_geocode
- reverse_geocode_numbered_roads | 0       | integer | rating    | For state and county highways, 0 - no preference in name, 
+ reverse_geocode_numbered_roads | 0       | integer | rating    | For state and county highways, 0 - no preference in name,
                                                                   1 - prefer the numbered highway name, 2 - prefer local state/county name
- use_pagc_address_parser        | false   | boolean | normalize | If set to true, will try to use the address_standardizer extension (via pagc_normalize_address) 
+ use_pagc_address_parser        | false   | boolean | normalize | If set to true, will try to use the address_standardizer extension (via pagc_normalize_address)
                                                                  instead of tiger normalize_address built one    </screen>
 
-        <para>Changed: 2.2.0 : default settings are now kept in a table called geocode_settings_default. Use customized settingsa re in geocode_settings and only contain those that have been set by user.</para>
+        <para>Changed: 2.2.0 : default settings are now kept in a table called geocode_settings_default. Use customized settingsa are in geocode_settings and only contain those that have been set by user.</para>
         <para>Availability: 2.1.0</para>
-        
+
       </refsection>
 
 
@@ -482,7 +481,7 @@ Total query runtime: 245 ms.
 result
 ---------
 false
-        </programlisting>    
+        </programlisting>
       </refsection>
 
       <!-- Optionally add a "See Also" section -->
@@ -491,7 +490,7 @@ false
         <para><xref linkend="Set_Geocode_Setting" /></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Get_Tract">
       <refnamediv>
         <refname>Get_Tract</refname>
@@ -515,7 +514,7 @@ false
         <para>Given a geometry will return the census tract location of that geometry. NAD 83 long lat is assumed if no spatial ref sys is specified.</para>
 
         <para>Availability: 2.0.0</para>
-        
+
       </refsection>
 
 
@@ -530,7 +529,7 @@ tract_name
 SELECT get_tract(ST_Point(-71.101375, 42.31376), 'tract_id' ) As tract_id;
 tract_id
 ---------
-25025120301</programlisting>        
+25025120301</programlisting>
       </refsection>
 
       <!-- Optionally add a "See Also" section -->
@@ -539,7 +538,7 @@ tract_id
         <para><xref linkend="Geocode" />></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Install_Missing_Indexes">
       <refnamediv>
         <refname>Install_Missing_Indexes</refname>
@@ -563,8 +562,8 @@ tract_id
             define the index for those tables and then execute the generated script. This is a helper function that adds new indexes needed to make queries faster that may have been missing during the load process.
            This function is a companion to <xref linkend="Missing_Indexes_Generate_Script" /> that in addition to generating the create index script, also executes it.
            It is called as part of the <filename>update_geocode.sql</filename> upgrade script.</para>
-    
-        
+
+
         <para>Availability: 2.0.0</para>
 
 
@@ -578,7 +577,7 @@ tract_id
 -------------------------
  t
         </programlisting>
-    
+
       </refsection>
 
       <!-- Optionally add a "See Also" section -->
@@ -623,7 +622,7 @@ tract_id
           <listitem>
             <para><varname>loader_lookuptables</varname> each record defines a kind of table (state, county), whether to process records in it and how to load them in.  Defines the steps to import data, stage data, add, removes columns, indexes, and constraints for each.  Each table is prefixed with the state and inherits from a table in the tiger schema. e.g. creates <varname>tiger_data.ma_faces</varname> which inherits from <varname>tiger.faces</varname></para>
           </listitem>
-        </orderedlist> 
+        </orderedlist>
         <para>Availability: 2.0.0 </para>
         <note><para><xref linkend="Loader_Generate_Script" /> includes this logic, but if you installed tiger geocoder prior to PostGIS 2.0.0 alpha5, you'll need to run this on the states you have already done
             to get these additional tables.</para></note>
@@ -654,9 +653,9 @@ del %TMPDIR%\*.* /Q
 %PSQL% -c "DROP SCHEMA tiger_staging CASCADE;"
 %PSQL% -c "CREATE SCHEMA tiger_staging;"
 cd %STATEDIR%
-for /r %%z in (*.zip) do %UNZIPTOOL% e %%z  -o%TMPDIR% 
-cd %TMPDIR%    
-%PSQL% -c "CREATE TABLE tiger_data.MA_tract(CONSTRAINT pk_MA_tract PRIMARY KEY (tract_id) ) INHERITS(tiger.tract); " 
+for /r %%z in (*.zip) do %UNZIPTOOL% e %%z  -o%TMPDIR%
+cd %TMPDIR%
+%PSQL% -c "CREATE TABLE tiger_data.MA_tract(CONSTRAINT pk_MA_tract PRIMARY KEY (tract_id) ) INHERITS(tiger.tract); "
 %SHP2PGSQL% -c -s 4269 -g the_geom   -W "latin1" tl_2010_25_tract10.dbf tiger_staging.ma_tract10 | %PSQL%
 %PSQL% -c "ALTER TABLE tiger_staging.MA_tract10 RENAME geoid10 TO tract_id;  SELECT loader_load_staged_data(lower('MA_tract10'), lower('MA_tract')); "
 %PSQL% -c "CREATE INDEX tiger_data_MA_tract_the_geom_gist ON tiger_data.MA_tract USING gist(the_geom);"
@@ -664,7 +663,7 @@ cd %TMPDIR%
 %PSQL% -c "ALTER TABLE tiger_data.MA_tract ADD CONSTRAINT chk_statefp CHECK (statefp = '25');"
 : </programlisting>
 <para>Generate sh script</para>
-<programlisting>STATEDIR="/gisdata/www2.census.gov/geo/pvs/tiger2010st/25_Massachusetts" 
+<programlisting>STATEDIR="/gisdata/www2.census.gov/geo/pvs/tiger2010st/25_Massachusetts"
 TMPDIR="/gisdata/temp/"
 UNZIPTOOL=unzip
 WGETTOOL="/usr/bin/wget"
@@ -695,7 +694,7 @@ for z in *.zip; do $UNZIPTOOL -o -d $TMPDIR $z; done
         <para><xref linkend="Loader_Generate_Script" /></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Loader_Generate_Script">
       <refnamediv>
         <refname>Loader_Generate_Script</refname>
@@ -731,7 +730,7 @@ for z in *.zip; do $UNZIPTOOL -o -d $TMPDIR $z; done
           <listitem>
             <para><varname>loader_lookuptables</varname> each record defines a kind of table (state, county), whether to process records in it and how to load them in.  Defines the steps to import data, stage data, add, removes columns, indexes, and constraints for each.  Each table is prefixed with the state and inherits from a table in the tiger schema. e.g. creates <varname>tiger_data.ma_faces</varname> which inherits from <varname>tiger.faces</varname></para>
           </listitem>
-        </orderedlist> 
+        </orderedlist>
         <para>Availability: 2.0.0 to support Tiger 2010 structured data and load census tract (tract), block groups (bg), and blocks (tabblocks) tables .</para>
 
 
@@ -762,7 +761,7 @@ set SHP2PGSQL="%PGBIN%shp2pgsql"
         <para>Generate sh script</para>
         <programlisting>SELECT loader_generate_script(ARRAY['MA','RI'], 'sh') AS result;
 -- result --
-STATEDIR="/gisdata/www2.census.gov/geo/pvs/tiger2010st/44_Rhode_Island" 
+STATEDIR="/gisdata/www2.census.gov/geo/pvs/tiger2010st/44_Rhode_Island"
 TMPDIR="/gisdata/temp/"
 UNZIPTOOL=unzip
 PGPORT=5432
@@ -785,7 +784,7 @@ wget http://www2.census.gov/geo/pvs/tiger2010st/44_Rhode_Island/ --no-parent --r
         <para></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Loader_Generate_Nation_Script">
       <refnamediv>
         <refname>Loader_Generate_Nation_Script</refname>
@@ -819,7 +818,7 @@ wget http://www2.census.gov/geo/pvs/tiger2010st/44_Rhode_Island/ --no-parent --r
           <listitem>
             <para><varname>loader_lookuptables</varname> each record defines a kind of table (state, county), whether to process records in it and how to load them in.  Defines the steps to import data, stage data, add, removes columns, indexes, and constraints for each.  Each table is prefixed with the state and inherits from a table in the tiger schema. e.g. creates <varname>tiger_data.ma_faces</varname> which inherits from <varname>tiger.faces</varname></para>
           </listitem>
-        </orderedlist> 
+        </orderedlist>
         <para>Availability: 2.1.0 </para>
         <note><para>If you were running <varname>tiger_2010</varname> version and you want to reload as state with <varname>tiger_2011</varname>, you'll need to for the very first load generate and run drop statements <xref linkend="Drop_Nation_Tables_Generate_Script" /> before you run this script.</para></note>
       </refsection>
@@ -839,7 +838,7 @@ wget http://www2.census.gov/geo/pvs/tiger2010st/44_Rhode_Island/ --no-parent --r
         <para><xref linkend="Loader_Generate_Script" /></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Missing_Indexes_Generate_Script">
       <refnamediv>
         <refname>Missing_Indexes_Generate_Script</refname>
@@ -864,8 +863,8 @@ wget http://www2.census.gov/geo/pvs/tiger2010st/44_Rhode_Island/ --no-parent --r
             define the index for those tables. This is a helper function that adds new indexes needed to make queries faster that may have been missing during the load process.
             As the geocoder is improved, this function will be updated to accommodate new indexes being used. If this function outputs nothing, it means
             all your tables have what we think are the key indexes already in place.</para>
-    
-        
+
+
         <para>Availability: 2.0.0</para>
 
 
@@ -886,7 +885,7 @@ CREATE INDEX idx_tiger_data_ma_cousub_countyfp ON tiger_data.ma_cousub USING btr
 CREATE INDEX idx_tiger_data_ma_edges_countyfp ON tiger_data.ma_edges USING btree(countyfp);
 CREATE INDEX idx_tiger_data_ma_faces_countyfp ON tiger_data.ma_faces USING btree(countyfp);
         </programlisting>
-    
+
       </refsection>
 
       <!-- Optionally add a "See Also" section -->
@@ -895,12 +894,12 @@ CREATE INDEX idx_tiger_data_ma_faces_countyfp ON tiger_data.ma_faces USING btree
         <para><xref linkend="Loader_Generate_Script"/>, <xref linkend="Install_Missing_Indexes" /></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Normalize_Address">
       <refnamediv>
         <refname>Normalize_Address</refname>
 
-        <refpurpose>Given a textual street address, returns a composite <varname>norm_addy</varname> type that has road suffix, prefix and type standardized, street, streetname etc. broken into separate fields.  This function 
+        <refpurpose>Given a textual street address, returns a composite <varname>norm_addy</varname> type that has road suffix, prefix and type standardized, street, streetname etc. broken into separate fields.  This function
         will work with just the lookup data packaged with the tiger_geocoder (no need for tiger census data).</refpurpose>
       </refnamediv>
 
@@ -916,7 +915,7 @@ CREATE INDEX idx_tiger_data_ma_faces_countyfp ON tiger_data.ma_faces USING btree
       <refsection>
         <title>Description</title>
 
-        <para>Given a textual street address, returns a composite <varname>norm_addy</varname> type that has road suffix, prefix and type standardized, street, streetname etc. broken into separate fields.  This is the first step in the geocoding process to 
+        <para>Given a textual street address, returns a composite <varname>norm_addy</varname> type that has road suffix, prefix and type standardized, street, streetname etc. broken into separate fields.  This is the first step in the geocoding process to
             get all addresses into normalized postal form. No other data is required aside from what is packaged with the geocoder.</para>
         <para>This function just uses the various direction/state/suffix lookup tables preloaded with the tiger_geocoder and located in the <varname>tiger</varname> schema, so it doesn't need you to download tiger census data or any other additional data to make use of it.
          You may find the need to add more abbreviations or alternative namings to the various lookup tables in the  <varname>tiger</varname> schema.</para>
@@ -965,18 +964,18 @@ CREATE INDEX idx_tiger_data_ma_faces_countyfp ON tiger_data.ma_faces USING btree
         <programlisting>SELECT address As orig, (g.na).streetname, (g.na).streettypeabbrev
  FROM (SELECT address, normalize_address(address) As na
         FROM addresses_to_geocode) As g;
-        
-                        orig                         |  streetname   | streettypeabbrev 
+
+                        orig                         |  streetname   | streettypeabbrev
 -----------------------------------------------------+---------------+------------------
  28 Capen Street, Medford, MA                        | Capen         | St
  124 Mount Auburn St, Cambridge, Massachusetts 02138 | Mount Auburn  | St
  950 Main Street, Worcester, MA 01610                | Main          | St
  529 Main Street, Boston MA, 02129                   | Main          | St
  77 Massachusetts Avenue, Cambridge, MA 02139        | Massachusetts | Ave
- 25 Wizard of Oz, Walaford, KS 99912323              | Wizard of Oz  | 
+ 25 Wizard of Oz, Walaford, KS 99912323              | Wizard of Oz  |
         </programlisting>
-        
-        
+
+
 
       </refsection>
 
@@ -986,12 +985,12 @@ CREATE INDEX idx_tiger_data_ma_faces_countyfp ON tiger_data.ma_faces USING btree
         <para><xref linkend="Geocode"/>, <xref linkend="Pprint_Addy"/></para>
       </refsection>
     </refentry>
-    
+
         <refentry id="Pagc_Normalize_Address">
       <refnamediv>
         <refname>Pagc_Normalize_Address</refname>
 
-        <refpurpose>Given a textual street address, returns a composite <varname>norm_addy</varname> type that has road suffix, prefix and type standardized, street, streetname etc. broken into separate fields.  This function 
+        <refpurpose>Given a textual street address, returns a composite <varname>norm_addy</varname> type that has road suffix, prefix and type standardized, street, streetname etc. broken into separate fields.  This function
         will work with just the lookup data packaged with the tiger_geocoder (no need for tiger census data). Requires address_standardizer extension.</refpurpose>
       </refnamediv>
 
@@ -1007,7 +1006,7 @@ CREATE INDEX idx_tiger_data_ma_faces_countyfp ON tiger_data.ma_faces USING btree
       <refsection>
         <title>Description</title>
 
-        <para>Given a textual street address, returns a composite <varname>norm_addy</varname> type that has road suffix, prefix and type standardized, street, streetname etc. broken into separate fields.  This is the first step in the geocoding process to 
+        <para>Given a textual street address, returns a composite <varname>norm_addy</varname> type that has road suffix, prefix and type standardized, street, streetname etc. broken into separate fields.  This is the first step in the geocoding process to
             get all addresses into normalized postal form. No other data is required aside from what is packaged with the geocoder.</para>
         <para>This function just uses the various pagc_* lookup tables preloaded with the tiger_geocoder and located in the <varname>tiger</varname> schema, so it doesn't need you to download tiger census data or any other additional data to make use of it.
          You may find the need to add more abbreviations or alternative namings to the various lookup tables in the  <varname>tiger</varname> schema.</para>
@@ -1019,7 +1018,7 @@ CREATE INDEX idx_tiger_data_ma_faces_countyfp ON tiger_data.ma_faces USING btree
         <para>(address) [predirAbbrev] (streetName) [streetTypeAbbrev] [postdirAbbrev] [internal] [location] [stateAbbrev] [zip]</para>
         <para>The native standardaddr of address_standardizer extension is at this time a bit richer than norm_addy since its designed to support international addresses (including country).  standardaddr equivalent fields are:</para>
         <para>house_num,predir, name, suftype, sufdir, unit, city, state, postcode</para>
-        
+
          <orderedlist>
           <listitem>
             <para><varname>address</varname> is an integer:  The street number</para>
@@ -1062,15 +1061,15 @@ CREATE INDEX idx_tiger_data_ma_faces_countyfp ON tiger_data.ma_faces USING btree
 SELECT addy.*
 FROM pagc_normalize_address('9000 E ROO ST STE 999, Springfield, CO') AS addy;
 
-        
+
  address | predirabbrev | streetname | streettypeabbrev | postdirabbrev | internal  |  location   | stateabbrev | zip | parsed
 ---------+--------------+------------+------------------+---------------+-----------+-------------+-------------+-----+--------
     9000 | E            | ROO        | ST               |               | SUITE 999 | SPRINGFIELD | CO          |     | t</programlisting>
-    
+
             <para>Batch call.  There are currently speed issues with the way postgis_tiger_geocoder wraps the address_standardizer.  These will hopefully
 be resolved in later editions.  To work around them, if you need speed for batch geocoding to call generate a normaddy  in batch mode, you are encouraged
 to directly call the address_standardizer standardize_address function as shown below which is similar exercise to what we did in <xref linkend="Normalize_Address" /> that uses data created in <xref linkend="Geocode" />.</para>
-    
+
     <programlisting>WITH g AS (SELECT address, ROW((sa).house_num, (sa).predir, (sa).name
   , (sa).suftype, (sa).sufdir, (sa).unit , (sa).city, (sa).state, (sa).postcode, true)::norm_addy As na
  FROM (SELECT address, standardize_address('tiger.pagc_lex'
@@ -1079,7 +1078,7 @@ to directly call the address_standardizer standardize_address function as shown
         FROM addresses_to_geocode) As g)
 SELECT address As orig, (g.na).streetname, (g.na).streettypeabbrev
  FROM  g;
- 
+
  orig                                                |  streetname   | streettypeabbrev
 -----------------------------------------------------+---------------+------------------
  529 Main Street, Boston MA, 02129                   | MAIN          | ST
@@ -1095,7 +1094,7 @@ SELECT address As orig, (g.na).streetname, (g.na).streettypeabbrev
         <para><xref linkend="Normalize_Address"/>, <xref linkend="Geocode"/></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Pprint_Addy">
       <refnamediv>
         <refname>Pprint_Addy</refname>
@@ -1117,7 +1116,7 @@ SELECT address As orig, (g.na).streetname, (g.na).streettypeabbrev
 
         <para>Given a <varname>norm_addy</varname> composite type object, returns a pretty print representation of it. No other data is required aside from what is packaged with the geocoder.</para>
         <para>Usually used in conjunction with <xref linkend="Normalize_Address"/>.</para>
-        
+
 
       </refsection>
 
@@ -1130,11 +1129,11 @@ SELECT address As orig, (g.na).streetname, (g.na).streettypeabbrev
 ---------------------------------------
  202 E Fremont St, Las Vegas, NV 89101
         </programlisting>
-        
+
         <para>Pretty print address a table of addresses</para>
         <programlisting>SELECT address As orig, pprint_addy(normalize_address(address)) As pretty_address
         FROM addresses_to_geocode;
-        
+
                         orig                         |              pretty_address
 -----------------------------------------------------+-------------------------------------------
  529 Main Street, Boston MA, 02129                   | 529 Main St, Boston MA, 02129
@@ -1151,14 +1150,14 @@ SELECT address As orig, (g.na).streetname, (g.na).streettypeabbrev
         <para><xref linkend="Normalize_Address"/></para>
       </refsection>
     </refentry>
-    
+
     <refentry id="Reverse_Geocode">
       <refnamediv>
         <refname>Reverse_Geocode</refname>
-    
+
         <refpurpose>Takes a geometry point in a known spatial ref sys and returns a record containing an array of theoretically possible addresses and an array of cross streets.  If include_strnum_range = true, includes the street range in the cross streets.</refpurpose>
       </refnamediv>
-    
+
       <refsynopsisdiv>
         <funcsynopsis>
           <funcprototype>
@@ -1171,18 +1170,18 @@ SELECT address As orig, (g.na).streetname, (g.na).streettypeabbrev
           </funcprototype>
         </funcsynopsis>
       </refsynopsisdiv>
-    
+
       <refsection>
         <title>Description</title>
-    
+
         <para>Takes a geometry point in a known spatial ref and returns a record containing an array of theoretically possible addresses and an array of cross streets.  If include_strnum_range = true, includes the street range in the cross streets.
         include_strnum_range defaults to false if not passed in. Addresses are sorted according to which road a point is closest to so first address is most likely the right one.</para>
-        
+
         <para>Why do we say theoretical instead of actual addresses.  The Tiger data doesn't have real addresses, but just street ranges.  As such the theoretical address is an interpolated address based on the
         street ranges. Like for example interpolating one of my addresses returns a 26 Court St. and 26 Court Sq., though there is no such place as 26 Court Sq.  This is because a point may be at a corner of 2
         streets and thus the logic interpolates along both streets.  The logic also assumes addresses are equally spaced along a street, which of course is wrong since you can have a municipal building taking up
             a good chunk of the street range and the rest of the buildings are clustered at the end.</para>
-    
+
         <para>Note: Hmm this function relies on Tiger data.  If you have not loaded data covering the region of this point, then hmm you will get a record filled with NULLS.</para>
         <para> Returned elements of the record are as follows:</para>
          <orderedlist>
@@ -1197,29 +1196,29 @@ SELECT address As orig, (g.na).streetname, (g.na).streettypeabbrev
             <para><varname>street</varname> an array of varchar:  These are cross streets (or the street) (streets that intersect or are the street the point is projected to be on).</para>
           </listitem>
         </orderedlist>
-      
+
         <!-- use this format if new function -->
         <para>Availability: 2.0.0 </para>
       </refsection>
-    
-    
+
+
       <refsection>
         <title>Examples</title>
-        <para>Example of a point at the corner of two streets, but closest to one.  This is approximate location of MIT: 77 Massachusetts Ave, Cambridge, MA 02139  
-            Note that although we don't have 3 streets, PostgreSQL will just return null for entries above our upper bound so safe to use.  This includes street ranges</para> 
-        <programlisting>SELECT pprint_addy(r.addy[1]) As st1, pprint_addy(r.addy[2]) As st2, pprint_addy(r.addy[3]) As st3, 
-            array_to_string(r.street, ',') As cross_streets 
+        <para>Example of a point at the corner of two streets, but closest to one.  This is approximate location of MIT: 77 Massachusetts Ave, Cambridge, MA 02139
+            Note that although we don't have 3 streets, PostgreSQL will just return null for entries above our upper bound so safe to use.  This includes street ranges</para>
+        <programlisting>SELECT pprint_addy(r.addy[1]) As st1, pprint_addy(r.addy[2]) As st2, pprint_addy(r.addy[3]) As st3,
+            array_to_string(r.street, ',') As cross_streets
         FROM reverse_geocode(ST_GeomFromText('POINT(-71.093902 42.359446)',4269),true) As r;
-       
+
  result
  ------
       st1                                  | st2 | st3 |               cross_streets
 -------------------------------------------+-----+-----+----------------------------------------------
  67 Massachusetts Ave, Cambridge, MA 02139 |     |     | 67 - 127 Massachusetts Ave,32 - 88 Vassar St</programlisting>
-            
-         <para>Here we choose not to include the address ranges for the cross streets and picked a location 
+
+         <para>Here we choose not to include the address ranges for the cross streets and picked a location
 really really close to a corner of 2 streets thus could be known by two different addresses.</para>
-<programlisting>SELECT pprint_addy(r.addy[1]) As st1, pprint_addy(r.addy[2]) As st2, 
+<programlisting>SELECT pprint_addy(r.addy[1]) As st1, pprint_addy(r.addy[2]) As st2,
 pprint_addy(r.addy[3]) As st3, array_to_string(r.street, ',') As cross_str
 FROM reverse_geocode(ST_GeomFromText('POINT(-71.06941 42.34225)',4269)) As r;
 
@@ -1231,38 +1230,38 @@ result
 </programlisting>
 
 <para>For this one we reuse our geocoded example from <xref linkend="Geocode" /> and we only want the primary address and at most 2 cross streets.</para>
-<programlisting>SELECT actual_addr, lon, lat, pprint_addy((rg).addy[1]) As int_addr1, 
+<programlisting>SELECT actual_addr, lon, lat, pprint_addy((rg).addy[1]) As int_addr1,
     (rg).street[1] As cross1, (rg).street[2] As cross2
 FROM (SELECT address As actual_addr, lon, lat,
     reverse_geocode( ST_SetSRID(ST_Point(lon,lat),4326) ) As rg
     FROM addresses_to_geocode WHERE rating > -1) As foo;
 
-                     actual_addr                     |    lon    |   lat    |                 int_addr1                 |     cross1      |   cross2   
+                     actual_addr                     |    lon    |   lat    |                 int_addr1                 |     cross1      |   cross2
 -----------------------------------------------------+-----------+----------+-------------------------------------------+-----------------+------------
- 529 Main Street, Boston MA, 02129                   | -71.07181 | 42.38359 | 527 Main St, Boston, MA 02129             | Medford St      | 
- 77 Massachusetts Avenue, Cambridge, MA 02139        | -71.09428 | 42.35988 | 77 Massachusetts Ave, Cambridge, MA 02139 | Vassar St       | 
+ 529 Main Street, Boston MA, 02129                   | -71.07181 | 42.38359 | 527 Main St, Boston, MA 02129             | Medford St      |
+ 77 Massachusetts Avenue, Cambridge, MA 02139        | -71.09428 | 42.35988 | 77 Massachusetts Ave, Cambridge, MA 02139 | Vassar St       |
  26 Capen Street, Medford, MA                        | -71.12377 | 42.41101 | 9 Edison Ave, Medford, MA 02155           | Capen St        | Tesla Ave
- 124 Mount Auburn St, Cambridge, Massachusetts 02138 | -71.12304 | 42.37328 | 3 University Rd, Cambridge, MA 02138      | Mount Auburn St | 
+ 124 Mount Auburn St, Cambridge, Massachusetts 02138 | -71.12304 | 42.37328 | 3 University Rd, Cambridge, MA 02138      | Mount Auburn St |
  950 Main Street, Worcester, MA 01610                | -71.82368 | 42.24956 | 3 Maywood St, Worcester, MA 01603         | Main St         | Maywood Pl
 </programlisting>
       </refsection>
-    
+
       <!-- Optionally add a "See Also" section -->
       <refsection>
         <title>See Also</title>
-    
+
         <para><xref linkend="Pprint_Addy" />, <xref linkend="Geocode" /></para>
       </refsection>
     </refentry>
-    
+
    <refentry id="Topology_Load_Tiger">
       <refnamediv>
         <refname>Topology_Load_Tiger</refname>
-    
+
         <refpurpose>Loads a defined region of tiger data into a PostGIS Topology and transforming the tiger data to spatial reference of the topology
             and snapping to the precision tolerance of the topology.</refpurpose>
       </refnamediv>
-    
+
       <refsynopsisdiv>
         <funcsynopsis>
           <funcprototype>
@@ -1273,18 +1272,18 @@ FROM (SELECT address As actual_addr, lon, lat,
           </funcprototype>
         </funcsynopsis>
       </refsynopsisdiv>
-    
+
       <refsection>
         <title>Description</title>
-    
+
         <para>Loads a defined region of tiger data into a PostGIS Topology. The faces, nodes and edges are transformed to the spatial reference system of the target topology and points are snapped to the tolerance of the target topology. The created faces, nodes, edges maintain the same ids as the original Tiger data faces, nodes, edges
         so that datasets can be in the future be more easily reconciled with tiger data. Returns summary details about the process.</para>
-        
+
         <para>This would be useful for example for redistricting data where you require the newly formed polygons to follow the center lines of streets and for the resulting polygons not to overlap.</para>
-    
+
         <note><para>This function relies on Tiger data as well as the installation of the PostGIS topology module.  For more information, refer to <xref linkend="Topology" /> and <xref linkend="installation_configuration" />.  If you have not loaded data covering the region of interest, then no topology records will be created. This function will also fail if you have not created a topology using the topology functions.</para></note>
-        
-        <note><para>Most topology validation errors are a result of tolerance issues where after transformation the edges points don't quite line up or overlap. 
+
+        <note><para>Most topology validation errors are a result of tolerance issues where after transformation the edges points don't quite line up or overlap.
         To remedy the situation you may want to increase or lower the precision if you get topology validation failures.</para></note>
         <para> Required arguments:</para>
          <orderedlist>
@@ -1299,24 +1298,24 @@ FROM (SELECT address As actual_addr, lon, lat,
             </para>
           </listitem>
         </orderedlist>
-      
+
         <!-- use this format if new function -->
         <para>Availability: 2.0.0 </para>
       </refsection>
       <refsection>
       <title>Example: Boston, Massachusetts Topology</title>
-      <para>Create a topology for Boston, Massachusetts in Mass State Plane Feet (2249) 
+      <para>Create a topology for Boston, Massachusetts in Mass State Plane Feet (2249)
           with tolerance 0.25 feet and then load in Boston city tiger faces, edges, nodes.</para>
       <programlisting>SELECT topology.CreateTopology('topo_boston', 2249, 0.25);
 createtopology
 --------------
    15
--- 60,902 ms ~ 1 minute on windows 7 desktop running 9.1 (with 5 states tiger data loaded) 
-SELECT tiger.topology_load_tiger('topo_boston', 'place', '2507000'); 
+-- 60,902 ms ~ 1 minute on windows 7 desktop running 9.1 (with 5 states tiger data loaded)
+SELECT tiger.topology_load_tiger('topo_boston', 'place', '2507000');
 -- topology_loader_tiger --
-29722 edges holding in temporary. 11108 faces added. 1875 edges of faces added.  20576 nodes added.  
-19962 nodes contained in a face.  0 edge start end corrected.  31597 edges added. 
- 
+29722 edges holding in temporary. 11108 faces added. 1875 edges of faces added.  20576 nodes added.
+19962 nodes contained in a face.  0 edge start end corrected.  31597 edges added.
+
 -- 41 ms --
 SELECT topology.TopologySummary('topo_boston');
  -- topologysummary--
@@ -1324,25 +1323,25 @@ Topology topo_boston (15), SRID 2249, precision 0.25
 20576 nodes, 31597 edges, 11109 faces, 0 topogeoms in 0 layers
 
 -- 28,797 ms to validate yeh returned no errors --
-SELECT * FROM 
-    topology.ValidateTopology('topo_boston'); 
-    
+SELECT * FROM
+    topology.ValidateTopology('topo_boston');
+
        error       |   id1    |    id2
 -------------------+----------+-----------
       </programlisting>
       </refsection>
-      
+
       <refsection>
       <title>Example: Suffolk, Massachusetts Topology</title>
-      <para>Create a topology for Suffolk, Massachusetts in Mass State Plane Meters (26986) 
+      <para>Create a topology for Suffolk, Massachusetts in Mass State Plane Meters (26986)
           with tolerance 0.25 meters and then load in Suffolk county tiger faces, edges, nodes.</para>
       <programlisting>SELECT topology.CreateTopology('topo_suffolk', 26986, 0.25);
 -- this took 56,275 ms ~ 1 minute on Windows 7 32-bit with 5 states of tiger loaded
 -- must have been warmed up after loading boston
-SELECT tiger.topology_load_tiger('topo_suffolk', 'county', '25025');  
+SELECT tiger.topology_load_tiger('topo_suffolk', 'county', '25025');
 -- topology_loader_tiger --
- 36003 edges holding in temporary. 13518 faces added. 2172 edges of faces added. 
- 24761 nodes added.  24075 nodes contained in a face.  0 edge start end corrected.  38175 edges added. 
+ 36003 edges holding in temporary. 13518 faces added. 2172 edges of faces added.
+ 24761 nodes added.  24075 nodes contained in a face.  0 edge start end corrected.  38175 edges added.
 -- 31 ms --
 SELECT topology.TopologySummary('topo_suffolk');
  -- topologysummary--
@@ -1350,9 +1349,9 @@ SELECT topology.TopologySummary('topo_suffolk');
 24761 nodes, 38175 edges, 13519 faces, 0 topogeoms in 0 layers
 
 -- 33,606 ms to validate --
-SELECT * FROM 
-    topology.ValidateTopology('topo_suffolk'); 
-    
+SELECT * FROM
+    topology.ValidateTopology('topo_suffolk');
+
        error       |   id1    |    id2
 -------------------+----------+-----------
  coincident nodes  | 81045651 |  81064553
@@ -1369,7 +1368,7 @@ SELECT * FROM
         <para><xref linkend="CreateTopology" />, <xref linkend="CreateTopoGeom" />, <xref linkend="TopologySummary" />, <xref linkend="ValidateTopology" /></para>
       </refsection>
    </refentry>
-   
+
        <refentry id="Set_Geocode_Setting">
       <refnamediv>
         <refname>Set_Geocode_Setting</refname>
@@ -1393,7 +1392,7 @@ SELECT * FROM
         <para>Sets value of specific setting stored in <varname>tiger.geocode_settings</varname> table.  Settings allow you to toggle debugging of functions.  Later plans will be to control rating with settings. Current list of settings are listed in <xref linkend="Get_Geocode_Setting" />.</para>
 
         <para>Availability: 2.1.0</para>
-        
+
       </refsection>
 
 
@@ -1403,7 +1402,7 @@ SELECT * FROM
         <programlisting>SELECT set_geocode_setting('debug_geocode_address', 'true') As result;
 result
 ---------
-true</programlisting>    
+true</programlisting>
       </refsection>
 
       <!-- Optionally add a "See Also" section -->
diff --git a/doc/extras_topology.xml b/doc/extras_topology.xml
index 45fc82c..7fa8e14 100644
--- a/doc/extras_topology.xml
+++ b/doc/extras_topology.xml
@@ -581,68 +581,68 @@ face without edges |   0 |
 				<refname>CreateTopology</refname>
 				<refpurpose>Creates a new topology schema and registers this new schema in the topology.topology table.</refpurpose>
 			</refnamediv>
-		
+
 			<refsynopsisdiv>
 				<funcsynopsis>
 					<funcprototype>
 						<funcdef>integer <function>CreateTopology</function></funcdef>
 						<paramdef><type>varchar </type> <parameter>topology_schema_name</parameter></paramdef>
 					</funcprototype>
-					
+
 					<funcprototype>
 						<funcdef>integer <function>CreateTopology</function></funcdef>
 						<paramdef><type>varchar </type> <parameter>topology_schema_name</parameter></paramdef>
 						<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
 					</funcprototype>
-		
+
 					<funcprototype>
 						<funcdef>integer <function>CreateTopology</function></funcdef>
 						<paramdef><type>varchar </type> <parameter>topology_schema_name</parameter></paramdef>
 						<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
-						<paramdef><type>double precision </type> <parameter>tolerance</parameter></paramdef>
+						<paramdef><type>double precision </type> <parameter>prec</parameter></paramdef>
 					</funcprototype>
-					
+
 					<funcprototype>
 						<funcdef>integer <function>CreateTopology</function></funcdef>
 						<paramdef><type>varchar </type> <parameter>topology_schema_name</parameter></paramdef>
 						<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
-						<paramdef><type>double precision </type> <parameter>tolerance</parameter></paramdef>
+						<paramdef><type>double precision </type> <parameter>prec</parameter></paramdef>
 						<paramdef><type>boolean </type> <parameter>hasz</parameter></paramdef>
 					</funcprototype>
 				</funcsynopsis>
 			</refsynopsisdiv>
-		
+
 			<refsection>
                 <title>Description</title>
-            
+
                 <para>Creates a new schema with name <varname>topology_name</varname> consisting of tables (<varname>edge_data</varname>,<varname>face</varname>,<varname>node</varname>, <varname>relation</varname>
-                    and registers this new topology in the topology.topology table. It returns the id of the topology in the topology table. The srid is the spatial reference identified as 
-                defined in spatial_ref_sys table for that topology.  Topologies must be uniquely named.  The tolerance is measured in the units of the spatial reference system.  If the tolerance is not specified defaults to 0.</para>
-                
+                    and registers this new topology in the topology.topology table. It returns the id of the topology in the topology table. The srid is the spatial reference identified as
+                defined in spatial_ref_sys table for that topology.  Topologies must be uniquely named.  The tolerance is measured in the units of the spatial reference system.  If the tolerance (<varname>prec</varname>) is not specified defaults to 0.</para>
+
                 <para>This is similar to the SQL/MM <xref linkend="ST_InitTopoGeo" /> but a bit more functional.  <varname>hasz</varname> defaults to false if not specified.</para>
-        
+
                 <!-- use this format if new function -->
                 <para>Availability: 1.?</para>
 			</refsection>
-		
-		
+
+
 			<refsection>
 				<title>Examples</title>
 				<para>This example creates a new schema called ma_topo that will store edges, faces, and relations in Massachusetts State Plane meters.
 					The tolerance represents 1/2 meter since the spatial reference system is a meter based spatial reference system</para>
 				<programlisting>SELECT topology.CreateTopology('ma_topo',26986, 0.5);</programlisting>
-				
+
 				<para>Create Rhode Island topology in State Plane ft</para>
 <programlisting>SELECT topology.CreateTopology('ri_topo',3438) As topoid;
 topoid
 ------
 2</programlisting>
 			</refsection>
-		
+
 			<!-- Optionally add a "See Also" section -->
 			<refsection>
 				<title>See Also</title>
-			
+
 				<para><xref linkend="spatial_ref_sys"/>, <xref linkend="ST_InitTopoGeo" />, <xref linkend="Topology_Load_Tiger" /></para>
 			</refsection>
 		</refentry>
diff --git a/doc/faq_raster.xml b/doc/faq_raster.xml
index c18653b..deb92c7 100644
--- a/doc/faq_raster.xml
+++ b/doc/faq_raster.xml
@@ -264,7 +264,7 @@ END
       </question>
 
       <answer>
-        <para>The function is not unique error happens if one of your arguments is a textual representation of a geometry instead of a geometry.  In these cases, PostgreSQL marks the textual representation as an unknown type, which means it can fall into the st_intersects(raster, geometry) or st_intersects(raster,raster) thus resulting in a non-unique case since both functions can in theory support your request.  To prevent this, you need to cast the geometry to a geometry.</para>
+        <para>The function is not unique error happens if one of your arguments is a textual representation of a geometry instead of a geometry.  In these cases, PostgreSQL marks the textual representation as an unknown type, which means it can fall into the st_intersects(raster, geometry) or st_intersects(raster,raster) thus resulting in a non-unique case since both functions can in theory support your request.  To prevent this, you need to cast the textual representation of the geometry to a geometry.</para>
         <para>For example if your code looks like this:</para>
         <programlisting>SELECT rast
  FROM my_raster
diff --git a/doc/reference_constructor.xml b/doc/reference_constructor.xml
index 8d59a18..6c81a12 100644
--- a/doc/reference_constructor.xml
+++ b/doc/reference_constructor.xml
@@ -425,7 +425,7 @@ LINESTRING(-113.98 39.198,-113.981 39.195)
 \\312Q\\300\\366{b\\235*!E@\\225|\\354.P\\312Q
 \\300p\\231\\323e1!E@');</programlisting>
 
-		<note><para>In PostgreSQL 9.1+ - standard_conforming_strings is set to on by default, where as in past versions it was set to on.  You can change defaults as needed
+		<note><para>In PostgreSQL 9.1+ - standard_conforming_strings is set to on by default, where as in past versions it was set to off.  You can change defaults as needed
 		    for a single query or at the database or server level.  Below is how you would do it with standard_conforming_strings = on.  In this case we escape the ' with standard ansi ',
 		    but slashes are not escaped</para></note>
 	<programlisting>
diff --git a/doc/reference_measure.xml b/doc/reference_measure.xml
index 50647b0..0e20a0b 100644
--- a/doc/reference_measure.xml
+++ b/doc/reference_measure.xml
@@ -2621,11 +2621,12 @@ SELECT s.gid, s.school_name
 			points are the same).</para>
 
 		<important>
-		  <para>This function will return false if either geometry is invalid even if they are binary equal.</para>
+		  <para>This function will return false if either geometry is invalid except in the case where they are binary equal.</para>
 		</important>
 
 		<para>&sfs_compliant; s2.1.1.2</para>
 		<para>&sqlmm_compliant; SQL-MM 3: 5.1.24</para>
+        <para>Changed: 2.2.0 Returns true even for invalid geometries if they are binary equal</para>
 	  </refsection>
 
 	  <refsection>
@@ -2969,7 +2970,7 @@ ST_3DLength
 	  <refnamediv>
 		<refname>ST_LengthSpheroid</refname>
 
-		<refpurpose>Calculates the 2D or 3D length of a linestring/multilinestring on an ellipsoid. This
+        <refpurpose>Calculates the 2D or 3D length/perimeter of a geometry on an ellipsoid. This
 			is useful if the coordinates of the geometry are in
 			longitude/latitude and a length is desired without reprojection.</refpurpose>
 	  </refnamediv>
@@ -2978,7 +2979,7 @@ ST_3DLength
 		<funcsynopsis>
 		  <funcprototype>
 			<funcdef>float <function>ST_LengthSpheroid</function></funcdef>
-			<paramdef><type>geometry </type> <parameter>a_linestring</parameter></paramdef>
+			<paramdef><type>geometry </type> <parameter>a_geometry</parameter></paramdef>
 			<paramdef><type>spheroid </type> <parameter>a_spheroid</parameter></paramdef>
 		  </funcprototype>
 		</funcsynopsis>
@@ -2987,25 +2988,21 @@ ST_3DLength
 	  <refsection>
 		<title>Description</title>
 
-		<para>Calculates the length of a geometry on an ellipsoid. This
+        <para>Calculates the length/perimeter of a geometry on an ellipsoid. This
 			is useful if the coordinates of the geometry are in
 			longitude/latitude and a length is desired without reprojection.
 			The ellipsoid is a separate database type and can be constructed
 			as follows:</para>
 
-		<literallayout>SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR
-		  AXIS&gt;,&lt;INVERSE FLATTENING&gt;]</literallayout>
-
+		<literallayout>SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR AXIS&gt;,&lt;INVERSE FLATTENING&gt;]</literallayout>
 
 		<literallayout>SPHEROID["GRS_1980",6378137,298.257222101]</literallayout>
-		<note><para>Will return 0 for anything that is not a MULTILINESTRING or LINESTRING</para></note>
 
 		<para>Availability: 1.2.2</para>
 		<para>Changed: 2.2.0 In prior versions this used to be called ST_Length_Spheroid and used to have a ST_3DLength_Spheroid alias</para>
 		<para>&Z_support;</para>
 	  </refsection>
 
-
 	  <refsection>
 		<title>Examples</title>
 
@@ -3050,7 +3047,7 @@ CAST('SPHEROID["GRS_1980",6378137,298.257222101]' As spheroid) As sph_m)  as foo
 	  <refnamediv>
 		<refname>ST_Length2D_Spheroid</refname>
 
-		<refpurpose>Calculates the 2D length of a linestring/multilinestring on an ellipsoid. This
+        <refpurpose>Calculates the 2D length/perimeter of a geometry on an ellipsoid. This
 			is useful if the coordinates of the geometry are in
 			longitude/latitude and a length is desired without reprojection.  </refpurpose>
 	  </refnamediv>
@@ -3059,7 +3056,7 @@ CAST('SPHEROID["GRS_1980",6378137,298.257222101]' As spheroid) As sph_m)  as foo
 		<funcsynopsis>
 		  <funcprototype>
 			<funcdef>float <function>ST_Length2D_Spheroid</function></funcdef>
-			<paramdef><type>geometry </type> <parameter>a_linestring</parameter></paramdef>
+			<paramdef><type>geometry </type> <parameter>a_geometry</parameter></paramdef>
 			<paramdef><type>spheroid </type> <parameter>a_spheroid</parameter></paramdef>
 		  </funcprototype>
 		</funcsynopsis>
@@ -3068,20 +3065,16 @@ CAST('SPHEROID["GRS_1980",6378137,298.257222101]' As spheroid) As sph_m)  as foo
 	  <refsection>
 		<title>Description</title>
 
-		<para>Calculates the 2D length of a geometry on an ellipsoid. This
+        <para>Calculates the 2D length/perimeter of a geometry on an ellipsoid. This
 			is useful if the coordinates of the geometry are in
 			longitude/latitude and a length is desired without reprojection.
 			The ellipsoid is a separate database type and can be constructed
 			as follows:</para>
 
-		<literallayout>SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR
-		  AXIS&gt;,&lt;INVERSE FLATTENING&gt;]</literallayout>
-
+		<literallayout>SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR AXIS&gt;,&lt;INVERSE FLATTENING&gt;]</literallayout>
 
 		<literallayout>SPHEROID["GRS_1980",6378137,298.257222101]</literallayout>
-		<note><para>Will return 0 for anything that is not a MULTILINESTRING or LINESTRING</para></note>
-		<note><para>This is much like <xref linkend="ST_Length_Spheroid" /> except it will throw away the Z coordinate in calculations.</para></note>
-
+		<note><para>This is much like <xref linkend="ST_Length_Spheroid" /> except it will ignore the Z ordinate in calculations.</para></note>
 	  </refsection>
 
 
diff --git a/doc/reference_raster.xml b/doc/reference_raster.xml
index 76e4a91..5902e6f 100644
--- a/doc/reference_raster.xml
+++ b/doc/reference_raster.xml
@@ -4283,8 +4283,8 @@ SELECT x, y, val, ST_AsText(geom) FROM (SELECT (ST_PixelAsPoints(rast, 1)).* FRO
 					<funcprototype>
 						<funcdef>geometry <function>ST_PixelAsCentroid</function></funcdef>
 						<paramdef><type>raster </type> <parameter>rast</parameter></paramdef>
-						<paramdef><type>integer </type> <parameter>columnx</parameter></paramdef>
-						<paramdef><type>integer </type> <parameter>rowy</parameter></paramdef>
+						<paramdef><type>integer </type> <parameter>x</parameter></paramdef>
+						<paramdef><type>integer </type> <parameter>y</parameter></paramdef>
 					</funcprototype>
 				</funcsynopsis>
 			</refsynopsisdiv>
@@ -4417,23 +4417,23 @@ SELECT x, y, val, ST_AsText(geom) FROM (SELECT (ST_PixelAsCentroids(rast, 1)).*
 				 <funcprototype>
 					<funcdef>double precision <function>ST_Value</function></funcdef>
 					<paramdef><type>raster </type> <parameter>rast</parameter></paramdef>
-					<paramdef><type>integer </type> <parameter>bandnum</parameter></paramdef>
+					<paramdef><type>integer </type> <parameter>band</parameter></paramdef>
 					<paramdef><type>geometry </type> <parameter>pt</parameter></paramdef>
 					<paramdef choice="opt"><type>boolean </type> <parameter>exclude_nodata_value=true</parameter></paramdef>
 				  </funcprototype>
 				  <funcprototype>
 					<funcdef>double precision <function>ST_Value</function></funcdef>
 					<paramdef><type>raster </type> <parameter>rast</parameter></paramdef>
-					<paramdef><type>integer </type> <parameter>columnx</parameter></paramdef>
-					<paramdef><type>integer </type> <parameter>rowy</parameter></paramdef>
+					<paramdef><type>integer </type> <parameter>x</parameter></paramdef>
+					<paramdef><type>integer </type> <parameter>y</parameter></paramdef>
 					<paramdef choice="opt"><type>boolean </type> <parameter>exclude_nodata_value=true</parameter></paramdef>
 				  </funcprototype>
 				  <funcprototype>
 					<funcdef>double precision <function>ST_Value</function></funcdef>
 					<paramdef><type>raster </type> <parameter>rast</parameter></paramdef>
-					<paramdef><type>integer </type> <parameter>bandnum</parameter></paramdef>
-					<paramdef><type>integer </type> <parameter>columnx</parameter></paramdef>
-					<paramdef><type>integer </type> <parameter>rowy</parameter></paramdef>
+					<paramdef><type>integer </type> <parameter>band</parameter></paramdef>
+					<paramdef><type>integer </type> <parameter>x</parameter></paramdef>
+					<paramdef><type>integer </type> <parameter>y</parameter></paramdef>
 					<paramdef choice="opt"><type>boolean </type> <parameter>exclude_nodata_value=true</parameter></paramdef>
 				  </funcprototype>
 				</funcsynopsis>
@@ -6423,12 +6423,17 @@ SELECT ST_PixelWidth(ST_Rescale(ST_AddBand(ST_MakeEmptyRaster(100, 100, 0, 0, 0.
 					<title>Examples</title>
 					<para>A simple example reskewing a raster from a skew of 0.0 to a skew of 0.0015.</para>
 					
-					<programlisting>-- the original raster pixel size
-SELECT ST_Rotation(ST_AddBand(ST_MakeEmptyRaster(100, 100, 0, 0, 0.001, -0.001, 0, 0, 4269), '8BUI'::text, 1, 0))
+					<programlisting>-- the original raster non-rotated
+SELECT ST_Rotation(ST_AddBand(ST_MakeEmptyRaster(100, 100, 0, 0, 0.001, -0.001, 0, 0, 4269), '8BUI'::text, 1, 0));
+
+-- result
+0
 					
--- the rescaled raster raster pixel size
-SELECT ST_Rotation(ST_Reskew(ST_AddBand(ST_MakeEmptyRaster(100, 100, 0, 0, 0.001, -0.001, 0, 0, 4269), '8BUI'::text, 1, 0), 0.0015))
-                    </programlisting>
+-- the reskewed raster raster rotation
+SELECT ST_Rotation(ST_Reskew(ST_AddBand(ST_MakeEmptyRaster(100, 100, 0, 0, 0.001, -0.001, 0, 0, 4269), '8BUI'::text, 1, 0), 0.0015));
+
+-- result
+-0.982793723247329</programlisting>
 					
 			</refsection>
 
@@ -6506,12 +6511,16 @@ SELECT ST_Rotation(ST_Reskew(ST_AddBand(ST_MakeEmptyRaster(100, 100, 0, 0, 0.001
 					<title>Examples</title>
 					<para>A simple example snapping a raster to a slightly different grid.</para>
 					
-					<programlisting>-- the original raster pixel size
-SELECT ST_UpperLeftX(ST_AddBand(ST_MakeEmptyRaster(10, 10, 0, 0, 0.001, -0.001, 0, 0, 4269), '8BUI'::text, 1, 0))
+					<programlisting>-- the original raster upper left X
+SELECT ST_UpperLeftX(ST_AddBand(ST_MakeEmptyRaster(10, 10, 0, 0, 0.001, -0.001, 0, 0, 4269), '8BUI'::text, 1, 0));
+-- result
+0
 					
--- the rescaled raster raster pixel size
-SELECT ST_UpperLeftX(ST_SnapToGrid(ST_AddBand(ST_MakeEmptyRaster(10, 10, 0, 0, 0.001, -0.001, 0, 0, 4269), '8BUI'::text, 1, 0), 0.0002, 0.0002))
-                    </programlisting>
+-- the upper left of raster after snapping
+SELECT ST_UpperLeftX(ST_SnapToGrid(ST_AddBand(ST_MakeEmptyRaster(10, 10, 0, 0, 0.001, -0.001, 0, 0, 4269), '8BUI'::text, 1, 0), 0.0002, 0.0002));
+
+--result
+-0.0008</programlisting>
 					
 			</refsection>
 
@@ -8242,7 +8251,7 @@ SELECT ST_AsJPEG(rast,ARRAY[2,1,3],ARRAY['QUALITY=90','PROGRESSIVE=ON']) As rast
                     </listitem>
                     <listitem>
                       <para>
-                        <varname>nbands</varname> is an array of bands to export (note that max is 3 for PNG) and the order of the bands is RGB. e.g ARRAY[3,2,1] means map band 3 to Red, band 2 to green and band 1 to blue
+                        <varname>nbands</varname> is an array of bands to export (note that max is 4 for PNG) and the order of the bands is RGBA. e.g ARRAY[3,2,1] means map band 3 to Red, band 2 to green and band 1 to blue
                       </para>
                     </listitem>
                    <listitem>
@@ -10776,7 +10785,7 @@ WHERE rid=167;
 					<para>Passing a <type>regprodedure</type> argument to a SQL function requires the full function signature to be passed, then cast to a <type>regprocedure</type> type. To pass the above example PL/pgSQL function as an argument, the SQL for the argument is:<programlisting>'simple_function(double precision, double precision, integer[], text[])'::regprocedure</programlisting>Note that the argument contains the name of the function, the types of the function arguments, quotes around the name and argument types, and a cast to a <type>regprocedure</type>.
 					</para>
 
-					<para>The third argument to the <varname>tworastuserfunc</varname> is a <type>variadic text</type> array. All trailing text arguments to any <xref linkend="RT_ST_MapAlgebraFct2" /> call are passed through to the specified <varname>tworastuserfunc</varname>, and are contained in the <varname>userargs</varname> argument.
+					<para>The fourth argument to the <varname>tworastuserfunc</varname> is a <type>variadic text</type> array. All trailing text arguments to any <xref linkend="RT_ST_MapAlgebraFct2" /> call are passed through to the specified <varname>tworastuserfunc</varname>, and are contained in the <varname>userargs</varname> argument.
 					</para>
 
 					<note>
@@ -13177,8 +13186,7 @@ MULTIPOLYGON(((3427928 5793243.85,3427928 5793243.8,3427928 5793243.75,3427927.8
 			overlaps or is to the left of the bounding box of raster B, or more accurately, overlaps or is NOT to the right
 			of the bounding box of raster B.</para>
 
-			<note><para>This operand will make use of any indexes that may be available on the
-				geometries.</para></note>
+			<note><para>This operand will make use of any indexes that may be available on the rasters.</para></note>
 		  </refsection>
 
 		  <refsection>
diff --git a/doc/release_notes.xml b/doc/release_notes.xml
index ae7cfdc..42ea07a 100644
--- a/doc/release_notes.xml
+++ b/doc/release_notes.xml
@@ -2,20 +2,85 @@
 <appendix id="release_notes">
   <title>Appendix</title>
     <subtitle>Release Notes</subtitle>
+    <sect1>
+      <title>Release 2.2.5</title>
+        <para>Release date: 2017/01/30</para>
+        <para>This is a bug fix and performance improvement release.</para>
+        <simplesect>
+            <title>Bug Fixes and Enhancements</title>
+            <para>3418, KNN recheck in 9.5+ fails with index returned tuples in wrong order</para>
+            <para>3680, PostGIS upgrade scripts missing GRANT for views</para>
+        </simplesect>
+    </sect1>
+    <sect1>
+      <title>Release 2.2.4</title>
+        <para>Release date: 2016/11/26</para>
+        <para>This is a bug fix and performance improvement release.</para>
+        <simplesect>
+            <title>Bug Fixes and Enhancements</title>
+            <para>1973, st_concavehull() returns sometimes empty geometry collection
+                            Fix from gde</para>
+            <para>3656, Fix upgrade of aggregates from 2.2 or lower version</para>
+            <para>3501, add raster constraint max extent exceeds array size limit
+                        for large tables, change to use ST_Extent</para>
+            <para>3659, Crash caused by raster GUC define after CREATE EXTENSION
+                 using wrong memory context. (manaeem)</para>
+        </simplesect>
+    </sect1>
+    <sect1>
+      <title>Release 2.2.3</title>
+        <para>Release date: 2016/10/06</para>
+        <para>This is a bug fix and performance improvement release.</para>
+        <simplesect>
+            <title>Bug Fixes and Enhancements</title>
+            <para>3615, Fix schema support in RT_CreateOveriew (Cait Smith)</para>
+            <para>3628, Fix lack of support for capitalized-Y in SwapOrdinates</para>
+            <para>3524, Add interruptibility to geography brute-force distance 
+                       calculation</para>
+            <para>3522, Handle POINT and MULTIPOINT correctly in ST_Subdivide</para>
+            <para>3565, ST_SetPoint can crash backend</para>
+            <para>3571, Install desktop file and application icons 
+                       for shp2pgsql-gui (Sebastiaan Couwenberg)</para>
+            <para>3573, Operator &lt;&lt;-&gt;&gt; incorrectly calculates m distance</para>
+            <para>3579, Crash in LWGEOM2GEOS</para>
+            <para>3515, tiger_data not being backed up</para>
+            <para>3569, Incorrect coordinates returned by ST_CollectionHomogenize
+                       (Dan Baston)</para>
+            <para>3602, perl as found by configure is not used 
+                       in tiger extension, postgis_sfcgal, address_standardizer</para>
+            <para>3604, pgcommon/Makefile.in orders CFLAGS leads to installed liblwgeom.h
+                      (Greg Troxel)</para>
+            <para>3607, Fix inconsistency with multilinestring in
+                       ST_LocateBetweenElevations (Artur Zakirov)</para>
+            <para>3608, Fix crash passing -W UTF-8 to shp2pgsql (Matt Amos)</para>
+            <para>3624, [raster] load_outdb related tests fail 
+                       for 2.2.2 &amp; 2.3.0-beta1 on Debian unstable
+                       perl @INC fix (Sebastiaan Couwenberg)</para>
+            <para>3627, Encoded polyline functions ignore precision parameter
+                       (Christian Quest / Dan Baston)</para>
+            <para>3501, use ST_Union instead of ST_Collect to compute 
+                      raster max extent constraint</para>
+            <para>3640, Interpolate_from_address sometimes results in "" invalid for numeric</para>
+            <para>3641, Tiger normalize, pagc_normalize integer out of range</para>
+            <para>3644, Deadlock on interrupt</para>
+            <para>3542, Crash on Geometry(MultiCurve())</para>
+            <para>Numerous documentation corrections from ruvyn</para>
+        </simplesect>
+    </sect1>
 
     <sect1>
       <title>Release 2.2.2</title>
         <para>Release date: 2016/03/22</para>
         <para>This is a bug fix and performance improvement release.</para>
   		  <simplesect>
-  			  <title>New Features</title>
+  			  <title>Bug Fixes and Enhancments</title>
           <para>#3463, Fix crash on face-collapsing edge change</para>
           <para>#3422, Improve ST_Split robustness on standard precision double systems (arm64, ppc64el, s390c, powerpc, ...)</para>
           <para>#3427, Update spatial_ref_sys to EPSG version 8.8</para>
           <para>#3433, ST_ClusterIntersecting incorrect for MultiPoints</para>
           <para>#3435, ST_AsX3D fix rendering of concave geometries</para>
           <para>#3436, memory handling mistake in ptarray_clone_deep</para>
-          <para>#3437, ST_ClusterIntersecting incorrect for MultiPoints</para>
+          <para>#3437, ST_Intersects incorrect for MultiPoints</para>
           <para>#3461, ST_GeomFromKML crashes Postgres when there are innerBoundaryIs and no outerBoundaryIs</para>
           <para>#3429, upgrading to 2.3 or from 2.1 can cause loop/hang on some platforms</para>
           <para>#3460, ST_ClusterWithin 'Tolerance not defined' error after upgrade</para>
@@ -147,7 +212,7 @@
         <title>Bug Fixes</title>
         <para>#3159, do not force a bbox cache on ST_Affine</para>
         <para>#3018, GROUP BY geography sometimes returns duplicate rows</para>
-        <para>#3048, shp2pgsql - illegal number format when specific system locale set</para>
+        <para>#3084, shp2pgsql - illegal number format when specific system locale set</para>
         <para>#3094, Malformed GeoJSON inputs crash backend</para>
         <para>#3104, st_asgml introduces random characters in ID field</para>
         <para>#3155, Remove liblwgeom.h on make uninstall</para>
@@ -176,7 +241,7 @@
         <title>Enhancements</title>
         <para>#3000, Ensure edge splitting and healing algorithms use indexes</para>
         <para>#3048, Speed up geometry simplification (J.Santana @ CartoDB)</para>
-        <para>#3050, Speep up geometry type reading (J.Santana @ CartoDB)</para>
+        <para>#3050, Speed up geometry type reading (J.Santana @ CartoDB)</para>
       </simplesect>
       <simplesect>
         <title>Bug Fixes</title>
diff --git a/extensions/address_standardizer/Makefile.in b/extensions/address_standardizer/Makefile.in
index 8d5a41a..22b23a6 100644
--- a/extensions/address_standardizer/Makefile.in
+++ b/extensions/address_standardizer/Makefile.in
@@ -170,4 +170,4 @@ EXTRA_CLEAN += sql/$(EXTENSION)--$(EXTVERSION).sql sql/$(EXTENSION)--unpackaged-
 
 PGXS := @PGXS@
 include $(PGXS)
-
+PERL = @PERL@
diff --git a/extensions/postgis/Makefile.in b/extensions/postgis/Makefile.in
index c6656c1..fa9009f 100644
--- a/extensions/postgis/Makefile.in
+++ b/extensions/postgis/Makefile.in
@@ -74,7 +74,7 @@ sql_bits/rtpostgis.sql: ../../raster/rt_pg/rtpostgis.sql
 	sed -e 's/BEGIN;//g' -e 's/COMMIT;//g'  $< > $@
 
 sql_bits/spatial_ref_sys_config_dump.sql: ../../spatial_ref_sys.sql ../../utils/create_spatial_ref_sys_config_dump.pl
-	../../utils/create_spatial_ref_sys_config_dump.pl $< > $@
+	$(PERL) ../../utils/create_spatial_ref_sys_config_dump.pl $< > $@
 
 # we need to also drop this temporary function from the extension
 # for casts that are being dropped we need to drop them 
diff --git a/extensions/postgis_sfcgal/Makefile.in b/extensions/postgis_sfcgal/Makefile.in
index 1760305..888cfe2 100644
--- a/extensions/postgis_sfcgal/Makefile.in
+++ b/extensions/postgis_sfcgal/Makefile.in
@@ -87,3 +87,4 @@ distclean: clean
 
 PGXS := $(shell $(PG_CONFIG) --pgxs)
 include $(PGXS)
+PERL = @PERL@
diff --git a/extensions/postgis_tiger_geocoder/Makefile.in b/extensions/postgis_tiger_geocoder/Makefile.in
index 46d8345..030287c 100644
--- a/extensions/postgis_tiger_geocoder/Makefile.in
+++ b/extensions/postgis_tiger_geocoder/Makefile.in
@@ -4,22 +4,26 @@ EXTENSION    = postgis_tiger_geocoder
 EXTVERSION    = @POSTGIS_LIB_VERSION@
 MINORVERSION  = 2011.@POSTGIS_MAJOR_VERSION@.@POSTGIS_MINOR_VERSION@
 GREP = @GREP@
+PERL = @PERL@
+
+MICRO_NUMBER  = $(shell echo $(EXTVERSION) | \
+						$(PERL) -pe 's/\d.\d.(\d+)[a-zA-Z]*\d*/$1/'
 
-MICRO_NUMBER  = $(shell echo $(EXTVERSION) | sed "s/[0-9]\.[0-9]\.\([0-9]*\)[a-zA-Z]*[0-9]*/\1/")
 PREREL_NUMBER = $(shell echo $(EXTVERSION) | \
-                        sed "s/[0-9]\.[0-9]\.\(.*\)/\1/" | \
+                        $(PERL) -pe 's/\d\.\d\.(.*)/\1/' | \
                         $(GREP) "[a-zA-Z]" | \
-                        sed "s/[0-9][a-zA-Z]\([0-9]*\)[a-zA-Z]*/\1/")
+                        $(PERL) -pe 's/\d+[a-zA-Z]+(\d+)/\1/'
+
 MICRO_PREV    = $(shell if test "$(MICRO_NUMBER)x" != "x"; then expr $(MICRO_NUMBER) - 1; fi)
 PREREL_PREV   = $(shell if test "$(PREREL_NUMBER)x" != "x"; then expr $(PREREL_NUMBER) - 1; fi)
 
 PREREL_PREFIX = $(shell echo $(EXTVERSION) | \
-                        sed "s/[0-9]\.[0-9]\.\(.*\)/\1/" | \
+                        $(PERL) -pe 's/\d\.\d\.(.*)/\1/' | \
                         $(GREP) "[a-zA-Z]" | \
-                        sed "s/\([0-9][a-zA-Z]*\)[0-9]*/\1/")
+                        $(PERL) -pe 's/(\d+[a-zA-Z]+)\d*/\1/'
 
 DATA         = $(filter-out $(wildcard sql/*--*.sql),$(wildcard sql/*.sql))
-REGRESS = test-normalize_address
+REGRESS = test-normalize_address test-upgrade
 REGRESS_OPTS = --load-extension=fuzzystrmatch --load-extension=postgis --load-extension=$(EXTENSION)
 
 PG_CONFIG    =  @PG_CONFIG@
@@ -35,7 +39,7 @@ ifeq (@ADDRESS_STANDARDIZER@,address_standardizer)
 endif
 
 ifeq ($(PG91),yes)
-all: sql/$(EXTENSION)--$(EXTVERSION).sql sql/$(EXTENSION)--unpackaged--$(EXTVERSION).sql sql/$(EXTENSION)--$(EXTVERSION)--$(EXTVERSION)next.sql sql/$(EXTENSION)--$(EXTVERSION)next--$(EXTVERSION).sql  sql_minor_upgrade sql/test-normalize_address.sql  sql/test-pagc_normalize_address.sql expected/test-normalize_address.out expected/test-pagc_normalize_address.out sql/$(EXTENSION)--$(EXTVERSION)next--$(EXTVERSION).sql  sql_minor_upgrade
+all: sql/$(EXTENSION)--$(EXTVERSION).sql sql/$(EXTENSION)--unpackaged--$(EXTVERSION).sql sql/$(EXTENSION)--$(EXTVERSION)--$(EXTVERSION)next.sql sql/$(EXTENSION)--$(EXTVERSION)next--$(EXTVERSION).sql  sql_minor_upgrade sql/test-normalize_address.sql  sql/test-pagc_normalize_address.sql expected/test-normalize_address.out expected/test-pagc_normalize_address.out sql/test-upgrade.sql expected/test-upgrade.out sql/$(EXTENSION)--$(EXTVERSION)next--$(EXTVERSION).sql  sql_minor_upgrade
 
 sql/$(EXTENSION)--$(EXTVERSION).sql: sql/$(EXTENSION).sql
 	mkdir -p sql
@@ -54,6 +58,13 @@ sql/test-normalize_address.sql: sql_bits/test_tuples_only_unaligned.sql.in ../..
 	mkdir -p sql
 	cat $^ > $@
 	
+sql/test-upgrade.sql: 
+	mkdir -p sql
+	echo 'ALTER EXTENSION ${EXTENSION} UPDATE TO "$(EXTVERSION)next"' > $@
+	
+expected/test-upgrade.out: sql/test-upgrade.sql
+	cp $< $@
+	
 sql/test-pagc_normalize_address.sql: sql_bits/test_tuples_only_unaligned.sql.in ../../extras/tiger_geocoder/regress/pagc_normalize_address_regress.sql
 	mkdir -p sql
 	cat $^ > $@
@@ -63,9 +74,13 @@ sql/$(EXTENSION).sql: sql_bits/tiger_geocoder.sql  sql_bits/mark_editable_object
 	cat $^ > $@
 	
 #this is a cludge to allow upgrading from same SVN to same SVN
-sql/$(EXTENSION)--$(EXTVERSION)--$(EXTVERSION)next.sql: ../postgis_extension_helper.sql sql_bits/remove_from_extension.sql.in sql/tiger_geocoder_upgrade_minor.sql sql_bits/mark_editable_objects.sql.in sql_bits/tiger_geocoder_comments.sql ../postgis_extension_helper_uninstall.sql
+sql/$(EXTENSION)--$(EXTVERSION)--$(EXTVERSION)next.sql: ../postgis_extension_helper.sql sql_bits/remove_from_extension.sql.in sql/tiger_geocoder_upgrade_minor.sql sql_bits/mark_editable_objects.sql.in sql_bits/tiger_geocoder_comments.sql
 	mkdir -p sql
 	cat $^ > $@
+	echo "SELECT postgis_extension_drop_if_exists('${EXTENSION}', 'DROP SCHEMA tiger_data');" >> $@
+	cat ../postgis_extension_helper_uninstall.sql  >> $@
+	
+	
 
 
 sql/$(EXTENSION)--$(EXTVERSION)next--$(EXTVERSION).sql: sql/$(EXTENSION)--$(EXTVERSION)--$(EXTVERSION)next.sql
@@ -75,6 +90,7 @@ sql/$(EXTENSION)--$(EXTVERSION)next--$(EXTVERSION).sql: sql/$(EXTENSION)--$(EXTV
 #strip BEGIN/COMMIT since these are not allowed in extensions
 #strip CREATE SCHEMA since we force extension 
 # to create schema by setting schema to tiger_geocoder in control
+#also remove tiger_data from extension if it is part of it
 sql_bits/tiger_geocoder_minor.sql.in: ../../extras/tiger_geocoder/utility/set_search_path.sql \
   	../../extras/tiger_geocoder/geocode_settings.sql \
   ../../extras/tiger_geocoder/tiger_loader_2015.sql \
@@ -107,6 +123,7 @@ sql_bits/tiger_geocoder_minor.sql.in: ../../extras/tiger_geocoder/utility/set_se
 	../../extras/tiger_geocoder/geocode/census_tracts_functions.sql
 	cat $^ > $@
 	
+#also remove tiger_data from extension if it is part of it so data gets backed up
 sql_bits/tiger_geocoder.sql.in: sql_bits/norm_addy_create.sql.in \
 	../../extras/tiger_geocoder/utility/set_search_path.sql \
 	../../extras/tiger_geocoder/geocode_settings.sql \
@@ -142,12 +159,14 @@ sql_bits/tiger_geocoder.sql.in: sql_bits/norm_addy_create.sql.in \
 	../../extras/tiger_geocoder/geocode/census_tracts_functions.sql \
 	../../extras/tiger_geocoder/topology/tiger_topology_loader.sql \
 	../postgis_extension_helper.sql \
-	sql_bits/add_search_path.sql \
-	../postgis_extension_helper_uninstall.sql 
+	sql_bits/add_search_path.sql
 	cat $^ > $@
+	echo "SELECT postgis_extension_drop_if_exists('${EXTENSION}', 'DROP SCHEMA tiger_data');" >> $@
+	cat ../postgis_extension_helper_uninstall.sql  >> $@
 	
 sql_bits/tiger_geocoder.sql: sql_bits/tiger_geocoder.sql.in
 	sed -e 's/BEGIN;//g' -e 's/COMMIT;//g' -e '/^CREATE SCHEMA/d;'  $< > $@
+	$(PERL) -pe 's/BEGIN\;//g ; s/COMMIT\;//g' $< > $@
 	
 sql_bits/add_search_path.sql: sql_bits/add_search_path.sql.in
 	cp $< $@
@@ -193,7 +212,7 @@ sql/tiger_geocoder_upgrade_minor.sql:  sql_bits/tiger_geocoder_minor.sql.in
 	 	 -e 's/BEGIN;//g' -e 's/COMMIT;//g' \
 	 	 $< > $@
 	 	 	
-sql_minor_upgrade: ../postgis_extension_helper.sql sql_bits/remove_from_extension.sql.in sql/tiger_geocoder_upgrade_minor.sql sql_bits/mark_editable_objects.sql.in sql_bits/tiger_geocoder_comments.sql ../postgis_extension_helper_uninstall.sql
+sql_minor_upgrade: sql/$(EXTENSION)--$(EXTVERSION)--$(EXTVERSION)next.sql
 	for OLD_VERSION in $(UPGRADEABLE_VERSIONS); do \
   	  cat $^ > sql/$(EXTENSION)--$$OLD_VERSION--$(EXTVERSION).sql; \
 	done
@@ -209,3 +228,4 @@ distclean: clean
 
 PGXS := $(shell $(PG_CONFIG) --pgxs)
 include $(PGXS)
+PERL=@PERL@
diff --git a/extensions/upgradeable_versions.mk b/extensions/upgradeable_versions.mk
index 4380688..9bd45f1 100644
--- a/extensions/upgradeable_versions.mk
+++ b/extensions/upgradeable_versions.mk
@@ -19,4 +19,7 @@ UPGRADEABLE_VERSIONS = \
   2.1.9 \
   2.2.0 \
   2.2.1 \
-  2.2.2
+  2.2.2 \
+  2.2.3 \
+  2.2.4 \
+  2.2.5
diff --git a/extras/tiger_geocoder/geocode/geocode.sql b/extras/tiger_geocoder/geocode/geocode.sql
index 9279fe7..dee1163 100644
--- a/extras/tiger_geocoder/geocode/geocode.sql
+++ b/extras/tiger_geocoder/geocode/geocode.sql
@@ -74,7 +74,7 @@ BEGIN
               )
             *
            FROM
-             geocode_address(IN_ADDY, max_results, restrict_geom) a
+             tiger.geocode_address(IN_ADDY, max_results, restrict_geom) a
            ORDER BY
               (a.addy).address,
               (a.addy).predirabbrev,
@@ -109,7 +109,7 @@ BEGIN
 
   -- No zip code, try state/location, need both or we'll get too much stuffs.
   IF IN_ADDY.zip IS NOT NULL OR (IN_ADDY.stateAbbrev IS NOT NULL AND IN_ADDY.location IS NOT NULL) THEN
-    FOR rec in SELECT * FROM geocode_location(IN_ADDY, restrict_geom) As b ORDER BY b.rating LIMIT max_results
+    FOR rec in SELECT * FROM tiger.geocode_location(IN_ADDY, restrict_geom) As b ORDER BY b.rating LIMIT max_results
     LOOP
       ADDY := rec.addy;
       GEOMOUT := rec.geomout;
diff --git a/extras/tiger_geocoder/geocode/geocode_address.sql b/extras/tiger_geocoder/geocode/geocode_address.sql
index 55af747..36ab6d7 100644
--- a/extras/tiger_geocoder/geocode/geocode_address.sql
+++ b/extras/tiger_geocoder/geocode/geocode_address.sql
@@ -40,7 +40,7 @@ BEGIN
   			var_restrict_geom = ST_SnapToGrid(ST_Transform(restrict_geom, 4269), 0.000001);
   		END IF;
   END IF;
-  var_bfilter := ' SELECT zcta5ce FROM zcta5 AS zc  
+  var_bfilter := ' SELECT zcta5ce FROM tiger.zcta5 AS zc  
                     WHERE zc.statefp = ' || quote_nullable(in_statefp) || ' 
                         AND ST_Intersects(zc.the_geom, ' || quote_literal(var_restrict_geom::text) || '::geometry)  ' ;
 
@@ -57,7 +57,7 @@ BEGIN
     --This signals bad zip input, only use the range if it falls in the place zip range
     IF length(parsed.zip) != 5 AND parsed.location IS NOT NULL THEN 
          stmt := 'SELECT ARRAY(SELECT DISTINCT zip
-          FROM zip_lookup_base AS z
+          FROM tiger.zip_lookup_base AS z
          WHERE z.statefp = $1
                AND  z.zip = ANY($3) AND lower(z.city) LIKE lower($2) || ''%''::text '  || COALESCE(' AND z.zip IN(' || var_bfilter || ')', '') || ')::varchar[] AS zip ORDER BY zip' ;
          EXECUTE stmt INTO zip_info USING in_statefp, parsed.location, zip_info.zip;
@@ -77,7 +77,7 @@ BEGIN
   -- If no good zips just include all for the location
   -- We do a like instead of absolute check since tiger sometimes tacks things like Town at end of places
     stmt := 'SELECT ARRAY(SELECT DISTINCT zip
-          FROM zip_lookup_base AS z
+          FROM tiger.zip_lookup_base AS z
          WHERE z.statefp = $1
                AND  lower(z.city) LIKE lower($2) || ''%''::text '  || COALESCE(' AND z.zip IN(' || var_bfilter || ')', '') || ')::varchar[] AS zip ORDER BY zip' ;
     EXECUTE stmt INTO zip_info USING in_statefp, parsed.location;
@@ -103,7 +103,7 @@ BEGIN
          || '    sufdirabrv, prequalabr)  
 							)
 						As rank
-                		FROM featnames As f INNER JOIN addr As ad ON (f.tlid = ad.tlid) 
+                		FROM tiger.featnames As f INNER JOIN tiger.addr As ad ON (f.tlid = ad.tlid) 
                     WHERE $10 = f.statefp AND $10 = ad.statefp 
                     	'
                     || CASE WHEN length(parsed.streetName) > 5  THEN ' AND (lower(f.fullname) LIKE (COALESCE($5 || '' '','''') || lower($2) || ''%'')::text OR lower(f.name) = lower($2) OR soundex(f.name) = soundex($2) ) ' ELSE  ' AND lower(f.name) = lower($2) ' END 
@@ -160,10 +160,10 @@ BEGIN
                 a.zip,
                 p.name as place
 
-                FROM  a INNER JOIN edges As b ON (a.statefp = b.statefp AND a.tlid = b.tlid  '
+                FROM  a INNER JOIN tiger.edges As b ON (a.statefp = b.statefp AND a.tlid = b.tlid  '
                || ')
-                    INNER JOIN faces AS f ON ($10 = f.statefp AND ( (b.tfidl = f.tfid AND a.side = ''L'') OR (b.tfidr = f.tfid AND a.side = ''R'' ) )) 
-                    INNER JOIN place p ON ($10 = p.statefp AND f.placefp = p.placefp ' 
+                    INNER JOIN tiger.faces AS f ON ($10 = f.statefp AND ( (b.tfidl = f.tfid AND a.side = ''L'') OR (b.tfidr = f.tfid AND a.side = ''R'' ) )) 
+                    INNER JOIN tiger.place p ON ($10 = p.statefp AND f.placefp = p.placefp ' 
           || CASE WHEN parsed.location > '' AND zip_info.zip IS NULL THEN ' AND ( lower(p.name) LIKE (lower($3::text) || ''%'')  ) ' ELSE '' END          
           || ')
                 WHERE a.statefp = $10  AND  b.statefp = $10   '
@@ -174,7 +174,7 @@ BEGIN
            ORDER BY 10 ,  11 DESC 
            LIMIT 20 
             ) AS sub 
-          JOIN state s ON ($10 = s.statefp) 
+          JOIN tiger.state s ON ($10 = s.statefp) 
             ORDER BY 1,2,3,4,5,6,7,9 
           LIMIT 20) As foo ORDER BY sub_rating, exact_address DESC LIMIT  ' || max_results*10 ;
          
@@ -347,7 +347,7 @@ BEGIN
          || '            AND $1::integer <= greatest_hn(b.fromhn,b.tohn) '
          || '            AND ($1 % 2)::numeric::integer = (to_number(b.fromhn,''99999999'') % 2)'
          || '    as exact_address, a.name, a.prequalabr, a.pretypabrv '
-         || '  FROM featnames a join addr b ON (a.tlid = b.tlid AND a.statefp = b.statefp  )'
+         || '  FROM tiger.featnames a join tiger.addr b ON (a.tlid = b.tlid AND a.statefp = b.statefp  )'
          || '  WHERE'
          || '        a.statefp = ' || quote_literal(zip_info.statefp) || ' AND a.mtfcc LIKE ''S%''  '
          || coalesce('    AND b.zip IN (''' || array_to_string(zip_info.zip,''',''') || ''') ','')
@@ -358,14 +358,14 @@ BEGIN
          || '  ORDER BY 11'
          || '  LIMIT 20'
          || '    ) AS sub'
-         || '  JOIN edges e ON (' || quote_literal(zip_info.statefp) || ' = e.statefp AND sub.tlid = e.tlid AND e.mtfcc LIKE ''S%'' ' 
+         || '  JOIN tiger.edges e ON (' || quote_literal(zip_info.statefp) || ' = e.statefp AND sub.tlid = e.tlid AND e.mtfcc LIKE ''S%'' ' 
          ||   CASE WHEN var_restrict_geom IS NOT NULL THEN ' AND ST_Intersects(e.the_geom, $8) '  ELSE '' END || ') '
-         || '  JOIN state s ON (' || quote_literal(zip_info.statefp) || ' = s.statefp)'
-         || '  JOIN faces f ON (' || quote_literal(zip_info.statefp) || ' = f.statefp AND (e.tfidl = f.tfid OR e.tfidr = f.tfid))'
-         || '  LEFT JOIN zip_lookup_base zip ON (sub.zip = zip.zip AND zip.statefp=' || quote_literal(zip_info.statefp) || ')'
-         || '  LEFT JOIN place p ON (' || quote_literal(zip_info.statefp) || ' = p.statefp AND f.placefp = p.placefp)'
-         || '  LEFT JOIN county co ON (' || quote_literal(zip_info.statefp) || ' = co.statefp AND f.countyfp = co.countyfp)'
-         || '  LEFT JOIN cousub cs ON (' || quote_literal(zip_info.statefp) || ' = cs.statefp AND cs.cosbidfp = sub.statefp || co.countyfp || f.cousubfp)'
+         || '  JOIN tiger.state s ON (' || quote_literal(zip_info.statefp) || ' = s.statefp)'
+         || '  JOIN tiger.faces f ON (' || quote_literal(zip_info.statefp) || ' = f.statefp AND (e.tfidl = f.tfid OR e.tfidr = f.tfid))'
+         || '  LEFT JOIN tiger.zip_lookup_base zip ON (sub.zip = zip.zip AND zip.statefp=' || quote_literal(zip_info.statefp) || ')'
+         || '  LEFT JOIN tiger.place p ON (' || quote_literal(zip_info.statefp) || ' = p.statefp AND f.placefp = p.placefp)'
+         || '  LEFT JOIN tiger.county co ON (' || quote_literal(zip_info.statefp) || ' = co.statefp AND f.countyfp = co.countyfp)'
+         || '  LEFT JOIN tiger.cousub cs ON (' || quote_literal(zip_info.statefp) || ' = cs.statefp AND cs.cosbidfp = sub.statefp || co.countyfp || f.cousubfp)'
          || ' WHERE'
          || '  ( (sub.side = ''L'' and e.tfidl = f.tfid) OR (sub.side = ''R'' and e.tfidr = f.tfid) ) '
          || ' ORDER BY 1,2,3,4,5,6,7,9'
@@ -392,7 +392,7 @@ BEGIN
       END IF;
 
       IF results.exact_address THEN
-        ADDY.address := parsed.address;
+        ADDY.address := substring(parsed.address::text FROM '[0-9]+')::integer;
       ELSE
         ADDY.address := NULL;
       END IF;
diff --git a/extras/tiger_geocoder/geocode/geocode_intersection.sql b/extras/tiger_geocoder/geocode/geocode_intersection.sql
index a716566..2df1d9a 100644
--- a/extras/tiger_geocoder/geocode/geocode_intersection.sql
+++ b/extras/tiger_geocoder/geocode/geocode_intersection.sql
@@ -1,6 +1,6 @@
  /*** 
  * 
- * Copyright (C) 2011 Regina Obe and Leo Hsu (Paragon Corporation)
+ * Copyright (C) 2011-2016 Regina Obe and Leo Hsu (Paragon Corporation)
  **/
 -- This function given two roadways, state and optional city, zip
 -- Will return addresses that are at the intersecton of those roadways
@@ -8,10 +8,17 @@
 -- Use case example an address at the intersection of 2 streets: 
 -- SELECT pprint_addy(addy), st_astext(geomout),rating FROM geocode_intersection('School St', 'Washington St', 'MA', 'Boston','02117');
 --DROP FUNCTION tiger.geocode_intersection(text,text,text,text,text,integer);
-CREATE OR REPLACE FUNCTION geocode_intersection(IN roadway1 text, IN roadway2 text, IN in_state text, IN in_city text DEFAULT '', IN in_zip text DEFAULT '', 
-IN num_results integer DEFAULT 10,  OUT ADDY NORM_ADDY,
-    OUT GEOMOUT GEOMETRY,
-    OUT RATING INTEGER) RETURNS SETOF record AS
+CREATE OR REPLACE FUNCTION geocode_intersection(
+    IN roadway1 text,
+    IN roadway2 text,
+    IN in_state text,
+    IN in_city text DEFAULT ''::text,
+    IN in_zip text DEFAULT ''::text,
+    IN num_results integer DEFAULT 10,
+    OUT addy norm_addy,
+    OUT geomout geometry,
+    OUT rating integer)
+  RETURNS SETOF record AS
 $$
 DECLARE
     var_na_road norm_addy;
@@ -48,19 +55,19 @@ BEGIN
     var_sql := '
     WITH 
     	a1 AS (SELECT f.*, addr.fromhn, addr.tohn, addr.side , addr.zip
-    				FROM (SELECT * FROM featnames 
+    				FROM (SELECT * FROM tiger.featnames 
     							WHERE statefp = $1 AND ( lower(name) = $2  ' ||
     							CASE WHEN length(var_na_road.streetName) > 5 THEN ' or  lower(fullname) LIKE $6 || ''%'' ' ELSE '' END || ')' 
-    							|| ')  AS f LEFT JOIN (SELECT * FROM addr WHERE addr.statefp = $1) As addr ON (addr.tlid = f.tlid AND addr.statefp = f.statefp)
+    							|| ')  AS f LEFT JOIN (SELECT * FROM tiger.addr As addr WHERE addr.statefp = $1) As addr ON (addr.tlid = f.tlid AND addr.statefp = f.statefp)
     					WHERE $5::text[] IS NULL OR addr.zip = ANY($5::text[]) OR addr.zip IS NULL 
     				ORDER BY CASE WHEN lower(f.fullname) = $6 THEN 0 ELSE 1 END
     				LIMIT 50000
     			  ),
         a2 AS (SELECT f.*, addr.fromhn, addr.tohn, addr.side , addr.zip
-    				FROM (SELECT * FROM featnames 
+    				FROM (SELECT * FROM tiger.featnames 
     							WHERE statefp = $1 AND ( lower(name) = $4 ' || 
     							CASE WHEN length(var_na_inter1.streetName) > 5 THEN ' or lower(fullname) LIKE $7 || ''%'' ' ELSE '' END || ')' 
-    							|| ' )  AS f LEFT JOIN (SELECT * FROM addr WHERE addr.statefp = $1) AS addr ON (addr.tlid = f.tlid AND addr.statefp = f.statefp)
+    							|| ' )  AS f LEFT JOIN (SELECT * FROM tiger.addr As addr WHERE addr.statefp = $1) AS addr ON (addr.tlid = f.tlid AND addr.statefp = f.statefp)
     					WHERE $5::text[] IS NULL OR addr.zip = ANY($5::text[])  or addr.zip IS NULL 
     			ORDER BY CASE WHEN lower(f.fullname) = $7 THEN 0 ELSE 1 END
     				LIMIT 50000
@@ -68,14 +75,14 @@ BEGIN
     	 e1 AS (SELECT e.the_geom, e.tnidf, e.tnidt, a.*,
     	 			CASE WHEN a.side = ''L'' THEN e.tfidl ELSE e.tfidr END AS tfid
     	 			FROM a1 As a
-    					INNER JOIN  edges AS e ON (e.statefp = a.statefp AND a.tlid = e.tlid)
+    					INNER JOIN  tiger.edges AS e ON (e.statefp = a.statefp AND a.tlid = e.tlid)
     				WHERE e.statefp = $1 
     				ORDER BY CASE WHEN lower(a.name) = $4 THEN 0 ELSE 1 END + CASE WHEN lower(e.fullname) = $7 THEN 0 ELSE 1 END
     				LIMIT 5000) ,
     	e2 AS (SELECT e.the_geom, e.tnidf, e.tnidt, a.*,
     	 			CASE WHEN a.side = ''L'' THEN e.tfidl ELSE e.tfidr END AS tfid
-    				FROM (SELECT * FROM edges WHERE statefp = $1) AS e INNER JOIN a2 AS a ON (e.statefp = a.statefp AND a.tlid = e.tlid)
-    					INNER JOIN e1 ON (e.statefp = e1.statefp AND ST_Intersects(e.the_geom, e1.the_geom) 
+    				FROM (SELECT * FROM tiger.edges WHERE statefp = $1) AS e INNER JOIN a2 AS a ON (e.statefp = a.statefp AND a.tlid = e.tlid)
+    					INNER JOIN e1 ON (e.statefp = e1.statefp  
     					AND ARRAY[e.tnidf, e.tnidt] && ARRAY[e1.tnidf, e1.tnidt] )
     					
     				WHERE (lower(e.fullname) = $7 or lower(a.name) LIKE $4 || ''%'')
@@ -100,9 +107,9 @@ BEGIN
                                 AS a_rating  
                     FROM e1 
                             INNER JOIN e2 ON (
-                                    ST_Intersects(e1.the_geom, e2.the_geom)  ) 
-                             INNER JOIN (SELECT * FROM faces WHERE statefp = $1) As fa1 ON (e1.tfid = fa1.tfid  )
-                          LEFT JOIN place AS p ON (fa1.placefp = p.placefp AND p.statefp = $1 )
+                                  ARRAY[e2.tnidf, e2.tnidt] && ARRAY[e1.tnidf, e1.tnidt]  ) 
+                             INNER JOIN (SELECT * FROM tiger.faces WHERE statefp = $1) As fa1 ON (e1.tfid = fa1.tfid  )
+                          LEFT JOIN tiger.place AS p ON (fa1.placefp = p.placefp AND p.statefp = $1 )
                        ORDER BY e1.tlid, e1.side, a_rating LIMIT $9*4 )
     SELECT address, fedirp , fename, fetype,fedirs,place, zip , geom, a_rating 
         FROM segs ORDER BY a_rating LIMIT  $9';
@@ -133,7 +140,7 @@ BEGIN
         ADDY.stateAbbrev      := in_state;
         ADDY.zip              := results.zip;
         ADDY.parsed := TRUE;
-        ADDY.address := results.address;
+        ADDY.address := substring(results.address FROM '[0-9]+')::integer;
         
         GEOMOUT := results.geom;
         RATING := results.a_rating;
@@ -145,4 +152,4 @@ $$
   LANGUAGE plpgsql IMMUTABLE
   COST 1000
   ROWS 10;
-ALTER FUNCTION geocode_intersection(IN text, IN text, IN text, IN text, IN text, IN integer) SET join_collapse_limit='2';
+ALTER FUNCTION geocode_intersection(text, text, text, text, text, integer) SET join_collapse_limit='2';
diff --git a/extras/tiger_geocoder/geocode/interpolate_from_address.sql b/extras/tiger_geocoder/geocode/interpolate_from_address.sql
index c5c2f0a..899592c 100644
--- a/extras/tiger_geocoder/geocode/interpolate_from_address.sql
+++ b/extras/tiger_geocoder/geocode/interpolate_from_address.sql
@@ -7,7 +7,7 @@
 -- fifth are from the other.
 -- in_side Side of street -- either 'L', 'R' or if blank ignores side of road
 -- in_offset_m -- number of meters offset to the side
-CREATE OR REPLACE FUNCTION interpolate_from_address(given_address INTEGER, in_addr1 VARCHAR, in_addr2 VARCHAR, in_road GEOMETRY, 
+CREATE OR REPLACE FUNCTION interpolate_from_address(given_address INTEGER, in_addr1 VARCHAR, in_addr2 VARCHAR, in_road GEOMETRY,
 	in_side VARCHAR DEFAULT '',in_offset_m float DEFAULT 10) RETURNS GEOMETRY
 AS $_$
 DECLARE
@@ -24,9 +24,9 @@ BEGIN
     IF in_road IS NULL THEN
         RETURN NULL;
     END IF;
-    
-	var_addr1 := to_number(in_addr1, '999999');
-	var_addr2 := to_number(in_addr2, '999999');
+
+	var_addr1 := to_number( CASE WHEN in_addr1 ~ '^[0-9]+$' THEN in_addr1 ELSE '0' END, '999999');
+	var_addr2 := to_number( CASE WHEN in_addr2 ~ '^[0-9]+$' THEN in_addr2 ELSE '0' END, '999999');
 
     IF geometrytype(in_road) = 'LINESTRING' THEN
       road := ST_Transform(in_road, utmzone(ST_StartPoint(in_road)) );
@@ -54,18 +54,18 @@ BEGIN
     center_pt = ST_LineInterpolatePoint(road, part);
     IF in_side > '' AND in_offset_m > 0 THEN
     /** Compute point the point to the in_side of the geometry **/
-    /**Take into consideration non-straight so we consider azimuth 
-    	of the 2 points that straddle the center location**/ 
+    /**Take into consideration non-straight so we consider azimuth
+    	of the 2 points that straddle the center location**/
     	IF part = 0 THEN
     		az := ST_Azimuth (ST_StartPoint(road), ST_PointN(road,2));
     	ELSIF part = 1 THEN
     		az := ST_Azimuth (ST_PointN(road,ST_NPoints(road) - 1), ST_EndPoint(road));
-    	ELSE 
+    	ELSE
     		/** Find the largest nth point position that is before the center point
     			This will be the start of our azimuth calc **/
     		SELECT i INTO npos
-    			FROM generate_series(1,ST_NPoints(road)) As i 
-    					WHERE part > ST_LineLocatePoint(road,ST_PointN(road,i)) 
+    			FROM generate_series(1,ST_NPoints(road)) As i
+    					WHERE part > ST_LineLocatePoint(road,ST_PointN(road,i))
     					ORDER BY i DESC;
     		IF npos < ST_NPoints(road) THEN				
     			az := ST_Azimuth (ST_PointN(road,npos), ST_PointN(road, npos + 1));
@@ -92,7 +92,7 @@ BEGIN
     RETURN result;
 END;
 $_$ LANGUAGE plpgsql IMMUTABLE COST 10;
--- needed to ban stupid warning about how we are using deprecated functions 
+-- needed to ban stupid warning about how we are using deprecated functions
 -- yada yada yada need this to work in 2.0 too bah
 ALTER FUNCTION interpolate_from_address(integer, character varying, character varying, geometry, character varying, double precision)
   SET client_min_messages='ERROR';
diff --git a/extras/tiger_geocoder/geocode/reverse_geocode.sql b/extras/tiger_geocoder/geocode/reverse_geocode.sql
index adb3167..bd6844f 100644
--- a/extras/tiger_geocoder/geocode/reverse_geocode.sql
+++ b/extras/tiger_geocoder/geocode/reverse_geocode.sql
@@ -127,7 +127,7 @@ BEGIN
 		FROM 
 		  (SELECT e.tlid, e.the_geom As line, n.fullname, COALESCE(n.prequalabr || '' '','''')  || n.name AS streetname, n.predirabrv, COALESCE(suftypabrv, pretypabrv) As streettypeabbrev,
 		      n.sufdirabrv, e.zip, e.side, e.fromhn, e.tohn , e.center_pt,
-		          ST_Distance_Sphere(ST_SetSRID(e.center_pt,4326),ST_SetSRID(ref_geom,4326)) As dist
+		          ST_DistanceSphere(ST_SetSRID(e.center_pt,4326),ST_SetSRID(ref_geom,4326)) As dist
 				FROM ea AS e 
 					LEFT JOIN (SELECT featnames.* FROM featnames 
 			    WHERE featnames.statefp = ' || quote_literal(var_state) ||'   ) AS n ON (n.statefp =  e.statefp AND n.tlid = e.tlid) 
diff --git a/extras/tiger_geocoder/normalize/normalize_address.sql b/extras/tiger_geocoder/normalize/normalize_address.sql
index f68cc2c..e55b7a2 100644
--- a/extras/tiger_geocoder/normalize/normalize_address.sql
+++ b/extras/tiger_geocoder/normalize/normalize_address.sql
@@ -697,7 +697,7 @@ BEGIN
   END IF;
 
  -- For address number only put numbers and stop if reach a non-number e.g. 123-456 will return 123
-  result.address := to_number(substring(addressString, '[0-9]+'), '99999999999');
+  result.address := to_number(substring(addressString, '[0-9]+'), '99999999');
    --get rid of extraneous spaces before we return
   result.zip := trim(zipString);
   result.streetName := trim(result.streetName);
diff --git a/extras/tiger_geocoder/pagc_normalize/pagc_normalize_address.sql b/extras/tiger_geocoder/pagc_normalize/pagc_normalize_address.sql
index 6718c85..25b1d24 100644
--- a/extras/tiger_geocoder/pagc_normalize/pagc_normalize_address.sql
+++ b/extras/tiger_geocoder/pagc_normalize/pagc_normalize_address.sql
@@ -31,7 +31,7 @@ BEGIN
    COALESCE(', ' || var_parse_rec.city,'') || COALESCE(', ' || var_parse_rec.state, '') || COALESCE(' ' || var_parse_rec.zip,'')  ) ;
  
  -- For address number only put numbers and stop if reach a non-number e.g. 123-456 will return 123
-  result.address := to_number(substring(var_rec.house_num, '[0-9]+'), '99999999999');
+  result.address := to_number(substring(var_rec.house_num, '[0-9]+'), '99999999');
    --get rid of extraneous spaces before we return
   result.zip := COALESCE(var_rec.postcode,result.zip);
   result.streetName := trim(var_rec.name);
diff --git a/liblwgeom/cunit/cu_clip_by_rect.c b/liblwgeom/cunit/cu_clip_by_rect.c
index 66bad2e..dc50cf1 100644
--- a/liblwgeom/cunit/cu_clip_by_rect.c
+++ b/liblwgeom/cunit/cu_clip_by_rect.c
@@ -42,7 +42,23 @@ static void test_lwgeom_clip_by_rect(void)
 	CU_ASSERT_STRING_EQUAL(wkt, tmp)
 	lwfree(tmp); lwgeom_free(out); lwgeom_free(in);
 
-  /* Disjoint polygon */
+	wkt = "MULTIPOINT EMPTY";
+	in = lwgeom_from_wkt(wkt, LW_PARSER_CHECK_NONE);
+	out = lwgeom_clip_by_rect(in, 5, 0, 10, 10);
+	tmp = lwgeom_to_ewkt(out);
+	/* printf("%s\n", tmp); */
+	CU_ASSERT_STRING_EQUAL(wkt, tmp)
+	lwfree(tmp); lwgeom_free(out); lwgeom_free(in);
+
+	wkt = "MULTIPOINT(0 0, 6 6, 7 5)";
+	in = lwgeom_from_wkt(wkt, LW_PARSER_CHECK_NONE);
+	out = lwgeom_clip_by_rect(in, 5, 0, 10, 10);
+	tmp = lwgeom_to_ewkt(out);
+	/* printf("%s\n", tmp); */
+	CU_ASSERT_STRING_EQUAL("MULTIPOINT(6 6,7 5)", tmp)
+	lwfree(tmp); lwgeom_free(out); lwgeom_free(in);
+
+	/* Disjoint polygon */
 	wkt = "POLYGON((311017 4773762,311016 4773749,311006 4773744,310990 4773748,310980 4773758,310985 4773771,311003 4773776,311017 4773762))";
 	in = lwgeom_from_wkt(wkt, LW_PARSER_CHECK_NONE);
 	out = lwgeom_clip_by_rect(in, -80, -80, 80, 80);
diff --git a/liblwgeom/liblwgeom.h.in b/liblwgeom/liblwgeom.h.in
index f417c32..37aae15 100644
--- a/liblwgeom/liblwgeom.h.in
+++ b/liblwgeom/liblwgeom.h.in
@@ -1027,7 +1027,12 @@ extern LWCURVEPOLY* lwcurvepoly_construct_from_lwpoly(LWPOLY *lwpoly);
 
 extern int lwcollection_ngeoms(const LWCOLLECTION *col);
 
-/* Given a generic geometry/collection, return the "simplest" form. */
+/* Given a generic geometry/collection, return the "simplest" form.
+ * The elements of the homogenized collection are references to the
+ * input geometry; a deep clone is not performed.
+ * TODO: consider returning a geometry that does not reference the
+ * input
+ * */
 extern LWGEOM *lwgeom_homogenize(const LWGEOM *geom);
 
 
@@ -2040,6 +2045,73 @@ int lwgeom_has_arc(const LWGEOM *geom);
 LWGEOM *lwgeom_stroke(const LWGEOM *geom, uint32_t perQuad);
 LWGEOM *lwgeom_unstroke(const LWGEOM *geom);
 
+/**
+ * Semantic of the `tolerance` argument passed to
+ * lwcurve_linearize
+ */
+typedef enum {
+	/**
+	 * Tolerance expresses the number of segments to use
+	 * for each quarter of circle (quadrant). Must be
+	 * an integer.
+	 */
+	LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD = 0,
+	/**
+	 * Tolerance expresses the maximum distance between
+	 * an arbitrary point on the curve and the closest
+	 * point to it on the resulting approximation, in
+	 * cartesian units.
+	 */
+	LW_LINEARIZE_TOLERANCE_TYPE_MAX_DEVIATION = 1,
+	/**
+	 * Tolerance expresses the maximum angle between
+	 * the radii generating approximation line vertices,
+	 * given in radiuses. A value of 1 would result
+	 * in an approximation of a semicircle composed by
+	 * 180 segments
+	 */
+	LW_LINEARIZE_TOLERANCE_TYPE_MAX_ANGLE = 2
+} LW_LINEARIZE_TOLERANCE_TYPE;
+
+typedef enum {
+  /**
+   * Symmetric linearization means that the output
+   * vertices would be the same no matter the order
+   * of the points defining the input curve.
+   */
+	LW_LINEARIZE_FLAG_SYMMETRIC = 1 << 0,
+
+  /**
+   * Retain angle instructs the engine to try its best
+   * to retain the requested angle between generating
+   * radii (where angle can be given explicitly with
+   * LW_LINEARIZE_TOLERANCE_TYPE_MAX_ANGLE or implicitly
+   * with LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD or
+   * LW_LINEARIZE_TOLERANCE_TYPE_MAX_DEVIATION).
+   *
+   * It only makes sense with LW_LINEARIZE_FLAG_SYMMETRIC
+   * which would otherwise reduce the angle as needed to
+   * keep it constant among all radiis so that all
+   * segments are of the same length.
+   *
+   * When this flag is set, the first and last generating
+   * angles (and thus the first and last segments) may
+   * instead be smaller (shorter) than the others.
+   *
+   */
+	LW_LINEARIZE_FLAG_RETAIN_ANGLE = 1 << 1
+} LW_LINEARIZE_FLAGS;
+
+/**
+ * @param geom input geometry
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags bitwise OR of operational flags, see LW_LINEARIZE_FLAGS
+ *
+ * @return a newly allocated LWGEOM
+ */
+extern LWGEOM* lwcurve_linearize(const LWGEOM *geom, double tol, LW_LINEARIZE_TOLERANCE_TYPE type, int flags);
+
 /*******************************************************************************
  * GEOS proxy functions on LWGEOM
  ******************************************************************************/
diff --git a/liblwgeom/lwgeodetic.c b/liblwgeom/lwgeodetic.c
index d660b84..23afaef 100644
--- a/liblwgeom/lwgeodetic.c
+++ b/liblwgeom/lwgeodetic.c
@@ -1907,6 +1907,7 @@ static double ptarray_distance_spheroid(const POINTARRAY *pa1, const POINTARRAY
 		/* Copy end to start to allow a new end value in next iteration */
 		e1.start = e1.end;
 		A1 = A2;
+		LW_ON_INTERRUPT(return -1.0);
 	}
 	LWDEBUGF(4,"finished all loops, returning %.8g", distance);
 
diff --git a/liblwgeom/lwgeom.c b/liblwgeom/lwgeom.c
index 9dfa063..9c27124 100644
--- a/liblwgeom/lwgeom.c
+++ b/liblwgeom/lwgeom.c
@@ -1912,10 +1912,20 @@ lwgeom_subdivide_recursive(const LWGEOM *geom, int maxvertices, int depth, LWCOL
 	}
 	
 	if ( width == 0.0 && height == 0.0 )
-		return 0;
+	{
+		if ( geom->type == POINTTYPE )
+		{
+			lwcollection_add_lwgeom(col, lwgeom_clone_deep(geom));
+			return 1;			
+		}
+		else
+		{
+			return 0;
+		}
+	}
 	
 	/* Always just recurse into collections */
-	if ( lwgeom_is_collection(geom) )
+	if ( lwgeom_is_collection(geom) && geom->type != MULTIPOINTTYPE )
 	{
 		LWCOLLECTION *incol = (LWCOLLECTION*)geom;
 		int n = 0;
diff --git a/liblwgeom/lwgeom_geos.c b/liblwgeom/lwgeom_geos.c
index a6f0c16..a9cad4c 100644
--- a/liblwgeom/lwgeom_geos.c
+++ b/liblwgeom/lwgeom_geos.c
@@ -327,7 +327,7 @@ LWGEOM2GEOS(const LWGEOM *lwgeom, int autofix)
 	/*
 	LWGEOM *tmp;
 	*/
-	uint32_t ngeoms, i;
+	uint32_t ngeoms, i, j;
 	int geostype;
 #if LWDEBUG_LEVEL >= 4
 	char *wkt;
@@ -456,18 +456,24 @@ LWGEOM2GEOS(const LWGEOM *lwgeom, int autofix)
 		if ( ngeoms > 0 )
 			geoms = malloc(sizeof(GEOSGeom)*ngeoms);
 
+		j = 0;
 		for (i=0; i<ngeoms; ++i)
 		{
-			GEOSGeometry* g = LWGEOM2GEOS(lwc->geoms[i], 0);
+			GEOSGeometry* g;
+			
+			if( lwgeom_is_empty(lwc->geoms[i]) )
+				continue;
+			
+			g = LWGEOM2GEOS(lwc->geoms[i], 0);
 			if ( ! g )
 			{
 				while (i) GEOSGeom_destroy(geoms[--i]);
 				free(geoms);
 				return NULL;
 			}
-			geoms[i] = g;
+			geoms[j++] = g;
 		}
-		g = GEOSGeom_createCollection(geostype, geoms, ngeoms);
+		g = GEOSGeom_createCollection(geostype, geoms, j);
 		if ( geoms ) free(geoms);
 		if ( ! g ) return NULL;
 		break;
@@ -961,7 +967,7 @@ lwgeom_clip_by_rect(const LWGEOM *geom1, double x0, double y0, double x1, double
 #if POSTGIS_GEOS_VERSION < 35
 	lwerror("The GEOS version this postgis binary "
 	        "was compiled against (%d) doesn't support "
-	        "'GEOSClipByRect' function (3.3.5+ required)",
+	        "'GEOSClipByRect' function (3.5.0+ required)",
 	        POSTGIS_GEOS_VERSION);
 	return NULL;
 #else /* POSTGIS_GEOS_VERSION >= 35 */
diff --git a/liblwgeom/lwlinearreferencing.c b/liblwgeom/lwlinearreferencing.c
index b702292..dc4dcde 100644
--- a/liblwgeom/lwlinearreferencing.c
+++ b/liblwgeom/lwlinearreferencing.c
@@ -524,11 +524,6 @@ lwmline_clip_to_ordinate_range(const LWMLINE *mline, char ordinate, double from,
 		}
 	}
 
-	if ( ! lwgeom_out || lwgeom_out->ngeoms == 0 ) /* Nothing left after clip. */
-	{
-		return NULL;
-	}
-
 	return lwgeom_out;
 
 }
diff --git a/liblwgeom/lwstroke.c b/liblwgeom/lwstroke.c
index 47cd169..af89f4c 100644
--- a/liblwgeom/lwstroke.c
+++ b/liblwgeom/lwstroke.c
@@ -2,13 +2,28 @@
  *
  * PostGIS - Spatial Types for PostgreSQL
  * http://postgis.net
- * Copyright 2001-2006 Refractions Research Inc.
  *
- * This is free software; you can redistribute and/or modify it under
- * the terms of the GNU General Public Licence. See the COPYING file.
+ * PostGIS is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * PostGIS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with PostGIS.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ **********************************************************************
+ *
+ * Copyright (C) 2001-2006 Refractions Research Inc.
+ * Copyright (C) 2017      Sandro Santilli <strk@kbt.io>
  *
  **********************************************************************/
 
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
@@ -16,15 +31,11 @@
 
 #include "liblwgeom_internal.h"
 
-/* #define POSTGIS_DEBUG_LEVEL 4 */
+/*#define POSTGIS_DEBUG_LEVEL 3*/
 
 #include "lwgeom_log.h"
 
 
-LWMLINE* lwmcurve_stroke(const LWMCURVE *mcurve, uint32_t perQuad);
-LWMPOLY* lwmsurface_stroke(const LWMSURFACE *msurface, uint32_t perQuad);
-LWCOLLECTION* lwcollection_stroke(const LWCOLLECTION *collection, uint32_t perQuad);
-
 LWGEOM* pta_unstroke(const POINTARRAY *points, int type, int srid);
 LWGEOM* lwline_unstroke(const LWLINE *line);
 LWGEOM* lwpolygon_unstroke(const LWPOLY *poly);
@@ -64,7 +75,7 @@ lwgeom_has_arc(const LWGEOM *geom)
 		col = (LWCOLLECTION *)geom;
 		for (i=0; i<col->ngeoms; i++)
 		{
-			if (lwgeom_has_arc(col->geoms[i]) == LW_TRUE) 
+			if (lwgeom_has_arc(col->geoms[i]) == LW_TRUE)
 				return LW_TRUE;
 		}
 		return LW_FALSE;
@@ -98,8 +109,25 @@ static double interpolate_arc(double angle, double a1, double a2, double a3, dou
 	}
 }
 
-static POINTARRAY *
-lwcircle_stroke(const POINT4D *p1, const POINT4D *p2, const POINT4D *p3, uint32_t perQuad)
+/**
+ * Segmentize an arc
+ *
+ * @param to POINTARRAY to append segmentized vertices to
+ * @param p1 first point defining the arc
+ * @param p2 second point defining the arc
+ * @param p3 third point defining the arc
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags LW_LINEARIZE_FLAGS
+ *
+ * @return number of points appended (0 if collinear),
+ *         or -1 on error (lwerror would be called).
+ */
+static int
+lwarc_linearize(POINTARRAY *to,
+                 const POINT4D *p1, const POINT4D *p2, const POINT4D *p3,
+                 double tol, LW_LINEARIZE_TOLERANCE_TYPE tolerance_type,
+                 int flags)
 {
 	POINT2D center;
 	POINT2D *t1 = (POINT2D*)p1;
@@ -110,41 +138,126 @@ lwcircle_stroke(const POINT4D *p1, const POINT4D *p2, const POINT4D *p3, uint32_
 	int clockwise = LW_TRUE;
 	double radius; /* Arc radius */
 	double increment; /* Angle per segment */
+	double angle_shift = 0;
 	double a1, a2, a3, angle;
-	POINTARRAY *pa;
+	POINTARRAY *pa = to;
 	int is_circle = LW_FALSE;
+	int points_added = 0;
 
-	LWDEBUG(2, "lwcircle_calculate_gbox called.");
+	LWDEBUG(2, "lwarc_linearize called.");
 
 	radius = lw_arc_center(t1, t2, t3, &center);
+	LWDEBUGF(2, " center is POINT(%.15g %.15g) - radius:%g", center.x, center.y, radius);
 	p2_side = lw_segment_side(t1, t3, t2);
 
 	/* Matched start/end points imply circle */
 	if ( p1->x == p3->x && p1->y == p3->y )
 		is_circle = LW_TRUE;
-	
+
 	/* Negative radius signals straight line, p1/p2/p3 are colinear */
 	if ( (radius < 0.0 || p2_side == 0) && ! is_circle )
-	    return NULL;
-		
-	/* The side of the p1/p3 line that p2 falls on dictates the sweep  
+	    return 0;
+
+	/* The side of the p1/p3 line that p2 falls on dictates the sweep
 	   direction from p1 to p3. */
 	if ( p2_side == -1 )
 		clockwise = LW_TRUE;
 	else
 		clockwise = LW_FALSE;
-		
-	increment = fabs(M_PI_2 / perQuad);
-	
+
+	if ( tolerance_type == LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD )
+	{{
+		int perQuad = rint(tol);
+		// error out if tol != perQuad ? (not-round)
+		if ( perQuad != tol )
+		{
+			lwerror("lwarc_linearize: segments per quadrant must be an integer value, got %.15g", tol, perQuad);
+			return -1;
+		}
+		if ( perQuad < 1 )
+		{
+			lwerror("lwarc_linearize: segments per quadrant must be at least 1, got %d", perQuad);
+			return -1;
+		}
+		increment = fabs(M_PI_2 / perQuad);
+		LWDEBUGF(2, "lwarc_linearize: perQuad:%d, increment:%g (%g degrees)", perQuad, increment, increment*180/M_PI);
+
+	}}
+	else if ( tolerance_type == LW_LINEARIZE_TOLERANCE_TYPE_MAX_DEVIATION )
+	{{
+		double halfAngle;
+		if ( tol <= 0 )
+		{
+			lwerror("lwarc_linearize: max deviation must be bigger than 0, got %.15g", tol);
+			return -1;
+		}
+		halfAngle = acos( -tol / radius + 1 );
+		increment = 2 * halfAngle;
+		LWDEBUGF(2, "lwarc_linearize: maxDiff:%g, radius:%g, halfAngle:%g, increment:%g (%g degrees)", tol, radius, halfAngle, increment, increment*180/M_PI);
+	}}
+	else if ( tolerance_type == LW_LINEARIZE_TOLERANCE_TYPE_MAX_ANGLE )
+	{
+		increment = tol;
+		if ( increment <= 0 )
+		{
+			lwerror("lwarc_linearize: max angle must be bigger than 0, got %.15g", tol);
+			return -1;
+		}
+	}
+	else
+	{
+		lwerror("lwarc_linearize: unsupported tolerance type %d", tolerance_type);
+		return LW_FALSE;
+	}
+
 	/* Angles of each point that defines the arc section */
 	a1 = atan2(p1->y - center.y, p1->x - center.x);
 	a2 = atan2(p2->y - center.y, p2->x - center.x);
 	a3 = atan2(p3->y - center.y, p3->x - center.x);
 
+	LWDEBUGF(2, "lwarc_linearize A1:%g A2:%g A3:%g",
+		a1*180/M_PI, a2*180/M_PI, a3*180/M_PI);
+
+	if ( flags & LW_LINEARIZE_FLAG_SYMMETRIC )
+	{{
+		/* Calculate total arc angle, in radians */
+		double angle = clockwise ? a1 - a3 : a3 - a1;
+		if ( angle < 0 ) angle += M_PI * 2;
+		LWDEBUGF(2, "lwarc_linearize SYMMETRIC requested - total angle %g deg",
+			         angle * 180 / M_PI);
+		if ( flags & LW_LINEARIZE_FLAG_RETAIN_ANGLE )
+		{{
+			/* Number of steps */
+			int steps = trunc(angle / increment);
+			/* Angle reminder */
+			double angle_reminder = angle - ( increment * steps );
+			angle_shift = angle_reminder / 2.0;
+
+			LWDEBUGF(2, "lwarc_linearize RETAIN_ANGLE operation requested - "
+			         "total angle %g, steps %d, increment %g, reminder %g",
+			         angle * 180 / M_PI, steps, increment * 180 / M_PI,
+			         angle_reminder * 180 / M_PI);
+		}}
+		else
+		{{
+			/* Number of segments in output */
+			int segs = ceil(angle / increment);
+			/* Tweak increment to be regular for all the arc */
+			increment = angle/segs;
+
+			LWDEBUGF(2, "lwarc_linearize SYMMETRIC operation requested - "
+							"total angle %g degrees - LINESTRING(%g %g,%g %g,%g %g) - S:%d -   I:%g",
+							angle*180/M_PI, p1->x, p1->y, center.x, center.y, p3->x, p3->y,
+							segs, increment*180/M_PI);
+		}}
+	}}
+
 	/* p2 on left side => clockwise sweep */
 	if ( clockwise )
 	{
+		LWDEBUG(2, " Clockwise sweep");
 		increment *= -1;
+		angle_shift *= -1;
 		/* Adjust a3 down so we can decrement from a1 to a3 cleanly */
 		if ( a3 > a1 )
 			a3 -= 2.0 * M_PI;
@@ -154,13 +267,14 @@ lwcircle_stroke(const POINT4D *p1, const POINT4D *p2, const POINT4D *p3, uint32_
 	/* p2 on right side => counter-clockwise sweep */
 	else
 	{
+		LWDEBUG(2, " Counterclockwise sweep");
 		/* Adjust a3 up so we can increment from a1 to a3 cleanly */
 		if ( a3 < a1 )
 			a3 += 2.0 * M_PI;
 		if ( a2 < a1 )
 			a2 += 2.0 * M_PI;
 	}
-	
+
 	/* Override angles for circle case */
 	if( is_circle )
 	{
@@ -169,59 +283,69 @@ lwcircle_stroke(const POINT4D *p1, const POINT4D *p2, const POINT4D *p3, uint32_
 		increment = fabs(increment);
 		clockwise = LW_FALSE;
 	}
-	
-	/* Initialize point array */
-	pa = ptarray_construct_empty(1, 1, 32);
+
+	LWDEBUGF(2, "lwarc_linearize angle_shift:%g, increment:%g",
+		angle_shift * 180/M_PI, increment * 180/M_PI);
 
 	/* Sweep from a1 to a3 */
 	ptarray_append_point(pa, p1, LW_FALSE);
-	for ( angle = a1 + increment; clockwise ? angle > a3 : angle < a3; angle += increment ) 
+	++points_added;
+	if ( angle_shift ) angle_shift -= increment;
+	LWDEBUGF(2, "a1:%g (%g deg), a3:%g (%g deg), inc:%g, shi:%g, cw:%d",
+		a1, a1 * 180 / M_PI, a3, a3 * 180 / M_PI, increment, angle_shift, clockwise);
+	for ( angle = a1 + increment + angle_shift; clockwise ? angle > a3 : angle < a3; angle += increment )
 	{
+		LWDEBUGF(2, " SA: %g ( %g deg )", angle, angle*180/M_PI);
 		pt.x = center.x + radius * cos(angle);
 		pt.y = center.y + radius * sin(angle);
 		pt.z = interpolate_arc(angle, a1, a2, a3, p1->z, p2->z, p3->z);
 		pt.m = interpolate_arc(angle, a1, a2, a3, p1->m, p2->m, p3->m);
 		ptarray_append_point(pa, &pt, LW_FALSE);
-	}	
-	return pa;
+		++points_added;
+		angle_shift = 0;
+	}
+	return points_added;
 }
 
-LWLINE *
-lwcircstring_stroke(const LWCIRCSTRING *icurve, uint32_t perQuad)
+/*
+ * @param icurve input curve
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWLINE
+ */
+static LWLINE *
+lwcircstring_linearize(const LWCIRCSTRING *icurve, double tol,
+                        LW_LINEARIZE_TOLERANCE_TYPE tolerance_type,
+                        int flags)
 {
 	LWLINE *oline;
 	POINTARRAY *ptarray;
-	POINTARRAY *tmp;
 	uint32_t i, j;
 	POINT4D p1, p2, p3, p4;
+	int ret;
 
-	LWDEBUGF(2, "lwcircstring_stroke called., dim = %d", icurve->points->flags);
+	LWDEBUGF(2, "lwcircstring_linearize called., dim = %d", icurve->points->flags);
 
 	ptarray = ptarray_construct_empty(FLAGS_GET_Z(icurve->points->flags), FLAGS_GET_M(icurve->points->flags), 64);
 
 	for (i = 2; i < icurve->points->npoints; i+=2)
 	{
-		LWDEBUGF(3, "lwcircstring_stroke: arc ending at point %d", i);
+		LWDEBUGF(3, "lwcircstring_linearize: arc ending at point %d", i);
 
 		getPoint4d_p(icurve->points, i - 2, &p1);
 		getPoint4d_p(icurve->points, i - 1, &p2);
 		getPoint4d_p(icurve->points, i, &p3);
-		tmp = lwcircle_stroke(&p1, &p2, &p3, perQuad);
 
-		if (tmp)
+		ret = lwarc_linearize(ptarray, &p1, &p2, &p3, tol, tolerance_type, flags);
+		if ( ret > 0 )
 		{
-			LWDEBUGF(3, "lwcircstring_stroke: generated %d points", tmp->npoints);
-
-			for (j = 0; j < tmp->npoints; j++)
-			{
-				getPoint4d_p(tmp, j, &p4);
-				ptarray_append_point(ptarray, &p4, LW_TRUE);
-			}
-			ptarray_free(tmp);
+			LWDEBUGF(3, "lwcircstring_linearize: generated %d points", ptarray->npoints);
 		}
-		else
+		else if ( ret == 0 )
 		{
-			LWDEBUG(3, "lwcircstring_stroke: points are colinear, returning curve points as line");
+			LWDEBUG(3, "lwcircstring_linearize: points are colinear, returning curve points as line");
 
 			for (j = i - 2 ; j < i ; j++)
 			{
@@ -229,17 +353,32 @@ lwcircstring_stroke(const LWCIRCSTRING *icurve, uint32_t perQuad)
 				ptarray_append_point(ptarray, &p4, LW_TRUE);
 			}
 		}
-
+		else
+		{
+			/* An error occurred, lwerror should have been called by now */
+			ptarray_free(ptarray);
+			return NULL;
+		}
 	}
 	getPoint4d_p(icurve->points, icurve->points->npoints-1, &p1);
 	ptarray_append_point(ptarray, &p1, LW_TRUE);
-		
+
 	oline = lwline_construct(icurve->srid, NULL, ptarray);
 	return oline;
 }
 
-LWLINE *
-lwcompound_stroke(const LWCOMPOUND *icompound, uint32_t perQuad)
+/*
+ * @param icompound input compound curve
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWLINE
+ */
+static LWLINE *
+lwcompound_linearize(const LWCOMPOUND *icompound, double tol,
+                      LW_LINEARIZE_TOLERANCE_TYPE tolerance_type,
+                      int flags)
 {
 	LWGEOM *geom;
 	POINTARRAY *ptarray = NULL, *ptarray_out = NULL;
@@ -256,7 +395,7 @@ lwcompound_stroke(const LWCOMPOUND *icompound, uint32_t perQuad)
 		geom = icompound->geoms[i];
 		if (geom->type == CIRCSTRINGTYPE)
 		{
-			tmp = lwcircstring_stroke((LWCIRCSTRING *)geom, perQuad);
+			tmp = lwcircstring_linearize((LWCIRCSTRING *)geom, tol, tolerance_type, flags);
 			for (j = 0; j < tmp->points->npoints; j++)
 			{
 				getPoint4d_p(tmp->points, j, &p);
@@ -285,8 +424,26 @@ lwcompound_stroke(const LWCOMPOUND *icompound, uint32_t perQuad)
 	return lwline_construct(icompound->srid, NULL, ptarray_out);
 }
 
-LWPOLY *
-lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
+/* Kept for backward compatibility - TODO: drop */
+LWLINE *
+lwcompound_stroke(const LWCOMPOUND *icompound, uint32_t perQuad)
+{
+		return lwcompound_linearize(icompound, perQuad, LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD, 0);
+}
+
+
+/*
+ * @param icompound input curve polygon
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWPOLY
+ */
+static LWPOLY *
+lwcurvepoly_linearize(const LWCURVEPOLY *curvepoly, double tol,
+                       LW_LINEARIZE_TOLERANCE_TYPE tolerance_type,
+                       int flags)
 {
 	LWPOLY *ogeom;
 	LWGEOM *tmp;
@@ -294,7 +451,7 @@ lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
 	POINTARRAY **ptarray;
 	int i;
 
-	LWDEBUG(2, "lwcurvepoly_stroke called.");
+	LWDEBUG(2, "lwcurvepoly_linearize called.");
 
 	ptarray = lwalloc(sizeof(POINTARRAY *)*curvepoly->nrings);
 
@@ -303,7 +460,7 @@ lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
 		tmp = curvepoly->rings[i];
 		if (tmp->type == CIRCSTRINGTYPE)
 		{
-			line = lwcircstring_stroke((LWCIRCSTRING *)tmp, perQuad);
+			line = lwcircstring_linearize((LWCIRCSTRING *)tmp, tol, tolerance_type, flags);
 			ptarray[i] = ptarray_clone_deep(line->points);
 			lwline_free(line);
 		}
@@ -314,7 +471,7 @@ lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
 		}
 		else if (tmp->type == COMPOUNDTYPE)
 		{
-			line = lwcompound_stroke((LWCOMPOUND *)tmp, perQuad);
+			line = lwcompound_linearize((LWCOMPOUND *)tmp, tol, tolerance_type, flags);
 			ptarray[i] = ptarray_clone_deep(line->points);
 			lwline_free(line);
 		}
@@ -329,14 +486,32 @@ lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
 	return ogeom;
 }
 
-LWMLINE *
-lwmcurve_stroke(const LWMCURVE *mcurve, uint32_t perQuad)
+/* Kept for backward compatibility - TODO: drop */
+LWPOLY *
+lwcurvepoly_stroke(const LWCURVEPOLY *curvepoly, uint32_t perQuad)
+{
+		return lwcurvepoly_linearize(curvepoly, perQuad, LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD, 0);
+}
+
+
+/**
+ * @param mcurve input compound curve
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWMLINE
+ */
+static LWMLINE *
+lwmcurve_linearize(const LWMCURVE *mcurve, double tol,
+                    LW_LINEARIZE_TOLERANCE_TYPE type,
+                    int flags)
 {
 	LWMLINE *ogeom;
 	LWGEOM **lines;
 	int i;
 
-	LWDEBUGF(2, "lwmcurve_stroke called, geoms=%d, dim=%d.", mcurve->ngeoms, FLAGS_NDIMS(mcurve->flags));
+	LWDEBUGF(2, "lwmcurve_linearize called, geoms=%d, dim=%d.", mcurve->ngeoms, FLAGS_NDIMS(mcurve->flags));
 
 	lines = lwalloc(sizeof(LWGEOM *)*mcurve->ngeoms);
 
@@ -345,7 +520,7 @@ lwmcurve_stroke(const LWMCURVE *mcurve, uint32_t perQuad)
 		const LWGEOM *tmp = mcurve->geoms[i];
 		if (tmp->type == CIRCSTRINGTYPE)
 		{
-			lines[i] = (LWGEOM *)lwcircstring_stroke((LWCIRCSTRING *)tmp, perQuad);
+			lines[i] = (LWGEOM *)lwcircstring_linearize((LWCIRCSTRING *)tmp, tol, type, flags);
 		}
 		else if (tmp->type == LINETYPE)
 		{
@@ -353,7 +528,7 @@ lwmcurve_stroke(const LWMCURVE *mcurve, uint32_t perQuad)
 		}
 		else if (tmp->type == COMPOUNDTYPE)
 		{
-			lines[i] = (LWGEOM *)lwcompound_stroke((LWCOMPOUND *)tmp, perQuad);
+			lines[i] = (LWGEOM *)lwcompound_linearize((LWCOMPOUND *)tmp, tol, type, flags);
 		}
 		else
 		{
@@ -366,8 +541,18 @@ lwmcurve_stroke(const LWMCURVE *mcurve, uint32_t perQuad)
 	return ogeom;
 }
 
-LWMPOLY *
-lwmsurface_stroke(const LWMSURFACE *msurface, uint32_t perQuad)
+/**
+ * @param msurface input multi surface
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWMPOLY
+ */
+static LWMPOLY *
+lwmsurface_linearize(const LWMSURFACE *msurface, double tol,
+                      LW_LINEARIZE_TOLERANCE_TYPE type,
+                      int flags)
 {
 	LWMPOLY *ogeom;
 	LWGEOM *tmp;
@@ -376,7 +561,7 @@ lwmsurface_stroke(const LWMSURFACE *msurface, uint32_t perQuad)
 	POINTARRAY **ptarray;
 	int i, j;
 
-	LWDEBUG(2, "lwmsurface_stroke called.");
+	LWDEBUG(2, "lwmsurface_linearize called.");
 
 	polys = lwalloc(sizeof(LWGEOM *)*msurface->ngeoms);
 
@@ -385,7 +570,7 @@ lwmsurface_stroke(const LWMSURFACE *msurface, uint32_t perQuad)
 		tmp = msurface->geoms[i];
 		if (tmp->type == CURVEPOLYTYPE)
 		{
-			polys[i] = (LWGEOM *)lwcurvepoly_stroke((LWCURVEPOLY *)tmp, perQuad);
+			polys[i] = (LWGEOM *)lwcurvepoly_linearize((LWCURVEPOLY *)tmp, tol, type, flags);
 		}
 		else if (tmp->type == POLYGONTYPE)
 		{
@@ -402,15 +587,25 @@ lwmsurface_stroke(const LWMSURFACE *msurface, uint32_t perQuad)
 	return ogeom;
 }
 
-LWCOLLECTION *
-lwcollection_stroke(const LWCOLLECTION *collection, uint32_t perQuad)
+/**
+ * @param collection input geometry collection
+ * @param tol tolerance, semantic driven by tolerance_type
+ * @param tolerance_type see LW_LINEARIZE_TOLERANCE_TYPE
+ * @param flags see flags in lwarc_linearize
+ *
+ * @return a newly allocated LWCOLLECTION
+ */
+static LWCOLLECTION *
+lwcollection_linearize(const LWCOLLECTION *collection, double tol,
+                    LW_LINEARIZE_TOLERANCE_TYPE type,
+                    int flags)
 {
 	LWCOLLECTION *ocol;
 	LWGEOM *tmp;
 	LWGEOM **geoms;
 	int i;
 
-	LWDEBUG(2, "lwcollection_stroke called.");
+	LWDEBUG(2, "lwcollection_linearize called.");
 
 	geoms = lwalloc(sizeof(LWGEOM *)*collection->ngeoms);
 
@@ -420,16 +615,18 @@ lwcollection_stroke(const LWCOLLECTION *collection, uint32_t perQuad)
 		switch (tmp->type)
 		{
 		case CIRCSTRINGTYPE:
-			geoms[i] = (LWGEOM *)lwcircstring_stroke((LWCIRCSTRING *)tmp, perQuad);
+			geoms[i] = (LWGEOM *)lwcircstring_linearize((LWCIRCSTRING *)tmp, tol, type, flags);
 			break;
 		case COMPOUNDTYPE:
-			geoms[i] = (LWGEOM *)lwcompound_stroke((LWCOMPOUND *)tmp, perQuad);
+			geoms[i] = (LWGEOM *)lwcompound_linearize((LWCOMPOUND *)tmp, tol, type, flags);
 			break;
 		case CURVEPOLYTYPE:
-			geoms[i] = (LWGEOM *)lwcurvepoly_stroke((LWCURVEPOLY *)tmp, perQuad);
+			geoms[i] = (LWGEOM *)lwcurvepoly_linearize((LWCURVEPOLY *)tmp, tol, type, flags);
 			break;
+		case MULTICURVETYPE:
+		case MULTISURFACETYPE:
 		case COLLECTIONTYPE:
-			geoms[i] = (LWGEOM *)lwcollection_stroke((LWCOLLECTION *)tmp, perQuad);
+			geoms[i] = (LWGEOM *)lwcollection_linearize((LWCOLLECTION *)tmp, tol, type, flags);
 			break;
 		default:
 			geoms[i] = lwgeom_clone(tmp);
@@ -441,28 +638,30 @@ lwcollection_stroke(const LWCOLLECTION *collection, uint32_t perQuad)
 }
 
 LWGEOM *
-lwgeom_stroke(const LWGEOM *geom, uint32_t perQuad)
+lwcurve_linearize(const LWGEOM *geom, double tol,
+                  LW_LINEARIZE_TOLERANCE_TYPE type,
+                  int flags)
 {
 	LWGEOM * ogeom = NULL;
 	switch (geom->type)
 	{
 	case CIRCSTRINGTYPE:
-		ogeom = (LWGEOM *)lwcircstring_stroke((LWCIRCSTRING *)geom, perQuad);
+		ogeom = (LWGEOM *)lwcircstring_linearize((LWCIRCSTRING *)geom, tol, type, flags);
 		break;
 	case COMPOUNDTYPE:
-		ogeom = (LWGEOM *)lwcompound_stroke((LWCOMPOUND *)geom, perQuad);
+		ogeom = (LWGEOM *)lwcompound_linearize((LWCOMPOUND *)geom, tol, type, flags);
 		break;
 	case CURVEPOLYTYPE:
-		ogeom = (LWGEOM *)lwcurvepoly_stroke((LWCURVEPOLY *)geom, perQuad);
+		ogeom = (LWGEOM *)lwcurvepoly_linearize((LWCURVEPOLY *)geom, tol, type, flags);
 		break;
 	case MULTICURVETYPE:
-		ogeom = (LWGEOM *)lwmcurve_stroke((LWMCURVE *)geom, perQuad);
+		ogeom = (LWGEOM *)lwmcurve_linearize((LWMCURVE *)geom, tol, type, flags);
 		break;
 	case MULTISURFACETYPE:
-		ogeom = (LWGEOM *)lwmsurface_stroke((LWMSURFACE *)geom, perQuad);
+		ogeom = (LWGEOM *)lwmsurface_linearize((LWMSURFACE *)geom, tol, type, flags);
 		break;
 	case COLLECTIONTYPE:
-		ogeom = (LWGEOM *)lwcollection_stroke((LWCOLLECTION *)geom, perQuad);
+		ogeom = (LWGEOM *)lwcollection_linearize((LWCOLLECTION *)geom, tol, type, flags);
 		break;
 	default:
 		ogeom = lwgeom_clone(geom);
@@ -470,6 +669,13 @@ lwgeom_stroke(const LWGEOM *geom, uint32_t perQuad)
 	return ogeom;
 }
 
+/* Kept for backward compatibility - TODO: drop */
+LWGEOM *
+lwgeom_stroke(const LWGEOM *geom, uint32_t perQuad)
+{
+	return lwcurve_linearize(geom, perQuad, LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD, 0);
+}
+
 /**
  * Return ABC angle in radians
  * TODO: move to lwalgorithm
@@ -514,9 +720,9 @@ static int pt_continues_arc(const POINT4D *a1, const POINT4D *a2, const POINT4D
 	b_distance = distance2d_pt_pt(tb, &center);
 	diff = fabs(radius - b_distance);
 	LWDEBUGF(4, "circle_radius=%g, b_distance=%g, diff=%g, percentage=%g", radius, b_distance, diff, diff/radius);
-	
+
 	/* Is the point b on the circle? */
-	if ( diff < EPSILON_SQLMM ) 
+	if ( diff < EPSILON_SQLMM )
 	{
 		int a2_side = lw_segment_side(t1, t3, t2);
 		int b_side  = lw_segment_side(t1, t3, tb);
@@ -526,7 +732,7 @@ static int pt_continues_arc(const POINT4D *a1, const POINT4D *a2, const POINT4D
 		/* Is the angle similar to the previous one ? */
 		diff = fabs(angle1 - angle2);
 		LWDEBUGF(4, " angle1: %g, angle2: %g, diff:%g", angle1, angle2, diff);
-		if ( diff > EPSILON_SQLMM ) 
+		if ( diff > EPSILON_SQLMM )
 		{
 			return LW_FALSE;
 		}
@@ -549,7 +755,7 @@ linestring_from_pa(const POINTARRAY *pa, int srid, int start, int end)
 	for( i = start; i < end + 2; i++ )
 	{
 		getPoint4d_p(pa, i, &p);
-		ptarray_set_point4d(pao, j++, &p);	
+		ptarray_set_point4d(pao, j++, &p);
 	}
 	return lwline_as_lwgeom(lwline_construct(srid, NULL, pao));
 }
@@ -557,16 +763,16 @@ linestring_from_pa(const POINTARRAY *pa, int srid, int start, int end)
 static LWGEOM*
 circstring_from_pa(const POINTARRAY *pa, int srid, int start, int end)
 {
-	
+
 	POINT4D p0, p1, p2;
 	POINTARRAY *pao = ptarray_construct(ptarray_has_z(pa), ptarray_has_m(pa), 3);
 	LWDEBUGF(4, "srid=%d, start=%d, end=%d", srid, start, end);
 	getPoint4d_p(pa, start, &p0);
-	ptarray_set_point4d(pao, 0, &p0);	
+	ptarray_set_point4d(pao, 0, &p0);
 	getPoint4d_p(pa, (start+end+1)/2, &p1);
-	ptarray_set_point4d(pao, 1, &p1);	
+	ptarray_set_point4d(pao, 1, &p1);
 	getPoint4d_p(pa, end+1, &p2);
-	ptarray_set_point4d(pao, 2, &p2);	
+	ptarray_set_point4d(pao, 2, &p2);
 	return lwcircstring_as_lwgeom(lwcircstring_construct(srid, NULL, pao));
 }
 
@@ -603,19 +809,19 @@ pta_unstroke(const POINTARRAY *points, int type, int srid)
 	/* Null on empty input? */
 	if ( points->npoints == 0 )
 		return NULL;
-	
+
 	/* We can't desegmentize anything shorter than four points */
 	if ( points->npoints < 4 )
 	{
 		/* Return a linestring here*/
 		lwerror("pta_unstroke needs implementation for npoints < 4");
 	}
-	
+
 	/* Allocate our result array of vertices that are part of arcs */
 	num_edges = points->npoints - 1;
 	edges_in_arcs = lwalloc(num_edges + 1);
 	memset(edges_in_arcs, 0, num_edges + 1);
-	
+
 	/* We make a candidate arc of the first two edges, */
 	/* And then see if the next edge follows it */
 	while( i < num_edges-2 )
@@ -673,7 +879,7 @@ pta_unstroke(const POINTARRAY *points, int type, int srid)
 				lw_arc_center((POINT2D*)&first, (POINT2D*)&b, (POINT2D*)&a1, (POINT2D*)&center);
 				angle = lw_arc_angle((POINT2D*)&first, (POINT2D*)&center, (POINT2D*)&b);
         int p2_side = lw_segment_side((POINT2D*)&first, (POINT2D*)&a1, (POINT2D*)&b);
-        if ( p2_side >= 0 ) angle = -angle; 
+        if ( p2_side >= 0 ) angle = -angle;
 
 				if ( angle < 0 ) angle = 2 * M_PI + angle;
 				num_quadrants = ( 4 * angle ) / ( 2 * M_PI );
@@ -695,7 +901,7 @@ pta_unstroke(const POINTARRAY *points, int type, int srid)
 			i = i+1;
 		}
 	}
-	
+
 #if POSTGIS_DEBUG_LEVEL > 3
 	{
 		char *edgestr = lwalloc(num_edges+1);
@@ -730,7 +936,7 @@ pta_unstroke(const POINTARRAY *points, int type, int srid)
 	/* Roll out last item */
 	end = num_edges - 1;
 	lwcollection_add_lwgeom(outcol, geom_from_pa(points, srid, edge_type, start, end));
-	
+
 	/* Strip down to singleton if only one entry */
 	if ( outcol->ngeoms == 1 )
 	{
@@ -808,7 +1014,7 @@ lwmline_unstroke(const LWMLINE *mline)
 	return (LWGEOM *)lwcollection_construct(MULTICURVETYPE, mline->srid, NULL, mline->ngeoms, geoms);
 }
 
-LWGEOM * 
+LWGEOM *
 lwmpolygon_unstroke(const LWMPOLY *mpoly)
 {
 	LWGEOM **geoms;
diff --git a/libpgcommon/Makefile.in b/libpgcommon/Makefile.in
index e89a1f2..da368cc 100644
--- a/libpgcommon/Makefile.in
+++ b/libpgcommon/Makefile.in
@@ -10,7 +10,7 @@
 # **********************************************************************
 
 CC=@CC@
-CFLAGS=@CFLAGS@ -I../liblwgeom @PGSQL_BE_CPPFLAGS@ @PROJ_CPPFLAGS@ @PICFLAGS@ @WARNFLAGS@ @GETTEXT_CFLAGS@
+CFLAGS=-I../liblwgeom @CFLAGS@ @PGSQL_BE_CPPFLAGS@ @PROJ_CPPFLAGS@ @PICFLAGS@ @WARNFLAGS@ @GETTEXT_CFLAGS@
 LDFLAGS=@GETTEXT_LDFLAGS@ @LIBINTL@
 
 NUMERICFLAGS=@NUMERICFLAGS@
diff --git a/loader/Makefile.in b/loader/Makefile.in
index 80956fc..1b4842f 100644
--- a/loader/Makefile.in
+++ b/loader/Makefile.in
@@ -114,14 +114,40 @@ $(SHP2PGSQL-GUI): $(SHPLIB_OBJS) shp2pgsql-core.o shp2pgsql-gui.o pgsql2shp-core
 installdir:
 	@mkdir -p $(DESTDIR)$(bindir)
 
-install: installdir 
+install-desktop:
+ifdef gtk_build
+	mkdir -p $(DESTDIR)$(datadir)/applications
+	$(INSTALL_DATA) shp2pgsql-gui.desktop $(DESTDIR)$(datadir)/applications/shp2pgsql-gui.desktop
+endif
+
+ICON_SIZES = 8x8 16x16 22x22 24x24 32x32 36x36 40x40 42x42 48x48 64x64
+
+install-icons:
+ifdef gtk_build
+	for size in $(ICON_SIZES); do \
+		mkdir -p $(DESTDIR)$(datadir)/icons/hicolor/$${size}/apps; \
+		#$(INSTALL_DATA) icons/hicolor/$${size}/apps/shp2pgsql-gui.png $(DESTDIR)$(datadir)/icons/hicolor/$${size}/apps/shp2pgsql-gui.png; \
+	done
+endif
+
+install: installdir install-desktop install-icons
 ifdef gtk_build
 	$(LIBTOOL) --mode=install $(INSTALL) $(SHP2PGSQL-GUI) "$(DESTDIR)$(bindir)/$(SHP2PGSQL-GUI)"
 endif
 	$(LIBTOOL) --mode=install $(INSTALL) $(PGSQL2SHP-CLI) "$(DESTDIR)$(bindir)/$(PGSQL2SHP-CLI)"
 	$(LIBTOOL) --mode=install $(INSTALL) $(SHP2PGSQL-CLI) "$(DESTDIR)$(bindir)/$(SHP2PGSQL-CLI)"
 
-uninstall:
+uninstall-desktop:
+ifdef gtk_build
+	rm -f $(DESTDIR)$(datadir)/applications/shp2pgsql-gui.desktop
+endif
+
+uninstall-icons:
+ifdef gtk_build
+	rm -f $(DESTDIR)$(datadir)/icons/hicolor/*/apps/shp2pgsql-gui.png
+endif
+
+uninstall: uninstall-desktop uninstall-icons
 	$(LIBTOOL) --mode=uninstall rm -f "$(DESTDIR)$(bindir)/$(PGSQL2SHP-CLI)"
 	$(LIBTOOL) --mode=uninstall rm -f "$(DESTDIR)$(bindir)/$(SHP2PGSQL-CLI)"
 	$(LIBTOOL) --mode=uninstall rm -f "$(DESTDIR)$(bindir)/$(SHP2PGSQL-GUI)"
diff --git a/loader/icons/hicolor/16x16/apps/shp2pgsql-gui.png b/loader/icons/hicolor/16x16/apps/shp2pgsql-gui.png
new file mode 100644
index 0000000..3b318f3
Binary files /dev/null and b/loader/icons/hicolor/16x16/apps/shp2pgsql-gui.png differ
diff --git a/loader/icons/hicolor/22x22/apps/shp2pgsql-gui.png b/loader/icons/hicolor/22x22/apps/shp2pgsql-gui.png
new file mode 100644
index 0000000..22a2c8f
Binary files /dev/null and b/loader/icons/hicolor/22x22/apps/shp2pgsql-gui.png differ
diff --git a/loader/icons/hicolor/24x24/apps/shp2pgsql-gui.png b/loader/icons/hicolor/24x24/apps/shp2pgsql-gui.png
new file mode 100644
index 0000000..03daa6e
Binary files /dev/null and b/loader/icons/hicolor/24x24/apps/shp2pgsql-gui.png differ
diff --git a/loader/icons/hicolor/32x32/apps/shp2pgsql-gui.png b/loader/icons/hicolor/32x32/apps/shp2pgsql-gui.png
new file mode 100644
index 0000000..af10309
Binary files /dev/null and b/loader/icons/hicolor/32x32/apps/shp2pgsql-gui.png differ
diff --git a/loader/icons/hicolor/36x36/apps/shp2pgsql-gui.png b/loader/icons/hicolor/36x36/apps/shp2pgsql-gui.png
new file mode 100644
index 0000000..5e0f34c
Binary files /dev/null and b/loader/icons/hicolor/36x36/apps/shp2pgsql-gui.png differ
diff --git a/loader/icons/hicolor/40x40/apps/shp2pgsql-gui.png b/loader/icons/hicolor/40x40/apps/shp2pgsql-gui.png
new file mode 100644
index 0000000..b9e79db
Binary files /dev/null and b/loader/icons/hicolor/40x40/apps/shp2pgsql-gui.png differ
diff --git a/loader/icons/hicolor/42x42/apps/shp2pgsql-gui.png b/loader/icons/hicolor/42x42/apps/shp2pgsql-gui.png
new file mode 100644
index 0000000..b8bcadb
Binary files /dev/null and b/loader/icons/hicolor/42x42/apps/shp2pgsql-gui.png differ
diff --git a/loader/icons/hicolor/48x48/apps/shp2pgsql-gui.png b/loader/icons/hicolor/48x48/apps/shp2pgsql-gui.png
new file mode 100644
index 0000000..fa24730
Binary files /dev/null and b/loader/icons/hicolor/48x48/apps/shp2pgsql-gui.png differ
diff --git a/loader/icons/hicolor/64x64/apps/shp2pgsql-gui.png b/loader/icons/hicolor/64x64/apps/shp2pgsql-gui.png
new file mode 100644
index 0000000..21d7063
Binary files /dev/null and b/loader/icons/hicolor/64x64/apps/shp2pgsql-gui.png differ
diff --git a/loader/icons/hicolor/8x8/apps/shp2pgsql-gui.png b/loader/icons/hicolor/8x8/apps/shp2pgsql-gui.png
new file mode 100644
index 0000000..87d9b0d
Binary files /dev/null and b/loader/icons/hicolor/8x8/apps/shp2pgsql-gui.png differ
diff --git a/loader/shp2pgsql-cli.c b/loader/shp2pgsql-cli.c
index 3f38523..d9ca714 100644
--- a/loader/shp2pgsql-cli.c
+++ b/loader/shp2pgsql-cli.c
@@ -169,7 +169,7 @@ main (int argc, char **argv)
 			break;
 
 		case 'W':
-			config->encoding = pgis_optarg;
+			config->encoding = strdup(pgis_optarg);
 			break;
 
 		case 'N':
diff --git a/loader/shp2pgsql-gui.desktop b/loader/shp2pgsql-gui.desktop
new file mode 100644
index 0000000..7014243
--- /dev/null
+++ b/loader/shp2pgsql-gui.desktop
@@ -0,0 +1,10 @@
+[Desktop Entry]
+Type=Application
+Name=shp2pgsql-gui
+GenericName=GUI for Shapefile to PostGIS import tool
+Comment=Import shapefiles into PostGIS databases
+Categories=Geography;Science;Geoscience;
+Exec=shp2pgsql-gui
+Icon=shp2pgsql-gui
+Terminal=false
+Keywords=spatial;postgis;postgresql;gis;
diff --git a/postgis/Makefile.in b/postgis/Makefile.in
index a327800..a574d27 100644
--- a/postgis/Makefile.in
+++ b/postgis/Makefile.in
@@ -90,7 +90,8 @@ OBJS=$(PG_OBJS)
 # to an existing liblwgeom.so in the PostgreSQL $libdir supplied by an
 # older version of PostGIS, rather than with the static liblwgeom.a
 # supplied with newer versions of PostGIS
-PG_CPPFLAGS += -I../liblwgeom -I../libpgcommon @CPPFLAGS@ -fPIC
+override CFLAGS := -I../liblwgeom $(CFLAGS)
+PG_CPPFLAGS += -I../libpgcommon @CPPFLAGS@ -fPIC
 SHLIB_LINK_F = ../libpgcommon/libpgcommon.a ../liblwgeom/.libs/liblwgeom.a @SHLIB_LINK@
 
 # Add SFCGAL Flags if defined
diff --git a/postgis/gserialized_gist_2d.c b/postgis/gserialized_gist_2d.c
index eb08781..a582090 100644
--- a/postgis/gserialized_gist_2d.c
+++ b/postgis/gserialized_gist_2d.c
@@ -372,7 +372,6 @@ static bool box2df_overabove(const BOX2DF *a, const BOX2DF *b)
 
 /**
 * Calculate the centroid->centroid distance between the boxes.
-* We return the square distance to avoid a call to sqrt.
 */
 static double box2df_distance_leaf_centroid(const BOX2DF *a, const BOX2DF *b)
 {
@@ -383,7 +382,6 @@ static double box2df_distance_leaf_centroid(const BOX2DF *a, const BOX2DF *b)
     double b_y = (b->ymax + b->ymin) / 2.0;
 
     /* This "distance" is only used for comparisons, */
-    /* so for speed we drop contants and skip the sqrt step. */
     return sqrt((a_x - b_x) * (a_x - b_x) + (a_y - b_y) * (a_y - b_y));
 }
 
@@ -475,27 +473,27 @@ static inline double pt_distance(double ax, double ay, double bx, double by)
 */
 static double box2df_distance(const BOX2DF *a, const BOX2DF *b)
 {
-    /* Check for overlap */
-    if ( box2df_overlaps(a, b) )
-        return 0.0;
+	/* Check for overlap */
+	if ( box2df_overlaps(a, b) )
+		return 0.0;
 
-    if ( box2df_left(a, b) )
-    {
-        if ( box2df_above(a, b) )
+	if ( box2df_left(a, b) )
+	{
+		if ( box2df_above(a, b) )
 			return pt_distance(a->xmax, a->ymin, b->xmin, b->ymax);
 		if ( box2df_below(a, b) )
 			return pt_distance(a->xmax, a->ymax, b->xmin, b->ymin);
 		else
-			return b->xmin - a->xmax;
+			return (double)b->xmin - (double)a->xmax;
 	}
 	if ( box2df_right(a, b) )
 	{
-        if ( box2df_above(a, b) )
+		if ( box2df_above(a, b) )
 			return pt_distance(a->xmin, a->ymin, b->xmax, b->ymax);
 		if ( box2df_below(a, b) )
 			return pt_distance(a->xmin, a->ymax, b->xmax, b->ymin);
 		else
-			return a->xmin - b->xmax;
+			return (double)a->xmin - (double)b->xmax;
 	}
 	if ( box2df_above(a, b) )
 	{
@@ -504,7 +502,7 @@ static double box2df_distance(const BOX2DF *a, const BOX2DF *b)
 		if ( box2df_right(a, b) )
 			return pt_distance(a->xmin, a->ymin, b->xmax, b->ymax);
 		else
-			return a->ymin - b->ymax;
+			return (double)a->ymin - (double)b->ymax;
 	}
 	if ( box2df_below(a, b) )
 	{
@@ -513,9 +511,9 @@ static double box2df_distance(const BOX2DF *a, const BOX2DF *b)
 		if ( box2df_right(a, b) )
 			return pt_distance(a->xmin, a->ymax, b->xmax, b->ymin);
 		else
-			return b->ymin - a->ymax;
+			return (double)b->ymin - (double)a->ymax;
 	}
-	
+
 	return FLT_MAX;
 }
 
@@ -1097,7 +1095,7 @@ Datum gserialized_gist_distance_2d(PG_FUNCTION_ARGS)
 	/* Box-style distance test */
 	if ( strategy == 14 ) /* operator <#> */
 	{
-		distance = (double)box2df_distance(entry_box, &query_box);
+		distance = box2df_distance(entry_box, &query_box);
 	}
 	/* True distance test (formerly centroid distance) */
 	else if ( strategy == 13 ) /* operator <-> */
@@ -1105,7 +1103,7 @@ Datum gserialized_gist_distance_2d(PG_FUNCTION_ARGS)
 		/* In all cases, since we only have keys (boxes) we'll return */
 		/* the minimum possible distance, which is the box2df_distance */
 		/* and let the recheck sort things out in the case of leaves */
-		distance = (double)box2df_distance(entry_box, &query_box);
+		distance = box2df_distance(entry_box, &query_box);
 
 		if (GIST_LEAF(entry))
 			*recheck = true;
diff --git a/postgis/gserialized_gist_nd.c b/postgis/gserialized_gist_nd.c
index 16d93d3..6f47643 100644
--- a/postgis/gserialized_gist_nd.c
+++ b/postgis/gserialized_gist_nd.c
@@ -746,7 +746,7 @@ Datum gserialized_distance_nd(PG_FUNCTION_ARGS)
 		else if ( lwgeom_get_type(lw2) == LINETYPE )
 		{
 			LWPOINT *lwp2 = lwline_get_lwpoint(lwgeom_as_lwline(closest), 1);
-			m1 = lwgeom_interpolate_point(lw2, lwp2);
+			m2 = lwgeom_interpolate_point(lw2, lwp2);
 			lwpoint_free(lwp2);
 		}
 		else 
diff --git a/postgis/lwgeom_accum.c b/postgis/lwgeom_accum.c
index e89d22a..4123ff8 100644
--- a/postgis/lwgeom_accum.c
+++ b/postgis/lwgeom_accum.c
@@ -275,7 +275,9 @@ pgis_geometry_polygonize_finalfn(PG_FUNCTION_ARGS)
 	p = (pgis_abs*) PG_GETARG_POINTER(0);
 
 	geometry_array = pgis_accum_finalfn(p, CurrentMemoryContext, fcinfo);
-	result = DirectFunctionCall1( polygonize_garray, geometry_array );
+	result = PGISDirectFunctionCall1( polygonize_garray, geometry_array );
+	if (!result)
+		PG_RETURN_NULL();
 
 	PG_RETURN_DATUM(result);
 }
diff --git a/postgis/lwgeom_export.c b/postgis/lwgeom_export.c
index 96357b2..24c6a41 100644
--- a/postgis/lwgeom_export.c
+++ b/postgis/lwgeom_export.c
@@ -622,9 +622,9 @@ Datum LWGEOM_asEncodedPolyline(PG_FUNCTION_ARGS)
 	lwgeom = lwgeom_from_gserialized(geom);
 	PG_FREE_IF_COPY(geom, 0);
 	
-	if (PG_NARGS() >2 && !PG_ARGISNULL(2))
+	if (PG_NARGS() > 1 && !PG_ARGISNULL(1))
 	{
-		precision = PG_GETARG_INT32(2);
+		precision = PG_GETARG_INT32(1);
 		if ( precision < 0 ) precision = 5;
 	}
 
diff --git a/postgis/lwgeom_functions_basic.c b/postgis/lwgeom_functions_basic.c
index fa016e4..c6c914a 100644
--- a/postgis/lwgeom_functions_basic.c
+++ b/postgis/lwgeom_functions_basic.c
@@ -2265,6 +2265,11 @@ Datum LWGEOM_setpoint_linestring(PG_FUNCTION_ARGS)
 		elog(ERROR, "First argument must be a LINESTRING");
 		PG_RETURN_NULL();
 	}
+	if ( lwgeom_is_empty(lwg) )
+	{
+		elog(ERROR, "Cannot set point values on EMPTY geometry, use ST_AddPoint to add points");
+		PG_RETURN_NULL();
+	}
 	if ( which > line->points->npoints-1 )
 	{
 		elog(ERROR, "Point index out of range (%d..%d)", 0, line->points->npoints-1);
@@ -2579,14 +2584,17 @@ Datum ST_CollectionHomogenize(PG_FUNCTION_ARGS)
 
 	lwoutput = lwgeom_homogenize(lwgeom);
 	lwgeom_free(lwgeom);
-	PG_FREE_IF_COPY(input, 0);
 
 	if ( ! lwoutput )
+	{
 		PG_RETURN_NULL();
+		PG_FREE_IF_COPY(input, 0);
+	}
 
 	output = geometry_serialize(lwoutput);
 	lwgeom_free(lwoutput);
 
+	PG_FREE_IF_COPY(input, 0);
 	PG_RETURN_POINTER(output);
 }
 
@@ -2634,7 +2642,7 @@ Datum ST_FlipCoordinates(PG_FUNCTION_ARGS)
 static LWORD ordname2ordval(char n)
 {
   if ( n == 'x' || n == 'X' ) return LWORD_X;
-  if ( n == 'y' || n == 'y' ) return LWORD_Y;
+  if ( n == 'y' || n == 'Y' ) return LWORD_Y;
   if ( n == 'z' || n == 'Z' ) return LWORD_Z;
   if ( n == 'm' || n == 'M' ) return LWORD_M;
   lwpgerror("Invalid ordinate name '%c'. Expected x,y,z or m", n);
diff --git a/postgis/lwgeom_geos.c b/postgis/lwgeom_geos.c
index 576f910..43c3e50 100644
--- a/postgis/lwgeom_geos.c
+++ b/postgis/lwgeom_geos.c
@@ -3371,7 +3371,6 @@ Datum GEOSnoop(PG_FUNCTION_ARGS)
 PG_FUNCTION_INFO_V1(polygonize_garray);
 Datum polygonize_garray(PG_FUNCTION_ARGS)
 {
-	Datum datum;
 	ArrayType *array;
 	int is3d = 0;
 	uint32 nelems, i;
@@ -3379,7 +3378,6 @@ Datum polygonize_garray(PG_FUNCTION_ARGS)
 	GEOSGeometry *geos_result;
 	const GEOSGeometry **vgeoms;
 	int srid=SRID_UNKNOWN;
-	size_t offset;
 #if POSTGIS_DEBUG_LEVEL >= 3
 	static int call=1;
 #endif
@@ -3388,47 +3386,21 @@ Datum polygonize_garray(PG_FUNCTION_ARGS)
 	call++;
 #endif
 
-	datum = PG_GETARG_DATUM(0);
-
-	/* Null array, null geometry (should be empty?) */
-	if ( (Pointer *)datum == NULL ) PG_RETURN_NULL();
-
-	array = DatumGetArrayTypeP(datum);
+	if (PG_ARGISNULL(0))
+		PG_RETURN_NULL();
 
-	nelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));
+	array = PG_GETARG_ARRAYTYPE_P(0);
+	nelems = array_nelems_not_null(array);
 
-	POSTGIS_DEBUGF(3, "polygonize_garray: number of elements: %d", nelems);
+	if (nelems == 0)
+		PG_RETURN_NULL();
 
-	if ( nelems == 0 ) PG_RETURN_NULL();
+	POSTGIS_DEBUGF(3, "polygonize_garray: number of non-null elements: %d", nelems);
 
 	/* Ok, we really need geos now ;) */
 	initGEOS(lwpgnotice, lwgeom_geos_error);
 
-	vgeoms = palloc(sizeof(GEOSGeometry *)*nelems);
-	offset = 0;
-	for (i=0; i<nelems; i++)
-	{
-		GEOSGeometry* g;
-		GSERIALIZED *geom = (GSERIALIZED *)(ARR_DATA_PTR(array)+offset);
-		offset += INTALIGN(VARSIZE(geom));
-		if ( ! is3d ) is3d = gserialized_has_z(geom);
-
-		g = (GEOSGeometry *)POSTGIS2GEOS(geom);
-		if ( 0 == g )   /* exception thrown at construction */
-		{
-			HANDLE_GEOS_ERROR("Geometry could not be converted to GEOS");
-			PG_RETURN_NULL();
-		}
-		vgeoms[i] = g;
-		if ( ! i )
-		{
-			srid = gserialized_get_srid(geom);
-		}
-		else
-		{
-			error_if_srid_mismatch(srid, gserialized_get_srid(geom));
-		}
-	}
+	vgeoms = (const GEOSGeometry**) ARRAY2GEOS(array, nelems, &is3d, &srid);
 
 	POSTGIS_DEBUG(3, "polygonize_garray: invoking GEOSpolygonize");
 
@@ -3450,10 +3422,7 @@ Datum polygonize_garray(PG_FUNCTION_ARGS)
 		PG_RETURN_NULL(); /*never get here */
 	}
 
-	/*compressType(result); */
-
 	PG_RETURN_POINTER(result);
-
 }
 
 
diff --git a/postgis/lwgeom_in_encoded_polyline.c b/postgis/lwgeom_in_encoded_polyline.c
index 944d3a3..1590b38 100644
--- a/postgis/lwgeom_in_encoded_polyline.c
+++ b/postgis/lwgeom_in_encoded_polyline.c
@@ -35,9 +35,9 @@ Datum line_from_encoded_polyline(PG_FUNCTION_ARGS)
   encodedpolyline_input = PG_GETARG_TEXT_P(0);
   encodedpolyline = text2cstring(encodedpolyline_input);
 
-  if (PG_NARGS() >2 && !PG_ARGISNULL(2))
+  if (PG_NARGS() > 1 && !PG_ARGISNULL(1))
   {
-    precision = PG_GETARG_INT32(2);
+    precision = PG_GETARG_INT32(1);
     if ( precision < 0 ) precision = 5;
   }
 
diff --git a/postgis/lwgeom_sqlmm.c b/postgis/lwgeom_sqlmm.c
index af59249..ea1c9d3 100644
--- a/postgis/lwgeom_sqlmm.c
+++ b/postgis/lwgeom_sqlmm.c
@@ -48,6 +48,8 @@ Datum LWGEOM_has_arc(PG_FUNCTION_ARGS)
  * Curve centers are determined by projecting the defining points into the 2d
  * plane.  Z and M values are assigned by linear interpolation between
  * defining points.
+ *
+ * TODO: drop, use ST_CurveToLine instead
  */
 PG_FUNCTION_INFO_V1(LWGEOM_curve_segmentize);
 Datum LWGEOM_curve_segmentize(PG_FUNCTION_ARGS)
@@ -70,10 +72,37 @@ Datum LWGEOM_curve_segmentize(PG_FUNCTION_ARGS)
 	igeom = lwgeom_from_gserialized(geom);
 	ogeom = lwgeom_stroke(igeom, perQuad);
 	lwgeom_free(igeom);
-	
-	if (ogeom == NULL) 
+
+	if (ogeom == NULL)
 		PG_RETURN_NULL();
-		
+
+	ret = geometry_serialize(ogeom);
+	lwgeom_free(ogeom);
+	PG_FREE_IF_COPY(geom, 0);
+	PG_RETURN_POINTER(ret);
+}
+
+PG_FUNCTION_INFO_V1(ST_CurveToLine);
+Datum ST_CurveToLine(PG_FUNCTION_ARGS)
+{
+	GSERIALIZED *geom = PG_GETARG_GSERIALIZED_P(0);
+	double tol = PG_GETARG_FLOAT8(1);
+	int toltype = PG_GETARG_INT32(2);
+	int flags = PG_GETARG_INT32(3);
+	GSERIALIZED *ret;
+	LWGEOM *igeom = NULL, *ogeom = NULL;
+
+	POSTGIS_DEBUG(2, "ST_CurveToLine called.");
+
+	POSTGIS_DEBUGF(3, "tol = %g, typ = %d, flg = %d", tol, toltype, flags);
+
+	igeom = lwgeom_from_gserialized(geom);
+	ogeom = lwcurve_linearize(igeom, tol, toltype, flags);
+	lwgeom_free(igeom);
+
+	if (ogeom == NULL)
+		PG_RETURN_NULL();
+
 	ret = geometry_serialize(ogeom);
 	lwgeom_free(ogeom);
 	PG_FREE_IF_COPY(geom, 0);
diff --git a/postgis/postgis.sql.in b/postgis/postgis.sql.in
index 45c6b6d..0295441 100644
--- a/postgis/postgis.sql.in
+++ b/postgis/postgis.sql.in
@@ -3544,6 +3544,7 @@ CREATE OR REPLACE FUNCTION ST_Combine_BBox(box2d,geometry)
 
 
 -- Availability: 1.2.2
+-- Changed: 2.2.0 to use non-deprecated ST_CombineBBox (r13535)
 CREATE AGGREGATE ST_Extent(
 	sfunc = ST_CombineBBox,
 	finalfunc = box2d,
@@ -3552,6 +3553,7 @@ CREATE AGGREGATE ST_Extent(
 	);
 
 -- Availability: 2.0.0
+-- Changed: 2.2.0 to use non-deprecated ST_CombineBBox (r13535)
 CREATE AGGREGATE ST_3DExtent(
 	sfunc = ST_CombineBBox,
 	basetype = geometry,
@@ -5213,15 +5215,36 @@ CREATE OR REPLACE FUNCTION ST_CoordDim(Geometry geometry)
 --
 -- SQL-MM
 --
+-- ST_CurveToLine(Geometry geometry, Tolerance float8, ToleranceType integer, Flags integer)
+--
+-- Converts a given geometry to a linear geometry.  Each curveed
+-- geometry or segment is converted into a linear approximation using
+-- the given tolerance.
+--
+-- Semantic of tolerance depends on the `toltype` argument, which can be:
+--    0: Tolerance is number of segments per quadrant
+--    1: Tolerance is max distance between curve and line
+--    2: Tolerance is max angle between radii defining line vertices
+--
+-- Supported flags:
+--    1: Symmetric output (result in same vertices when inverting the curve)
+--
+CREATE OR REPLACE FUNCTION ST_CurveToLine(geom geometry, tol float8, toltype integer, flags integer)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME', 'ST_CurveToLine'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+--
+-- SQL-MM
+--
 -- ST_CurveToLine(Geometry geometry, SegmentsPerQuarter integer)
 --
 -- Converts a given geometry to a linear geometry.  Each curveed
 -- geometry or segment is converted into a linear approximation using
 -- the given number of segments per quarter circle.
+--
 CREATE OR REPLACE FUNCTION ST_CurveToLine(geometry, integer)
-	RETURNS geometry
-	AS 'MODULE_PATHNAME', 'LWGEOM_curve_segmentize'
-	LANGUAGE 'c' IMMUTABLE STRICT;
+	RETURNS geometry AS 'SELECT ST_CurveToLine($1, $2::float8, 0, 0)'
+	LANGUAGE 'sql' IMMUTABLE STRICT;
 --
 -- SQL-MM
 --
@@ -5231,7 +5254,7 @@ CREATE OR REPLACE FUNCTION ST_CurveToLine(geometry, integer)
 -- geometry or segment is converted into a linear approximation using
 -- the default value of 32 segments per quarter circle
 CREATE OR REPLACE FUNCTION ST_CurveToLine(geometry)
-	RETURNS geometry AS 'SELECT ST_CurveToLine($1, 32)'
+	RETURNS geometry AS 'SELECT ST_CurveToLine($1, 32::integer)'
 	LANGUAGE 'sql' IMMUTABLE STRICT;
 
 CREATE OR REPLACE FUNCTION ST_HasArc(Geometry geometry)
@@ -5449,7 +5472,7 @@ $$
 	cavept geometry[];
 	seglength double precision;
 	var_tempgeom geometry;
-	scale_factor integer := 1;
+	scale_factor float := 1;
 	i integer;
 	
 	BEGIN
diff --git a/postgis/postgis_module.c b/postgis/postgis_module.c
index d1d0866..61b4468 100644
--- a/postgis/postgis_module.c
+++ b/postgis/postgis_module.c
@@ -114,7 +114,12 @@ _PG_fini(void)
 static void
 handleInterrupt(int sig)
 {
-  printf("Interrupt requested\n"); fflush(stdout);
+  /* NOTE: printf here would be dangerous, see
+   * https://trac.osgeo.org/postgis/ticket/3644
+   *
+   * TODO: block interrupts during execution, to fix the problem
+   */
+  /* printf("Interrupt requested\n"); fflush(stdout); */
 
 #if POSTGIS_GEOS_VERSION >= 34 
   GEOS_interruptRequest();
diff --git a/raster/rt_core/Makefile.in b/raster/rt_core/Makefile.in
index c6df021..4d05c47 100644
--- a/raster/rt_core/Makefile.in
+++ b/raster/rt_core/Makefile.in
@@ -28,7 +28,7 @@ LIBGDAL_LDFLAGS = @LIBGDAL_LDFLAGS@
 GEOS_LDFLAGS = @GEOS_LDFLAGS@ -lgeos_c
 PROJ_LDFLAGS = @PROJ_LDFLAGS@ -lproj
 LDFLAGS = $(LIBLWGEOM_LDFLAGS) $(LIBGDAL_LDFLAGS) $(PROJ_LDFLAGS) $(GEOS_LDFLAGS)
-CFLAGS = @CFLAGS@ @PICFLAGS@ @WARNFLAGS@ $(LIBLWGEOM_CFLAGS) $(LIBGDAL_CFLAGS) @PROJ_CPPFLAGS@ @GEOS_CPPFLAGS@
+CFLAGS = $(LIBLWGEOM_CFLAGS) @CFLAGS@ @PICFLAGS@ @WARNFLAGS@ $(LIBGDAL_CFLAGS) @PROJ_CPPFLAGS@ @GEOS_CPPFLAGS@
 
 # Standalone RTCORE objects
 RT_OBJS = \
diff --git a/raster/rt_pg/Makefile.in b/raster/rt_pg/Makefile.in
index 8f76cbd..f1e7313 100644
--- a/raster/rt_pg/Makefile.in
+++ b/raster/rt_pg/Makefile.in
@@ -65,7 +65,8 @@ LIBGDAL_CFLAGS=@LIBGDAL_CFLAGS@
 LIBGDAL_LDFLAGS=@LIBGDAL_LDFLAGS@
 LIBPROJ_CFLAGS=@PROJ_CPPFLAGS@
 
-PG_CPPFLAGS+=@CPPFLAGS@ $(LIBLWGEOM_CFLAGS) $(LIBGDAL_CFLAGS) $(LIBPGCOMMON_CFLAGS) $(LIBPROJ_CFLAGS) -I../rt_core
+override CFLAGS := $(LIBLWGEOM_CFLAGS) $(CFLAGS)
+PG_CPPFLAGS+= @CPPFLAGS@ $(LIBGDAL_CFLAGS) $(LIBPGCOMMON_CFLAGS) $(LIBPROJ_CFLAGS) -I../rt_core
 SHLIB_LINK_F = ../rt_core/librtcore.a $(LIBLWGEOM_LDFLAGS) $(LIBPGCOMMON_LDFLAGS) $(LIBGDAL_LDFLAGS) @SHLIB_LINK@ 
 
 # Extra files to remove during 'make clean'
diff --git a/raster/rt_pg/rtpostgis.c b/raster/rt_pg/rtpostgis.c
index b8c2702..98396c5 100644
--- a/raster/rt_pg/rtpostgis.c
+++ b/raster/rt_pg/rtpostgis.c
@@ -132,6 +132,7 @@
 #include <postgres.h> /* for palloc */
 #include <fmgr.h> /* for PG_MODULE_MAGIC */
 #include "utils/guc.h"
+#include "utils/memutils.h"
 
 #include "../../postgis_config.h"
 #include "lwgeom_pg.h"
@@ -151,6 +152,9 @@ PG_MODULE_MAGIC;
 /* Module load callback */
 void _PG_init(void);
 
+/* Module unload callback */
+void _PG_fini(void);
+
 #define RT_MSG_MAXLEN 256
 
 
@@ -244,6 +248,14 @@ static char *gdal_datapath = NULL;
 extern char *gdal_enabled_drivers;
 extern char enable_outdb_rasters;
 
+/* ---------------------------------------------------------------- */
+/*  Useful variables                                                */
+/* ---------------------------------------------------------------- */
+
+static char *env_postgis_gdal_enabled_drivers = NULL;
+static char *boot_postgis_gdal_enabled_drivers = NULL;
+static char *env_postgis_enable_outdb_rasters = NULL;
+
 /* postgis.gdal_datapath */
 static void
 rtpg_assignHookGDALDataPath(const char *newpath, void *extra) {
@@ -408,11 +420,8 @@ rtpg_assignHookEnableOutDBRasters(bool enable, void *extra) {
 void
 _PG_init(void) {
 
-	char *env_postgis_gdal_enabled_drivers = NULL;
-	char *boot_postgis_gdal_enabled_drivers = NULL;
-
-	char *env_postgis_enable_outdb_rasters = NULL;
 	bool boot_postgis_enable_outdb_rasters = false;
+	MemoryContext old_context;
 
 	/* Install liblwgeom handlers */
 	pg_install_lwgeom_handlers();
@@ -421,6 +430,12 @@ _PG_init(void) {
 	rt_set_handlers(rt_pg_alloc, rt_pg_realloc, rt_pg_free, rt_pg_error, rt_pg_debug, rt_pg_notice);
 
 	/*
+	 * Change to context for memory allocation calls like palloc() in the
+	 * extension initialization routine
+	 */
+	old_context = MemoryContextSwitchTo(TopMemoryContext);
+
+	/*
 	 use POSTGIS_GDAL_ENABLED_DRIVERS to set the bootValue
 	 of GUC postgis.gdal_enabled_drivers
 	*/
@@ -513,6 +528,27 @@ _PG_init(void) {
 		NULL  /* GucShowHook show_hook */
 	);
 
-	/* free memory allocations */
+	/* Revert back to old context */
+	MemoryContextSwitchTo(old_context);
+}
+
+/* Module unload callback */
+void
+_PG_fini(void) {
+
+	MemoryContext old_context;
+
+	old_context = MemoryContextSwitchTo(TopMemoryContext);
+
+	/* Clean up */
+	pfree(env_postgis_gdal_enabled_drivers);
 	pfree(boot_postgis_gdal_enabled_drivers);
+	pfree(env_postgis_enable_outdb_rasters);
+
+	env_postgis_gdal_enabled_drivers = NULL;
+	boot_postgis_gdal_enabled_drivers = NULL;
+	env_postgis_enable_outdb_rasters = NULL;
+
+	/* Revert back to old context */
+	MemoryContextSwitchTo(old_context);
 }
diff --git a/raster/rt_pg/rtpostgis.sql.in b/raster/rt_pg/rtpostgis.sql.in
index 94c7adf..7705e6e 100644
--- a/raster/rt_pg/rtpostgis.sql.in
+++ b/raster/rt_pg/rtpostgis.sql.in
@@ -7138,28 +7138,42 @@ CREATE OR REPLACE FUNCTION _add_raster_constraint_extent(rastschema name, rastta
 		fqtn text;
 		cn name;
 		sql text;
-		attr text;
+		attr text; srid integer;
 	BEGIN
 		fqtn := '';
 		IF length($1) > 0 THEN
 			fqtn := quote_ident($1) || '.';
 		END IF;
 		fqtn := fqtn || quote_ident($2);
+		
+		sql := 'SELECT MAX(ST_SRID('
+				|| quote_ident($3)
+		|| ') ) FROM '
+				|| fqtn
+				|| ' HAVING COUNT(DISTINCT ST_SRID('
+				|| quote_ident($3)
+		|| ') ) = 1';
+		EXECUTE sql INTO srid;
 
 		cn := 'enforce_max_extent_' || $3;
 
-		sql := 'SELECT st_ashexewkb(st_envelope(st_collect(st_envelope('
-			|| quote_ident($3)
-			|| ')))) FROM '
-			|| fqtn;
-		EXECUTE sql INTO attr;
-
-		sql := 'ALTER TABLE ' || fqtn
-			|| ' ADD CONSTRAINT ' || quote_ident(cn)
-			|| ' CHECK (st_envelope('
-			|| quote_ident($3)
-			|| ') @ ''' || attr || '''::geometry)';
-		RETURN _add_raster_constraint(cn, sql);
+		IF srid > -1 THEN
+			sql := 'SELECT st_ashexewkb( st_setsrid( st_extent( st_envelope('
+				|| quote_ident($3)
+				|| ')), ' || srid || ')) FROM '
+				|| fqtn;
+			EXECUTE sql INTO attr;
+		
+			sql := 'ALTER TABLE ' || fqtn
+				|| ' ADD CONSTRAINT ' || quote_ident(cn)
+				|| ' CHECK ( st_envelope('
+				|| quote_ident($3)
+				|| ') @ ''' || attr || '''::geometry) ';
+			RETURN  _add_raster_constraint(cn, sql);
+		ELSE 
+			-- no valid srid therefore doesn't make sense to set extent
+			RETURN false;
+		END IF;
 	END;
 	$$ LANGUAGE 'plpgsql' VOLATILE STRICT
 	COST 100;
@@ -8797,7 +8811,8 @@ BEGIN
   PERFORM AddOverviewConstraints(sinfo.sch, ttab, col,
                                  sinfo.sch, sinfo.tab, col, factor);
 
-  RETURN ttab;
+    -- return the schema as well as the table
+  RETURN sinfo.sch||'.'||ttab;
 END;
 $$ LANGUAGE 'plpgsql' VOLATILE STRICT;
 
diff --git a/raster/test/regress/rt_createoverview.sql b/raster/test/regress/rt_createoverview.sql
index 3cc172c..46cf51d 100644
--- a/raster/test/regress/rt_createoverview.sql
+++ b/raster/test/regress/rt_createoverview.sql
@@ -1,4 +1,5 @@
 SET client_min_messages TO warning;
+-- Test for table without explicit schema
 CREATE TABLE res1 AS SELECT
   ST_AddBand(
     ST_MakeEmptyRaster(10, 10, x, y, 1, -1, 0, 0, 0)
@@ -46,9 +47,94 @@ SELECT 'count',
 (SELECT count(*) r16 from o_16_res1)
 ;
 
+-- End of overview test on table without explicit schema
 
 DROP TABLE o_16_res1;
 DROP TABLE o_8_res1;
 DROP TABLE o_4_res1;
 DROP TABLE o_2_res1;
+-- Keep the source table 
+
+
+-- Test overview with table in schema
+-- 
+CREATE SCHEMA oschm;
+-- offset the schema tableto distinguish it from original
+-- let it be small to reduce time cost. 
+CREATE TABLE oschm.res1 AS SELECT
+  ST_AddBand(
+    ST_MakeEmptyRaster(10, 10, x, y, 1, -1, 0, 0, 0)
+    , 1, '8BUI', 0, 0
+  ) r
+FROM generate_series(100, 270, 10) x,
+     generate_series(140, -30, -10) y;
+SELECT addrasterconstraints('oschm'::name,'res1'::name, 'r'::name);
+
+-- add overview with explicit schema
+SELECT ST_CreateOverview('oschm.res1', 'r', 8)::text = 'oschm.o_8_res1';
+
+-- set search path to 'oschm' first
+SET search_path to oschm,public;
+
+-- create overview with schema in search_path
+SELECT ST_CreateOverview('res1', 'r', 4)::text = 'o_4_res1';
+
+-- Create overview for table in public schema with explict path
+-- at same factor of schema table
+SELECT ST_CreateOverview('public.res1', 'r', 8)::text = 'public.o_8_res1';
+ 
+-- Reset the search_path
+SET search_path to public;
+
+-- Create public overview of public table with same name
+-- and scale as schema table above using reset search path.
+SELECT ST_CreateOverview('res1', 'r', 4)::text = 'o_4_res1';
+
+-- Check scale and extent 
+-- Offset means that original raster overviews won't match
+-- extent and values only mach on schema table not public one
+SELECT r_table_schema, r_table_name tab, r_raster_column c,
+ srid s, scale_x sx, scale_y sy,
+ blocksize_x w, blocksize_y h, same_alignment a,
+ -- regular_blocking (why not regular?)
+ --extent::box2d e,
+ st_covers(extent::box2d, 'BOX(100 -30,270 140)'::box2d) ec,
+ st_xmin(extent::box2d) = 100 as eix,
+ st_ymax(extent::box2d) = 140 as eiy,
+ (st_xmax(extent::box2d) - 280) <= scale_x as eox,
+ --(st_xmax(extent::box2d) - 170) eoxd,
+ abs(st_ymin(extent::box2d) + 40) <= abs(scale_y) as eoy
+ --,abs(st_ymin(extent::box2d) + 80) eoyd
+ FROM raster_columns
+WHERE r_table_name like '%res1'
+ORDER BY r_table_schema, scale_x, r_table_name;
+
+-- this test may be redundant - it's just confirming that the
+-- overview factor is correct, which we do for the original table.
+SELECT o_table_schema, o_table_name, o_raster_column,
+       r_table_schema, r_table_name, r_raster_column, overview_factor
+FROM raster_overviews
+WHERE r_table_name = 'res1'
+AND   r_table_schema = 'oschm'
+ORDER BY o_table_schema,overview_factor;
+-- get the oschm table sizes
+SELECT 'count',
+(SELECT count(*) r1 from oschm.res1),
+(SELECT count(*) r4 from oschm.o_4_res1),
+(SELECT count(*) r8 from oschm.o_8_res1) ;
+
+-- clean up scheam oschm
+DROP TABLE oschm.o_8_res1;
+DROP TABLE oschm.o_4_res1;
+DROP TABLE oschm.res1;
+DROP SCHEMA oschm;
+
+-- Drop the tables for noschema test
+DROP TABLE o_8_res1;
+DROP TABLE o_4_res1;
 DROP TABLE res1;
+
+-- Reset the session environment 
+-- possibly a bit harsh, but we had to set the search_path
+-- and need to reset it back to default.
+DISCARD ALL;
diff --git a/raster/test/regress/rt_createoverview_expected b/raster/test/regress/rt_createoverview_expected
index 7173bca..e3afec4 100644
--- a/raster/test/regress/rt_createoverview_expected
+++ b/raster/test/regress/rt_createoverview_expected
@@ -13,3 +13,17 @@ o_4_res1|r|res1|r|4
 o_8_res1|r|res1|r|8
 o_16_res1|r|res1|r|16
 count|544|136|36|10|3
+t
+t
+t
+t
+t
+oschm|res1|r|0|1|-1|10|10|t|t|t|t|t|t
+oschm|o_4_res1|r|0|4|-4|10|10|t|t|t|t|t|t
+oschm|o_8_res1|r|0|8|-8|10|10|t|t|t|t|t|t
+public|res1|r|0|1|-1|10|10|t|f|f|f|t|f
+public|o_4_res1|r|0|4|-4|10|10|t|f|f|f|t|f
+public|o_8_res1|r|0|8|-8|10|10|t|f|f|f|t|f
+oschm|o_4_res1|r|oschm|res1|r|4
+oschm|o_8_res1|r|oschm|res1|r|8
+count|324|25|9
diff --git a/regress/Makefile.in b/regress/Makefile.in
index f7e8ae8..ee6f8bc 100644
--- a/regress/Makefile.in
+++ b/regress/Makefile.in
@@ -81,6 +81,7 @@ TESTS = \
 	cluster \
 	concave_hull\
 	ctors \
+	curvetoline \
 	dump \
 	dumppoints \
 	empty \
diff --git a/regress/curvetoline.sql b/regress/curvetoline.sql
new file mode 100644
index 0000000..00a7ca4
--- /dev/null
+++ b/regress/curvetoline.sql
@@ -0,0 +1,64 @@
+
+
+-- Semantic of tolerance depends on the `toltype` argument, which can be:
+--    0: Tolerance is number of segments per quadrant
+--    1: Tolerance is max distance between curve and line
+--    2: Tolerance is max angle between radii defining line vertices
+--
+-- Supported flags:
+--    1: Symmetric output (result in same vertices when inverting the curve)
+
+SELECT 'semicircle1', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	3, -- Tolerance
+	0, -- Above is number of segments per quadrant
+	0  -- no flags
+), 2));
+
+SELECT 'semicircle2', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	20, -- Tolerance
+	1, -- Above is max distance between curve and line
+	0  -- no flags
+), 2));
+
+SELECT 'semicircle2.sym', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	20, -- Tolerance
+	1, -- Above is max distance between curve and line
+	1  -- Symmetric flag
+), 2));
+
+SELECT 'semicircle3', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	radians(40), -- Tolerance
+	2, -- Above is max angle between generating radii
+	0  -- no flags
+), 2));
+
+SELECT 'semicircle3.sym', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	radians(40), -- Tolerance
+	2, -- Above is max angle between generating radii
+	1  -- Symmetric flag
+), 2));
+SELECT 'semicircle3.sym.ret', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
+	radians(40), -- Tolerance
+	2, -- Above is max angle between generating radii
+	3  -- Symmetric and RetainAngle flags
+), 2));
+SELECT 'multiarc1', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0,400 200,600 0)'::geometry,
+	radians(45), -- Tolerance
+	2, -- Above is max angle between generating radii
+	3  -- Symmetric and RetainAngle flags
+), 2));
+SELECT 'multiarc1.maxerr20.sym', ST_AsText(ST_SnapToGrid(ST_CurveToLine(
+ 'CIRCULARSTRING(0 0,100 -100,200 0,400 200,600 0)'::geometry,
+	20, -- Tolerance
+	1, -- Above is max distance between curve and line
+	1  -- Symmetric
+), 2));
+
+
diff --git a/regress/curvetoline_expected b/regress/curvetoline_expected
new file mode 100644
index 0000000..115897e
--- /dev/null
+++ b/regress/curvetoline_expected
@@ -0,0 +1,8 @@
+semicircle1|LINESTRING(0 0,14 -50,50 -86,100 -100,150 -86,186 -50,200 0)
+semicircle2|LINESTRING(0 0,72 -96,184 -54,200 0)
+semicircle2.sym|LINESTRING(0 0,50 -86,150 -86,200 0)
+semicircle3|LINESTRING(0 0,24 -64,82 -98,150 -86,194 -34,200 0)
+semicircle3.sym|LINESTRING(0 0,20 -58,70 -96,130 -96,180 -58,200 0)
+semicircle3.sym.ret|LINESTRING(0 0,2 -18,36 -76,100 -100,164 -76,198 -18,200 0)
+multiarc1|LINESTRING(0 0,30 -70,100 -100,170 -70,200 0,258 142,400 200,542 142,600 0)
+multiarc1.maxerr20.sym|LINESTRING(0 0,50 -86,150 -86,200 0,258 142,400 200,542 142,600 0)
diff --git a/regress/in_encodedpolyline.sql b/regress/in_encodedpolyline.sql
index 604fbc1..1fba56a 100644
--- a/regress/in_encodedpolyline.sql
+++ b/regress/in_encodedpolyline.sql
@@ -1,2 +1,2 @@
 select 'linefromencodedpolyline_01',st_asewkt(st_linefromencodedpolyline('_p~iF~ps|U_ulLnnqC_mqNvxq`@'));
-select 'linefromencodedpolyline_02',st_asewkt(st_linefromencodedpolyline('_p~iFlhz|UuksL`wjCivjNvxq`@', 6));
+select 'linefromencodedpolyline_02',st_asewkt(ST_SnapToGrid(st_linefromencodedpolyline('_izlhAj}oidF{}jgCrotj@chtxCn`{nI', 6),0.001));
diff --git a/regress/in_encodedpolyline_expected b/regress/in_encodedpolyline_expected
index 7024958..b0d6262 100644
--- a/regress/in_encodedpolyline_expected
+++ b/regress/in_encodedpolyline_expected
@@ -1,2 +1,2 @@
 linefromencodedpolyline_01|SRID=4326;LINESTRING(-120.2 38.5,-120.95 40.7,-126.453 43.252)
-linefromencodedpolyline_02|SRID=4326;LINESTRING(-120.23447 38.5,-120.95 40.73435,-126.453 43.252)
+linefromencodedpolyline_02|SRID=4326;LINESTRING(-120.234 38.5,-120.95 40.734,-126.453 43.252)
diff --git a/regress/knn_recheck_expected b/regress/knn_recheck_expected
index ca79418..9c37f23 100644
--- a/regress/knn_recheck_expected
+++ b/regress/knn_recheck_expected
@@ -124,3 +124,6 @@
 #3nd-3|600001|9461|54.3900|54.3900
 #3nd-3|600001|9749|54.5453|54.5453
 #3nd-3|600001|10041|54.6233|54.6233
+#3573|8
+#3418|0.331823813642119|0.331823813642119
+#3418|0.55|0.55
diff --git a/regress/out_geometry_expected b/regress/out_geometry_expected
index 9e6b084..f045640 100644
--- a/regress/out_geometry_expected
+++ b/regress/out_geometry_expected
@@ -41,7 +41,7 @@ kml_projection_01|<Point><coordinates>-74.078,4.596</coordinates></Point>
 encoded_polyline_01|_p~iF~ps|U_ulLnnqC_mqNvxq`@
 encoded_polyline_02|_p~iF~ps|U_ulLnnqC_mqNvxq`@
 ERROR:  Only SRID 4326 is supported.
-encoded_polyline_04|_p~iFlhz|UuksL`wjCivjNvxq`@
+encoded_polyline_04|_izlhAd}oidF{}jgCxotj@chtxCn`{nI
 svg_empty_geom|
 svg_option_01|M 1 -1 L 4 -4 5 -7
 svg_option_02|M 1 -1 l 3 -3 1 -3
diff --git a/regress/regress_lrs.sql b/regress/regress_lrs.sql
index ca78b4f..a362d9a 100644
--- a/regress/regress_lrs.sql
+++ b/regress/regress_lrs.sql
@@ -23,6 +23,12 @@ select 'LINEZM_3', ST_AsText(ST_LocateBetween('LINESTRING(0 10 100 0, 0 0 0 10,
 select 'LINEZM_4', ST_AsText(ST_LocateBetween('LINESTRING(0 10 100 0, 0 0 0 20, 10 0 0 0)', 2, 18));
 select 'LINEZM_5', ST_AsText(ST_LocateBetween('LINESTRING(0 10 100 0, 0 0 0 20, 0 10 10 40, 10 0 0 0)', 2, 18));
 select 'LINEZM_6', ST_AsText(ST_LocateBetween('LINESTRING(0 10 10 40, 10 0 0 0)', 2, 2));
+-- #3119 --
+select '#3119a', ST_AsText(ST_LocateBetweenElevations('LINESTRING Z(0 0 0, 10 10 10)'::geometry, 11, 11));
+
+-- Multilinestrings
+-- #3119 --
+select '#3119b', ST_AsText(ST_LocateBetweenElevations('MULTILINESTRING Z((0 0 0, 10 10 10))'::geometry, 11, 11));
 
 --- line_locate_point
 
diff --git a/regress/regress_lrs_expected b/regress/regress_lrs_expected
index 54ae3ff..a61cc04 100644
--- a/regress/regress_lrs_expected
+++ b/regress/regress_lrs_expected
@@ -15,6 +15,8 @@ LINEZM_3|MULTILINESTRING ZM ((0 8 80 2,0 0 0 10,8 0 0 2))
 LINEZM_4|MULTILINESTRING ZM ((0 9 90 2,0 1 10 18),(1 0 0 18,9 0 0 2))
 LINEZM_5|MULTILINESTRING ZM ((0 9 90 2,0 1 10 18),(5.5 4.5 4.5 18,9.5 0.5 0.5 2))
 LINEZM_6|MULTIPOINT ZM (9.5 0.5 0.5 2)
+#3119a|MULTILINESTRING Z EMPTY
+#3119b|MULTILINESTRING Z EMPTY
 line_locate_point_1|0.528602749909894
 line_locate_point_2|1
 line_locate_point_3|0
diff --git a/regress/run_test.pl b/regress/run_test.pl
index aa2481e..f67ef35 100755
--- a/regress/run_test.pl
+++ b/regress/run_test.pl
@@ -22,11 +22,18 @@ use Cwd 'abs_path';
 use Getopt::Long;
 use strict;
 
+##################################################################
+# Add . to @INC if removed for CVE-2016-1238
+##################################################################
+BEGIN {
+	push @INC, "." if(!grep /^\.$/, @INC);
+}
+
 
 ##################################################################
 # Usage ./run_test.pl <testname> [<testname>]
 #
-#  Create the spatial database 'postgis_reg' (or whatever $DB 
+#  Create the spatial database 'postgis_reg' (or whatever $DB
 #  is set to) if it doesn't already exist.
 #
 #  Run the <testname>.sql script
@@ -67,7 +74,7 @@ my $VERBOSE = 0;
 GetOptions (
 	'verbose' => \$VERBOSE,
 	'clean' => \$OPT_CLEAN,
-	'nodrop' => \$OPT_NODROP, 
+	'nodrop' => \$OPT_NODROP,
 	'upgrade' => \$OPT_UPGRADE,
 	'upgrade-path=s' => \$OPT_UPGRADE_PATH,
 	'dumprestore' => \$OPT_DUMPRESTORE,
@@ -90,7 +97,7 @@ if ( $OPT_UPGRADE_PATH )
   {
     die "--upgrade-path is only supported with --extension"
   }
-  $OPT_UPGRADE = 1; # implied 
+  $OPT_UPGRADE = 1; # implied
   my @path = split ('--', $OPT_UPGRADE_PATH);
   $OPT_UPGRADE_FROM = $path[0]
     || die "Malformed upgrade path, <from>--<to> expected, $OPT_UPGRADE_PATH given";
@@ -163,7 +170,7 @@ foreach my $exec ( ($SHP2PGSQL, $PGSQL2SHP) )
 		print "failed\n";
 		die "Unable to find $exec executable.\n";
 	}
-	
+
 }
 
 if ( $OPT_WITH_RASTER )
@@ -386,13 +393,13 @@ foreach $TEST (@ARGV)
 
 	start_test($TEST);
 
-	# Check for a "-pre.pl" file in case there are setup commands 
+	# Check for a "-pre.pl" file in case there are setup commands
     eval_file("${TEST}-pre.pl");
 
 	# Check for a "-pre.sql" file in case there is setup SQL needed before
 	# the test can be run.
 	if ( -r "${TEST}-pre.sql" )
-	{	
+	{
 		run_simple_sql("${TEST}-pre.sql");
 		show_progress();
 	}
@@ -434,18 +441,18 @@ foreach $TEST (@ARGV)
 			print " ... but cleanup sql failed!";
 		}
 	}
-	
-	# Check for a "-post.pl" file in case there are teardown commands 
+
+	# Check for a "-post.pl" file in case there are teardown commands
     eval_file("${TEST}-post.pl");
-	
+
 }
 
 
-################################################################### 
+###################################################################
 # Uninstall postgis (serves as an uninstall test)
 ##################################################################
 
-# We only test uninstall if we've been asked to drop 
+# We only test uninstall if we've been asked to drop
 # and we did create
 # and nobody requested raster or topology
 # (until they have an uninstall script themself)
@@ -489,7 +496,7 @@ exit($FAIL);
 # Utility functions
 #
 
-sub usage 
+sub usage
 {
 	die qq{
 Usage: $0 [<options>] <testname> [<testname>]
@@ -532,7 +539,7 @@ sub show_progress
 	print ".";
 }
 
-# pass <msg> 
+# pass <msg>
 sub pass
 {
   my $msg = shift;
@@ -566,10 +573,10 @@ sub fail
 	$FAIL++;
 }
 
-  
+
 
 ##################################################################
-# run_simple_sql 
+# run_simple_sql
 #   Run an sql script and hide results unless it fails.
 #   SQL input file name is $1
 ##################################################################
@@ -577,7 +584,7 @@ sub run_simple_sql
 {
 	my $sql = shift;
 
-	if ( ! -r $sql ) 
+	if ( ! -r $sql )
 	{
 		fail("can't read $sql");
 		return 0;
@@ -589,18 +596,18 @@ sub run_simple_sql
 	#print($cmd);
 	my $rv = system($cmd);
 	# Check if psql errored out.
-	if ( $rv != 0 ) 
+	if ( $rv != 0 )
 	{
 		fail("Unable to run sql script $sql", $tmpfile);
 		return 0;
 	}
-	
+
 	# Check for ERROR lines
 	open FILE, "$tmpfile";
 	my @lines = <FILE>;
 	close FILE;
 	my @errors = grep(/^ERROR/, @lines);
-	
+
 	if ( @errors > 0 )
 	{
 		fail("Errors while running sql script $sql", $tmpfile);
@@ -616,7 +623,7 @@ sub drop_table
 	my $tblname = shift;
 	my $cmd = "psql -tXA -d $DB -c \"DROP TABLE IF EXISTS $tblname\" >> $REGRESS_LOG 2>&1";
 	my $rv = system($cmd);
-	die "Could not run: $cmd\n" if $rv;	
+	die "Could not run: $cmd\n" if $rv;
 }
 
 sub sql
@@ -642,7 +649,7 @@ sub eval_file
 }
 
 ##################################################################
-# run_simple_test 
+# run_simple_test
 #   Run an sql script and compare results with the given expected output
 #   SQL input is ${TEST}.sql, expected output is {$TEST}_expected
 ##################################################################
@@ -657,7 +664,7 @@ sub run_simple_test
 		fail("can't read $sql");
 		return 0;
 	}
-	
+
 	if ( ! $OPT_EXPECT )
 	{
 		if ( ! -r "$expected" )
@@ -705,7 +712,7 @@ sub run_simple_test
 	@lines = grep(!/^(INSERT|DELETE|UPDATE|SELECT|COPY|DO)/, @lines);
 	@lines = grep(!/^(CONTEXT|RESET|ANALYZE)/, @lines);
 	@lines = grep(!/^(DROP|CREATE|ALTER|VACUUM)/, @lines);
-	@lines = grep(!/^(LOG|SET|TRUNCATE)/, @lines);
+	@lines = grep(!/^(LOG|SET|TRUNCATE|DISCARD)/, @lines);
 	@lines = grep(!/^LINE \d/, @lines);
 	@lines = grep(!/^\s+$/, @lines);
 
@@ -720,10 +727,10 @@ sub run_simple_test
 		$lines[$i] =~ s/^ROLLBACK/COMMIT/;
 		$lines[$i] =~ s/^psql.*(NOTICE|WARNING|ERROR):/\1:/g;
 	}
-	
+
 	# Write out output file
 	open(FILE, ">$outfile");
-	foreach my $l (@lines) 
+	foreach my $l (@lines)
 	{
 		print FILE $l;
 	}
@@ -731,7 +738,7 @@ sub run_simple_test
 
 	# Clean up interim stuff
 	#remove_tree($betmpdir);
-	
+
 	if ( $OPT_EXPECT )
 	{
 		print " (expected)";
@@ -754,7 +761,7 @@ sub run_simple_test
 			return 1;
 		}
 	}
-	
+
 	return 1;
 }
 
@@ -787,7 +794,7 @@ sub run_loader_and_check_output
 	my ( $cmd, $rv );
 	my $outfile = "${TMPDIR}/loader.out";
 	my $errfile = "${TMPDIR}/loader.err";
-	
+
 	# ON_ERROR_STOP is used by psql to return non-0 on an error
 	my $psql_opts = " --no-psqlrc --variable ON_ERROR_STOP=true";
 
@@ -815,7 +822,7 @@ sub run_loader_and_check_output
 				return 0;
 			}
 		}
-		
+
 		# Run the loader SQL script.
 		show_progress();
 		$cmd = "psql $psql_opts -f $outfile $DB > $errfile 2>&1";
@@ -857,13 +864,13 @@ sub run_dumper_and_check_output
 
 	my ($cmd, $rv);
 	my $errfile = "${TMPDIR}/dumper.err";
-	
-	if ( $run_always || -r $expected_shp_file ) 
+
+	if ( $run_always || -r $expected_shp_file )
 	{
 		show_progress();
 		$cmd = "${PGSQL2SHP} -f ${TMPDIR}/dumper $DB $tblname > $errfile 2>&1";
 		$rv = system($cmd);
-	
+
 		if ( $rv )
 		{
 			fail("$description: dumping loaded table", $errfile);
@@ -871,11 +878,11 @@ sub run_dumper_and_check_output
 		}
 
 		# Compare with expected output if there is any.
-		
+
 		if ( -r $expected_shp_file )
 		{
 			show_progress();
-			
+
 			my $diff = diff($expected_shp_file,  "$TMPDIR/dumper.shp");
 			if ( $diff )
 			{
@@ -914,7 +921,7 @@ sub run_raster_loader_and_check_output
 	my $expected_select_results_file = shift;
 	my $loader_options = shift;
 	my $run_always = shift;
-	
+
 	# ON_ERROR_STOP is used by psql to return non-0 on an error
 	my $psql_opts="--no-psqlrc --variable ON_ERROR_STOP=true";
 
@@ -922,20 +929,20 @@ sub run_raster_loader_and_check_output
 	my $outfile = "${TMPDIR}/loader.out";
 	my $errfile = "${TMPDIR}/loader.err";
 
-	if ( $run_always || -r $expected_sql_file || -r $expected_select_results_file ) 
+	if ( $run_always || -r $expected_sql_file || -r $expected_select_results_file )
 	{
 		show_progress();
 
 		# Produce the output SQL file.
 		$cmd = "$RASTER2PGSQL $loader_options ${TEST}.tif $tblname > $outfile 2> $errfile";
 		$rv = system($cmd);
-		
+
 		if ( $rv )
 		{
 		    fail("$description: running raster2pgsql", $errfile);
 		    return 0;
 	    }
-	    
+
 	    if ( -r $expected_sql_file )
 	    {
 	        show_progress();
@@ -945,7 +952,7 @@ sub run_raster_loader_and_check_output
 				fail(" $description: actual SQL does not match expected.", "$outfile");
 				return 0;
 			}
-	        
+
         }
 
 		# Run the loader SQL script.
@@ -965,26 +972,26 @@ sub run_raster_loader_and_check_output
     		return 0 if ( ! $rv );
     	}
 	}
-    	
+
     return 1;
 }
 
 
 
 ##################################################################
-#  run_loader_test 
+#  run_loader_test
 #
 #  Load a shapefile with different methods, create a 'select *' SQL
-#  test and run simple test with provided expected output. 
+#  test and run simple test with provided expected output.
 #
 #  SHP input is ${TEST}.shp, expected output is {$TEST}.expected
 ##################################################################
-sub run_loader_test 
+sub run_loader_test
 {
 	# See if there is a custom command-line options file
 	my $opts_file = "${TEST}.opts";
 	my $custom_opts="";
-	
+
 	if ( -r $opts_file )
 	{
 		open(FILE, $opts_file);
@@ -1052,22 +1059,22 @@ sub run_loader_test
 		}
 		drop_table($tblname);
 	}
-	
+
 	return 1;
 }
 
 ##################################################################
-#  run_dumper_test 
+#  run_dumper_test
 #
 #  Run dumper and compare output with various expectances
-#  test and run simple test with provided expected output. 
+#  test and run simple test with provided expected output.
 #
 # input is ${TEST}.dmp, where last line is considered to be the
 # [table|query] argument for pgsql2shp and all the previous lines,
-# if any are 
+# if any are
 #
 ##################################################################
-sub run_dumper_test 
+sub run_dumper_test
 {
   my $dump_file  = "${TEST}.dmp";
 
@@ -1141,14 +1148,14 @@ sub run_dumper_test
 
 
 ##################################################################
-#  run_raster_loader_test 
+#  run_raster_loader_test
 ##################################################################
 sub run_raster_loader_test
 {
 	# See if there is a custom command-line options file
 	my $opts_file = "${TEST}.opts";
 	my $custom_opts="";
-	
+
 	if ( -r $opts_file )
 	{
 		open(FILE, $opts_file);
@@ -1166,9 +1173,9 @@ sub run_raster_loader_test
 	{
 		return 0;
 	}
-	
+
 	drop_table($tblname);
-	
+
 	return 1;
 }
 
@@ -1179,15 +1186,15 @@ sub run_raster_loader_test
 sub count_db_objects
 {
 	my $count = sql("WITH counts as (
-		select count(*) from pg_type union all 
-		select count(*) from pg_proc union all 
+		select count(*) from pg_type union all
+		select count(*) from pg_proc union all
 		select count(*) from pg_cast union all
 		select count(*) from pg_aggregate union all
 		select count(*) from pg_operator union all
 		select count(*) from pg_opclass union all
 		select count(*) from pg_namespace
 			where nspname NOT LIKE 'pg_%' union all
-		select count(*) from pg_opfamily ) 
+		select count(*) from pg_opfamily )
 		select sum(count) from counts");
 
  	return $count;
@@ -1203,7 +1210,7 @@ sub create_db
 	return system($cmd);
 }
 
-sub create_spatial 
+sub create_spatial
 {
 	my ($cmd, $rv);
 	print "Creating database '$DB' \n";
@@ -1216,7 +1223,7 @@ sub create_spatial
 	# Count database objects before installing anything
 	$OBJ_COUNT_PRE = count_db_objects();
 
-	if ( $OPT_EXTENSIONS ) 
+	if ( $OPT_EXTENSIONS )
 	{
 		prepare_spatial_extensions();
 	}
@@ -1231,12 +1238,12 @@ sub load_sql_file
 {
 	my $file = shift;
 	my $strict = shift;
-	
+
 	if ( $strict && ! -e $file )
 	{
-		die "Unable to find $file\n"; 
+		die "Unable to find $file\n";
 	}
-	
+
 	if ( -e $file )
 	{
 		# ON_ERROR_STOP is used by psql to return non-0 on an error
@@ -1267,7 +1274,7 @@ sub prepare_spatial_extensions
 		$sql .= " VERSION '" . $OPT_UPGRADE_FROM . "'";
 	}
 
-	print "Preparing db '${DB}' using: ${sql}\n"; 
+	print "Preparing db '${DB}' using: ${sql}\n";
 
 	my $cmd = "psql $psql_opts -c \"". $sql . "\" $DB >> $REGRESS_LOG 2>&1";
 	my $rv = system($cmd);
@@ -1316,14 +1323,14 @@ sub prepare_spatial
 	# Load postgis.sql into the database
 	load_sql_file("${STAGED_SCRIPTS_DIR}/postgis.sql", 1);
 	load_sql_file("${STAGED_SCRIPTS_DIR}/postgis_comments.sql", 0);
-	
+
 	if ( $OPT_WITH_TOPO )
 	{
 		print "Loading Topology into '${DB}'\n";
 		load_sql_file("${STAGED_SCRIPTS_DIR}/topology.sql", 1);
 		load_sql_file("${STAGED_SCRIPTS_DIR}/topology_comments.sql", 0);
 	}
-	
+
 	if ( $OPT_WITH_RASTER )
 	{
 		print "Loading Raster into '${DB}'\n";
@@ -1358,8 +1365,8 @@ sub upgrade_spatial
     {
         die "$script not found\n";
     }
-    
-    if ( $OPT_WITH_TOPO ) 
+
+    if ( $OPT_WITH_TOPO )
     {
         my $script = `ls ${STAGED_SCRIPTS_DIR}/topology_upgrade.sql`;
         chomp($script);
@@ -1373,8 +1380,8 @@ sub upgrade_spatial
             die "$script not found\n";
         }
     }
-    
-    if ( $OPT_WITH_RASTER ) 
+
+    if ( $OPT_WITH_RASTER )
     {
         my $script = `ls ${STAGED_SCRIPTS_DIR}/rtpostgis_upgrade.sql`;
         chomp($script);
@@ -1413,7 +1420,7 @@ sub upgrade_spatial_extensions
       die;
     }
 
-    if ( $OPT_WITH_TOPO ) 
+    if ( $OPT_WITH_TOPO )
     {
       my $sql = "ALTER EXTENSION postgis_topology UPDATE TO '${nextver}'";
       my $cmd = "psql $psql_opts -c \"" . $sql . "\" $DB >> $REGRESS_LOG 2>&1";
@@ -1423,7 +1430,7 @@ sub upgrade_spatial_extensions
         die;
       }
     }
-    
+
     return 1;
 }
 
@@ -1452,9 +1459,9 @@ sub drop_spatial_extensions
 {
     # ON_ERROR_STOP is used by psql to return non-0 on an error
     my $psql_opts="--no-psqlrc --variable ON_ERROR_STOP=true";
-    my $ok = 1; 
+    my $ok = 1;
     my ($cmd, $rv);
-    
+
     if ( $OPT_WITH_TOPO )
     {
         # NOTE: "manually" dropping topology schema as EXTENSION does not
@@ -1471,7 +1478,7 @@ sub drop_spatial_extensions
         $rv = system($cmd);
         $ok = 0 if $rv;
     }
-    
+
     $cmd = "psql $psql_opts -c \"DROP EXTENSION postgis\" $DB >> $REGRESS_LOG 2>&1";
     $rv = system($cmd);
   	die "\nError encountered dropping EXTENSION POSTGIS, see $REGRESS_LOG for details\n\n"
@@ -1485,9 +1492,9 @@ sub uninstall_spatial
 {
 	my $ok;
 	start_test("uninstall");
-	
+
 	if ( $OPT_EXTENSIONS )
-	{	
+	{
 		$ok = drop_spatial_extensions();
 	}
 	else
@@ -1495,11 +1502,11 @@ sub uninstall_spatial
 		$ok = drop_spatial();
 	}
 
-	if ( $ok ) 
+	if ( $ok )
 	{
 		show_progress(); # on to objects count
 		$OBJ_COUNT_POST = count_db_objects();
-		
+
 		if ( $OBJ_COUNT_POST != $OBJ_COUNT_PRE )
 		{
 			fail("Object count pre-install ($OBJ_COUNT_PRE) != post-uninstall ($OBJ_COUNT_POST)");
@@ -1511,9 +1518,9 @@ sub uninstall_spatial
 			return 1;
 		}
 	}
-	
+
 	return 0;
-}  
+}
 
 # Dump and restore the database
 sub dump_restore
diff --git a/regress/subdivide.sql b/regress/subdivide.sql
index 69b6a2d..30c941e 100644
--- a/regress/subdivide.sql
+++ b/regress/subdivide.sql
@@ -22,3 +22,5 @@ WITH g AS (SELECT 'POLYGON((132 10,119 23,85 35,68 29,66 28,49 42,32 56,22 64,32
 SELECT '3' As rn, full_area::numeric(10,3) = SUM(ST_Area(gs.geom))::numeric(10,3), COUNT(gs.geom) As num_pieces, MAX(ST_NPoints(gs.geom)) As max_vert
 FROM gs
 GROUP BY gs.full_area;
+
+SELECT '#3522', ST_AsText(ST_Subdivide(ST_GeomFromText('POINT(1 1)',4326),10));
diff --git a/regress/subdivide_expected b/regress/subdivide_expected
index 1c828a5..43e89ec 100644
--- a/regress/subdivide_expected
+++ b/regress/subdivide_expected
@@ -1,3 +1,4 @@
 1|t|9|9
 2|t|6|7
 3|t|15|9
+#3522|POINT(1 1)
diff --git a/regress/swapordinates.sql b/regress/swapordinates.sql
index 382a2b6..53d329e 100644
--- a/regress/swapordinates.sql
+++ b/regress/swapordinates.sql
@@ -13,3 +13,6 @@ SELECT 'swap1', ST_AsText(ST_SwapOrdinates('POINTZ(0 1 2)','xz'));
 SELECT 'swap2', ST_AsText(ST_SwapOrdinates('POINTM(0 1 2)','my'));
 SELECT 'swap3', ST_AsText(ST_SwapOrdinates('POINTZM(0 1 2 3)','mz'));
 SELECT 'swap4', ST_AsText(ST_SwapOrdinates('MULTICURVE ZM ((5 5 1 3, 3 5 2 2, 3 3 3 1, 0 3 1 1), CIRCULARSTRING ZM (0 0 0 0, 0.2 1 3 -2, 0.5 1.4 1 2), COMPOUNDCURVE ZM (CIRCULARSTRING ZM (0 0 0 0,1 1 1 2,1 0 0 1),(1 0 0 1,0 1 5 4)))','my'));
+
+select '#3628.1', ST_AsText(ST_SwapOrdinates('POINT(1 2 3)', 'XY'));
+select '#3628.2', ST_AsText(ST_SwapOrdinates('POINT(1 2 3)', 'YZ'));
diff --git a/regress/swapordinates_expected b/regress/swapordinates_expected
index c498bba..57ecf15 100644
--- a/regress/swapordinates_expected
+++ b/regress/swapordinates_expected
@@ -8,3 +8,5 @@ swap1|POINT Z (2 1 0)
 swap2|POINT M (0 2 1)
 swap3|POINT ZM (0 1 3 2)
 swap4|MULTICURVE ZM ((5 3 1 5,3 2 2 5,3 1 3 3,0 1 1 3),CIRCULARSTRING ZM (0 0 0 0,0.2 -2 3 1,0.5 2 1 1.4),COMPOUNDCURVE ZM (CIRCULARSTRING ZM (0 0 0 0,1 2 1 1,1 1 0 0),(1 1 0 0,0 4 5 1)))
+#3628.1|POINT Z (2 1 3)
+#3628.2|POINT Z (1 3 2)
diff --git a/regress/tickets.sql b/regress/tickets.sql
index 362795c..1532fcf 100644
--- a/regress/tickets.sql
+++ b/regress/tickets.sql
@@ -906,6 +906,23 @@ SELECT '#2870', ST_Summary('Point(151.215289 -33.856885)'::geometry::bytea::geog
 
 SELECT '#2956', st_astwkb(null,0) is null;
 
+-- #2965 --
+CREATE TABLE test_analyze_crash (a integer not null, g geometry);
+INSERT INTO test_analyze_crash values (1, '0102000020E6100000010000006D1092A47FF33440AD4ECD9B00334A40');
+ANALYZE test_analyze_crash;
+SELECT '#2965', ST_AsText(g) FROM test_analyze_crash;
+DROP TABLE test_analyze_crash;
+
+-- #3119 --
+SELECT '#3119a', floor(ST_LengthSpheroid('SRID=4326;LINESTRING (-72.640965 42.11867, -72.6395 42.1187)', 'SPHEROID["GRS_1980",6378137,298.257222101]'));
+-- polygons are also handled
+SELECT '#3119b', floor(ST_LengthSpheroid('SRID=4326;POLYGON ((-72.640965 42.11867, -72.6395 42.1187, -72.64065 42.11819, -72.640965 42.11867))', 'SPHEROID["GRS_1980",6378137,298.257222101]'));
+-- for polygons with holes, all rings are considered
+SELECT '#3119c', floor(ST_LengthSpheroid('SRID=4326;POLYGON ((-72.640965 42.11819, -72.640965 42.1187, -72.6395 42.1187, -72.6395 42.11819, -72.640965 42.11819),
+          (-72.63965 42.118305, -72.64083 42.118305, -72.64083 42.118595, -72.63965 42.118595, -72.63965 42.118305))', 'SPHEROID["GRS_1980",6378137,298.257222101]'));
+-- triangles also work
+SELECT '#3119d', floor(ST_LengthSpheroid('SRID=4326;TRIANGLE ((-72.640965 42.11867, -72.6395 42.1187, -72.64065 42.11819, -72.640965 42.11867))', 'SPHEROID["GRS_1980",6378137,298.257222101]'));
+
 SELECT '#3172', ST_AsText(ST_AddMeasure('LINESTRING(0 0,0 0)', 1, 2));
 
 --SELECT '#3244a', ST_AsText(ST_3DClosestPoint('POINT(0 0 0)', 'POINT(0 0)'));
@@ -933,6 +950,50 @@ SELECT '#3437d' AS t, count(*) FROM mp INNER JOIN p ON ST_Covers(mp.geom, p.geom
 UNION ALL
 SELECT '#3437e' AS t, count(*) FROM mp INNER JOIN p ON ST_Within(p.geom, mp.geom);
 
+-- #3470
+SELECT '#3470', ST_Polygonize(ARRAY[NULL]::geometry[]) IS NULL;
+SELECT '#3470b', ST_Area(ST_Polygonize(ARRAY[NULL, 'LINESTRING (0 0, 10 0, 10 10)', NULL, 'LINESTRING (0 0, 10 10)', NULL]::geometry[]));
+
+-- #3565
+SELECT '#3565',ST_SetPoint(st_geomfromtext('LINESTRING EMPTY'), 0, ST_MakePoint(1,1));
+
+-- #3569
+WITH clustr AS (
+      SELECT ST_Polygonize(ST_MakeEnvelope(1, 2, 3, 4)) AS geom
+    )
+    SELECT '#3569', ST_CollectionHomogenize(geom)::box2d
+    FROM clustr;
+
+-- #3579
+with
+        params as (
+        select
+            11 :: float as sidewalk_offset,
+            1 :: float  as epsilon
+    ),
+        road as (
+-- L-shaped road, 10 m
+        select 'SRID=3857;LINESTRING(10 0, 0 0, 0 10)' :: geometry as geom
+    ),
+        sidewalks as (
+        select ST_Collect(
+                   ST_OffsetCurve(geom, sidewalk_offset),
+                   ST_OffsetCurve(geom, -sidewalk_offset)
+               ) geom
+        from road, params
+    )
+select
+    '#3579', ST_Intersects(road.geom, sidewalks.geom),
+-- should be false
+    ST_Intersects(ST_Buffer(road.geom, sidewalk_offset + epsilon), sidewalks.geom) -- should be true
+from road, sidewalks, params;
+
+-- #3583
+Select '#3583', ST_AsText(ST_GeomFromGeoJSON('{"type":"MultiPolygon", "coordinates":[[[139.10030364990232,35.16777444430609],5842.4224490305424]]}')); 
+
+-- #3627
+SELECT '#3627a', ST_AsEncodedPolyline('SRID=4326;LINESTRING(-0.250691 49.283048,-0.250633 49.283376,-0.250502 49.283972,-0.251245 49.284028,-0.251938 49.284232,-0.251938 49.2842)', 6);
+SELECT '#3627b', ST_Equals(geom, ST_LineFromEncodedPolyline(ST_AsEncodedPolyline(geom, 7), 7)) FROM (VALUES ('SRID=4326;LINESTRING (0 0, 1 1)')) AS v (geom);
 
 -- Clean up
 DELETE FROM spatial_ref_sys;
diff --git a/regress/tickets_expected b/regress/tickets_expected
index 0ca9d55..0b94df3 100644
--- a/regress/tickets_expected
+++ b/regress/tickets_expected
@@ -275,6 +275,11 @@ ERROR:  invalid GML representation
 #2788|f|Self-intersection|POINT(1 1)
 #2870|Point[GS]
 #2956|t
+#2965|LINESTRING(20.9511664253809 52.3984560730436)
+#3119a|121
+#3119b|291
+#3119c|615
+#3119d|291
 #3172|LINESTRING M (0 0 1,0 0 2)
 #3300|POLYGON((-71.7821 42.2622,-71.7821 42.9067,-71.029 42.9067,-71.029 42.2622,-71.7821 42.2622))
 #3367|POLYGON EMPTY
@@ -285,3 +290,11 @@ ERROR:  invalid GML representation
 #3437c|5
 #3437d|5
 #3437e|5
+#3470|t
+#3470b|50
+ERROR:  Cannot set point values on EMPTY geometry, use ST_AddPoint to add points
+#3569|BOX(1 2,3 4)
+#3579|f|t
+#3583|MULTIPOLYGON Z (EMPTY)
+#3627a|o}~~|AdshNoSsBgd@eGoBlm@wKhj@~@?
+#3627b|t
diff --git a/spatial_ref_sys.sql b/spatial_ref_sys.sql
index 0fcbf06..7bba961 100644
--- a/spatial_ref_sys.sql
+++ b/spatial_ref_sys.sql
@@ -442,7 +442,7 @@ INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4tex
 ---
 --- EPSG 4179 : Pulkovo 1942(58)
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (4179,'EPSG',4179,'GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]]','+proj=longlat +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (4179,'EPSG',4179,'GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]]','+proj=longlat +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +no_defs ');
 ---
 --- EPSG 4180 : EST97
 ---
@@ -2676,23 +2676,23 @@ INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4tex
 ---
 --- EPSG 2171 : Pulkovo 1942(58) / Poland zone I (deprecated)
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (2171,'EPSG',2171,'PROJCS["Pulkovo 1942(58) / Poland zone I (deprecated)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",50.625],PARAMETER["central_meridian",21.08333333333333],PARAMETER["scale_factor",0.9998],PARAMETER["false_easting",4637000],PARAMETER["false_northing",5647000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","2171"]]','+proj=sterea +lat_0=50.625 +lon_0=21.08333333333333 +k=0.9998 +x_0=4637000 +y_0=5647000 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (2171,'EPSG',2171,'PROJCS["Pulkovo 1942(58) / Poland zone I (deprecated)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",50.625],PARAMETER["central_meridian",21.08333333333333],PARAMETER["scale_factor",0.9998],PARAMETER["false_easting",4637000],PARAMETER["false_northing",5647000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","2171"]]','+proj=sterea +lat_0=50.625 +lon_0=21.08333333333333 +k=0.9998 +x_0=4637000 +y_0=5647000 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 2172 : Pulkovo 1942(58) / Poland zone II
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (2172,'EPSG',2172,'PROJCS["Pulkovo 1942(58) / Poland zone II",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",53.00194444444445],PARAMETER["central_meridian",21.50277777777778],PARAMETER["scale_factor",0.9998],PARAMETER["false_easting",4603000],PARAMETER["false_northing",5806000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","2172"]]','+proj=sterea +lat_0=53.00194444444445 +lon_0=21.50277777777778 +k=0.9998 +x_0=4603000 +y_0=5806000 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (2172,'EPSG',2172,'PROJCS["Pulkovo 1942(58) / Poland zone II",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",53.00194444444445],PARAMETER["central_meridian",21.50277777777778],PARAMETER["scale_factor",0.9998],PARAMETER["false_easting",4603000],PARAMETER["false_northing",5806000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","2172"]]','+proj=sterea +lat_0=53.00194444444445 +lon_0=21.50277777777778 +k=0.9998 +x_0=4603000 +y_0=5806000 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 2173 : Pulkovo 1942(58) / Poland zone III
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (2173,'EPSG',2173,'PROJCS["Pulkovo 1942(58) / Poland zone III",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",53.58333333333334],PARAMETER["central_meridian",17.00833333333333],PARAMETER["scale_factor",0.9998],PARAMETER["false_easting",3501000],PARAMETER["false_northing",5999000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","2173"]]','+proj=sterea +lat_0=53.58333333333334 +lon_0=17.00833333333333 +k=0.9998 +x_0=3501000 +y_0=5999000 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (2173,'EPSG',2173,'PROJCS["Pulkovo 1942(58) / Poland zone III",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",53.58333333333334],PARAMETER["central_meridian",17.00833333333333],PARAMETER["scale_factor",0.9998],PARAMETER["false_easting",3501000],PARAMETER["false_northing",5999000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","2173"]]','+proj=sterea +lat_0=53.58333333333334 +lon_0=17.00833333333333 +k=0.9998 +x_0=3501000 +y_0=5999000 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 2174 : Pulkovo 1942(58) / Poland zone IV
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (2174,'EPSG',2174,'PROJCS["Pulkovo 1942(58) / Poland zone IV",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",51.67083333333333],PARAMETER["central_meridian",16.67222222222222],PARAMETER["scale_factor",0.9998],PARAMETER["false_easting",3703000],PARAMETER["false_northing",5627000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","2174"]]','+proj=sterea +lat_0=51.67083333333333 +lon_0=16.67222222222222 +k=0.9998 +x_0=3703000 +y_0=5627000 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (2174,'EPSG',2174,'PROJCS["Pulkovo 1942(58) / Poland zone IV",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",51.67083333333333],PARAMETER["central_meridian",16.67222222222222],PARAMETER["scale_factor",0.9998],PARAMETER["false_easting",3703000],PARAMETER["false_northing",5627000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","2174"]]','+proj=sterea +lat_0=51.67083333333333 +lon_0=16.67222222222222 +k=0.9998 +x_0=3703000 +y_0=5627000 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 2175 : Pulkovo 1942(58) / Poland zone V
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (2175,'EPSG',2175,'PROJCS["Pulkovo 1942(58) / Poland zone V",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",18.95833333333333],PARAMETER["scale_factor",0.999983],PARAMETER["false_easting",237000],PARAMETER["false_northing",-4700000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","2175"]]','+proj=tmerc +lat_0=0 +lon_0=18.95833333333333 +k=0.999983 +x_0=237000 +y_0=-4700000 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (2175,'EPSG',2175,'PROJCS["Pulkovo 1942(58) / Poland zone V",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",18.95833333333333],PARAMETER["scale_factor",0.999983],PARAMETER["false_easting",237000],PARAMETER["false_northing",-4700000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","2175"]]','+proj=tmerc +lat_0=0 +lon_0=18.95833333333333 +k=0.999983 +x_0=237000 +y_0=-4700000 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 2176 : ETRS89 / Poland CS2000 zone 5
 ---
@@ -6436,7 +6436,7 @@ INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4tex
 ---
 --- EPSG 3120 : Pulkovo 1942(58) / Poland zone I
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3120,'EPSG',3120,'PROJCS["Pulkovo 1942(58) / Poland zone I",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",50.625],PARAMETER["central_meridian",21.08333333333333],PARAMETER["scale_factor",0.9998],PARAMETER["false_easting",4637000],PARAMETER["false_northing",5467000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3120"]]','+proj=sterea +lat_0=50.625 +lon_0=21.08333333333333 +k=0.9998 +x_0=4637000 +y_0=5467000 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3120,'EPSG',3120,'PROJCS["Pulkovo 1942(58) / Poland zone I",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",50.625],PARAMETER["central_meridian",21.08333333333333],PARAMETER["scale_factor",0.9998],PARAMETER["false_easting",4637000],PARAMETER["false_northing",5467000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3120"]]','+proj=sterea +lat_0=50.625 +lon_0=21.08333333333333 +k=0.9998 +x_0=4637000 +y_0=5467000 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3121 : PRS92 / Philippines zone 1
 ---
@@ -7268,35 +7268,35 @@ INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4tex
 ---
 --- EPSG 3328 : Pulkovo 1942(58) / GUGiK-80
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3328,'EPSG',3328,'PROJCS["Pulkovo 1942(58) / GUGiK-80",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",52.16666666666666],PARAMETER["central_meridian",19.16666666666667],PARAMETER["scale_factor",0.999714],PARAMETER["false_easting",500000],PARAMETER["false_northing",500000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3328"]]','+proj=sterea +lat_0=52.16666666666666 +lon_0=19.16666666666667 +k=0.999714 +x_0=500000 +y_0=500000 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3328,'EPSG',3328,'PROJCS["Pulkovo 1942(58) / GUGiK-80",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Oblique_Stereographic"],PARAMETER["latitude_of_origin",52.16666666666666],PARAMETER["central_meridian",19.16666666666667],PARAMETER["scale_factor",0.999714],PARAMETER["false_easting",500000],PARAMETER["false_northing",500000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3328"]]','+proj=sterea +lat_0=52.16666666666666 +lon_0=19.16666666666667 +k=0.999714 +x_0=500000 +y_0=500000 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3329 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 5
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3329,'EPSG',3329,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 5",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",15],PARAMETER["scale_factor",1],PARAMETER["false_easting",5500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3329"]]','+proj=tmerc +lat_0=0 +lon_0=15 +k=1 +x_0=5500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3329,'EPSG',3329,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 5",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",15],PARAMETER["scale_factor",1],PARAMETER["false_easting",5500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3329"]]','+proj=tmerc +lat_0=0 +lon_0=15 +k=1 +x_0=5500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3330 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 6
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3330,'EPSG',3330,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 6",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",18],PARAMETER["scale_factor",1],PARAMETER["false_easting",6500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3330"]]','+proj=tmerc +lat_0=0 +lon_0=18 +k=1 +x_0=6500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3330,'EPSG',3330,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 6",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",18],PARAMETER["scale_factor",1],PARAMETER["false_easting",6500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3330"]]','+proj=tmerc +lat_0=0 +lon_0=18 +k=1 +x_0=6500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3331 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 7
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3331,'EPSG',3331,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 7",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",21],PARAMETER["scale_factor",1],PARAMETER["false_easting",7500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3331"]]','+proj=tmerc +lat_0=0 +lon_0=21 +k=1 +x_0=7500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3331,'EPSG',3331,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 7",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",21],PARAMETER["scale_factor",1],PARAMETER["false_easting",7500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3331"]]','+proj=tmerc +lat_0=0 +lon_0=21 +k=1 +x_0=7500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3332 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 8
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3332,'EPSG',3332,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 8",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",24],PARAMETER["scale_factor",1],PARAMETER["false_easting",8500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3332"]]','+proj=tmerc +lat_0=0 +lon_0=24 +k=1 +x_0=8500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3332,'EPSG',3332,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 8",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",24],PARAMETER["scale_factor",1],PARAMETER["false_easting",8500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3332"]]','+proj=tmerc +lat_0=0 +lon_0=24 +k=1 +x_0=8500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3333 : Pulkovo 1942(58) / Gauss-Kruger zone 3
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3333,'EPSG',3333,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 3",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",15],PARAMETER["scale_factor",1],PARAMETER["false_easting",3500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3333"]]','+proj=tmerc +lat_0=0 +lon_0=15 +k=1 +x_0=3500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3333,'EPSG',3333,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 3",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",15],PARAMETER["scale_factor",1],PARAMETER["false_easting",3500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3333"]]','+proj=tmerc +lat_0=0 +lon_0=15 +k=1 +x_0=3500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3334 : Pulkovo 1942(58) / Gauss-Kruger zone 4
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3334,'EPSG',3334,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 4",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",21],PARAMETER["scale_factor",1],PARAMETER["false_easting",4500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3334"]]','+proj=tmerc +lat_0=0 +lon_0=21 +k=1 +x_0=4500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3334,'EPSG',3334,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 4",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",21],PARAMETER["scale_factor",1],PARAMETER["false_easting",4500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3334"]]','+proj=tmerc +lat_0=0 +lon_0=21 +k=1 +x_0=4500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3335 : Pulkovo 1942(58) / Gauss-Kruger zone 5
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3335,'EPSG',3335,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 5",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",27],PARAMETER["scale_factor",1],PARAMETER["false_easting",5500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3335"]]','+proj=tmerc +lat_0=0 +lon_0=27 +k=1 +x_0=5500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3335,'EPSG',3335,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 5",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",27],PARAMETER["scale_factor",1],PARAMETER["false_easting",5500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3335"]]','+proj=tmerc +lat_0=0 +lon_0=27 +k=1 +x_0=5500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3336 : IGN 1962 Kerguelen / UTM zone 42S
 ---
@@ -9204,7 +9204,7 @@ INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4tex
 ---
 --- EPSG 3833 : Pulkovo 1942(58) / Gauss-Kruger zone 2
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3833,'EPSG',3833,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 2",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",9],PARAMETER["scale_factor",1],PARAMETER["false_easting",2500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3833"]]','+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=2500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3833,'EPSG',3833,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 2",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",9],PARAMETER["scale_factor",1],PARAMETER["false_easting",2500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3833"]]','+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=2500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3834 : Pulkovo 1942(83) / Gauss-Kruger zone 2
 ---
@@ -9220,19 +9220,19 @@ INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4tex
 ---
 --- EPSG 3837 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 3
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3837,'EPSG',3837,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 3",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",9],PARAMETER["scale_factor",1],PARAMETER["false_easting",3500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3837"]]','+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=3500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3837,'EPSG',3837,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 3",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",9],PARAMETER["scale_factor",1],PARAMETER["false_easting",3500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3837"]]','+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=3500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3838 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 4
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3838,'EPSG',3838,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 4",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",12],PARAMETER["scale_factor",1],PARAMETER["false_easting",4500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3838"]]','+proj=tmerc +lat_0=0 +lon_0=12 +k=1 +x_0=4500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3838,'EPSG',3838,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 4",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",12],PARAMETER["scale_factor",1],PARAMETER["false_easting",4500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3838"]]','+proj=tmerc +lat_0=0 +lon_0=12 +k=1 +x_0=4500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3839 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 9
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3839,'EPSG',3839,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 9",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",27],PARAMETER["scale_factor",1],PARAMETER["false_easting",9500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3839"]]','+proj=tmerc +lat_0=0 +lon_0=27 +k=1 +x_0=9500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3839,'EPSG',3839,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 9",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",27],PARAMETER["scale_factor",1],PARAMETER["false_easting",9500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3839"]]','+proj=tmerc +lat_0=0 +lon_0=27 +k=1 +x_0=9500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3840 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 10
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3840,'EPSG',3840,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 10",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",30],PARAMETER["scale_factor",1],PARAMETER["false_easting",10500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3840"]]','+proj=tmerc +lat_0=0 +lon_0=30 +k=1 +x_0=10500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (3840,'EPSG',3840,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 10",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",30],PARAMETER["scale_factor",1],PARAMETER["false_easting",10500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","3840"]]','+proj=tmerc +lat_0=0 +lon_0=30 +k=1 +x_0=10500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 3841 : Pulkovo 1942(83) / 3-degree Gauss-Kruger zone 6
 ---
@@ -11272,7 +11272,7 @@ INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4tex
 ---
 --- EPSG 5631 : Pulkovo 1942(58) / Gauss-Kruger zone 2 (E-N)
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (5631,'EPSG',5631,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 2 (E-N)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",9],PARAMETER["scale_factor",1],PARAMETER["false_easting",2500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","5631"]]','+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=2500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (5631,'EPSG',5631,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 2 (E-N)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",9],PARAMETER["scale_factor",1],PARAMETER["false_easting",2500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","5631"]]','+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=2500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 5632 : PTRA08 / LCC Europe
 ---
@@ -11356,7 +11356,7 @@ INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4tex
 ---
 --- EPSG 5663 : Pulkovo 1942(58) / Gauss-Kruger zone 3 (E-N)
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (5663,'EPSG',5663,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 3 (E-N)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",15],PARAMETER["scale_factor",1],PARAMETER["false_easting",3500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","5663"]]','+proj=tmerc +lat_0=0 +lon_0=15 +k=1 +x_0=3500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (5663,'EPSG',5663,'PROJCS["Pulkovo 1942(58) / Gauss-Kruger zone 3 (E-N)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",15],PARAMETER["scale_factor",1],PARAMETER["false_easting",3500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","5663"]]','+proj=tmerc +lat_0=0 +lon_0=15 +k=1 +x_0=3500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 5664 : Pulkovo 1942(83) / Gauss-Kruger zone 2 (E-N)
 ---
@@ -11384,15 +11384,15 @@ INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4tex
 ---
 --- EPSG 5670 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 3 (E-N)
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (5670,'EPSG',5670,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 3 (E-N)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",9],PARAMETER["scale_factor",1],PARAMETER["false_easting",3500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","5670"]]','+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=3500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (5670,'EPSG',5670,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 3 (E-N)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",9],PARAMETER["scale_factor",1],PARAMETER["false_easting",3500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","5670"]]','+proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=3500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 5671 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 4 (E-N)
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (5671,'EPSG',5671,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 4 (E-N)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",12],PARAMETER["scale_factor",1],PARAMETER["false_easting",4500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","5671"]]','+proj=tmerc +lat_0=0 +lon_0=12 +k=1 +x_0=4500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (5671,'EPSG',5671,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 4 (E-N)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",12],PARAMETER["scale_factor",1],PARAMETER["false_easting",4500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","5671"]]','+proj=tmerc +lat_0=0 +lon_0=12 +k=1 +x_0=4500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 5672 : Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 5 (E-N)
 ---
-INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (5672,'EPSG',5672,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 5 (E-N)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",15],PARAMETER["scale_factor",1],PARAMETER["false_easting",5500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","5672"]]','+proj=tmerc +lat_0=0 +lon_0=15 +k=1 +x_0=5500000 +y_0=0 +ellps=krass +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84 +units=m +no_defs ');
+INSERT INTO "spatial_ref_sys" ("srid","auth_name","auth_srid","srtext","proj4text") VALUES (5672,'EPSG',5672,'PROJCS["Pulkovo 1942(58) / 3-degree Gauss-Kruger zone 5 (E-N)",GEOGCS["Pulkovo 1942(58)",DATUM["Pulkovo_1942_58",SPHEROID["Krassowsky 1940",6378245,298.3,AUTHORITY["EPSG","7024"]],TOWGS84[2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266],AUTHORITY["EPSG","6179"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4179"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",15],PARAMETER["scale_factor",1],PARAMETER["false_easting",5500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","5672"]]','+proj=tmerc +lat_0=0 +lon_0=15 +k=1 +x_0=5500000 +y_0=0 +ellps=krass +towgs84=2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266 +units=m +no_defs ');
 ---
 --- EPSG 5673 : Pulkovo 1942(83) / 3-degree Gauss-Kruger zone 3 (E-N)
 ---
diff --git a/topology/postgis_topology.c b/topology/postgis_topology.c
index 60e12b2..342e1db 100644
--- a/topology/postgis_topology.c
+++ b/topology/postgis_topology.c
@@ -589,12 +589,13 @@ fillEdgeFields(LWT_ISO_EDGE* edge, HeapTuple row, TupleDesc rowdesc, int fields)
     if ( isnull ) {
       lwpgwarning("Found edge with NULL edge_id");
       edge->edge_id = -1;
+    } else {
+      val = DatumGetInt32(dat);
+      POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (edge_id)"
+                        " has int32 val of %d",
+                        colno, val);
+      edge->edge_id = val;
     }
-    val = DatumGetInt32(dat);
-    POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (edge_id)"
-                      " has int32 val of %d",
-                      colno, val);
-    edge->edge_id = val;
 
   }
   if ( fields & LWT_COL_EDGE_START_NODE ) {
@@ -602,66 +603,72 @@ fillEdgeFields(LWT_ISO_EDGE* edge, HeapTuple row, TupleDesc rowdesc, int fields)
     if ( isnull ) {
       lwpgwarning("Found edge with NULL start_node");
       edge->start_node = -1;
+    } else {
+      val = DatumGetInt32(dat);
+      POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (start_node)"
+                        " has int32 val of %d", colno, val);
+      edge->start_node = val;
     }
-    val = DatumGetInt32(dat);
-    edge->start_node = val;
-    POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (start_node)"
-                      " has int32 val of %d", colno, val);
   }
   if ( fields & LWT_COL_EDGE_END_NODE ) {
     dat = SPI_getbinval(row, rowdesc, ++colno, &isnull);
     if ( isnull ) {
       lwpgwarning("Found edge with NULL end_node");
-      edge->start_node = -1;
+      edge->end_node = -1;
+    } else {
+      val = DatumGetInt32(dat);
+      POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (end_node)"
+                        " has int32 val of %d", colno, val);
+      edge->end_node = val;
     }
-    val = DatumGetInt32(dat);
-    edge->end_node = val;
-    POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (end_node)"
-                      " has int32 val of %d", colno, val);
   }
   if ( fields & LWT_COL_EDGE_FACE_LEFT ) {
     dat = SPI_getbinval(row, rowdesc, ++colno, &isnull);
     if ( isnull ) {
       lwpgwarning("Found edge with NULL face_left");
-      edge->start_node = -1;
+      edge->face_left = -1;
+    } else {
+      val = DatumGetInt32(dat);
+      POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (face_left)"
+                        " has int32 val of %d", colno, val);
+      edge->face_left = val;
     }
-    val = DatumGetInt32(dat);
-    edge->face_left = val;
-    POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (face_left)"
-                      " has int32 val of %d", colno, val);
   }
   if ( fields & LWT_COL_EDGE_FACE_RIGHT ) {
     dat = SPI_getbinval(row, rowdesc, ++colno, &isnull);
     if ( isnull ) {
       lwpgwarning("Found edge with NULL face_right");
-      edge->start_node = -1;
+      edge->face_right = -1;
+    } else {
+      val = DatumGetInt32(dat);
+      POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (face_right)"
+                        " has int32 val of %d", colno, val);
+      edge->face_right = val;
     }
-    val = DatumGetInt32(dat);
-    edge->face_right = val;
-    POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (face_right)"
-                      " has int32 val of %d", colno, val);
   }
   if ( fields & LWT_COL_EDGE_NEXT_LEFT ) {
     dat = SPI_getbinval(row, rowdesc, ++colno, &isnull);
     if ( isnull ) {
       lwpgwarning("Found edge with NULL next_left");
-      edge->start_node = -1;
+      edge->next_left = -1;
+    } else {
+      val = DatumGetInt32(dat);
+      POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (next_left)"
+                        " has int32 val of %d", colno, val);
+      edge->next_left = val;
     }
-    val = DatumGetInt32(dat);
-    edge->next_left = val;
-    POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (next_left)"
-                      " has int32 val of %d", colno, val);
   }
   if ( fields & LWT_COL_EDGE_NEXT_RIGHT ) {
     dat = SPI_getbinval(row, rowdesc, ++colno, &isnull);
     if ( isnull ) {
       lwpgwarning("Found edge with NULL next_right");
-      edge->start_node = -1;
+      edge->next_right = -1;
+    } else {
+      val = DatumGetInt32(dat);
+      POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (next_right)"
+                        " has int32 val of %d", colno, val);
+      edge->next_right = val;
     }
-    val = DatumGetInt32(dat);
-    edge->next_right = val;
-    POSTGIS_DEBUGF(2, "fillEdgeFields: colno%d (next_right)"
-                      " has int32 val of %d", colno, val);
   }
   if ( fields & LWT_COL_EDGE_GEOM ) {
     dat = SPI_getbinval(row, rowdesc, ++colno, &isnull);
diff --git a/topology/sql/populate.sql.in b/topology/sql/populate.sql.in
index 335a261..79b692c 100644
--- a/topology/sql/populate.sql.in
+++ b/topology/sql/populate.sql.in
@@ -437,7 +437,9 @@ BEGIN
     RAISE EXCEPTION 'Face geometry must be a polygon';
   END IF;
 
-  for rrec IN SELECT (ST_DumpRings(ST_ForceRHR(apoly))).geom
+  for rrec IN SELECT (d).* FROM (
+    SELECT ST_DumpRings(ST_ForceRHR(apoly)) d
+  ) foo
   LOOP -- {
     --
     -- Find all bounds edges, forcing right-hand-rule
diff --git a/utils/check_all_upgrades.sh b/utils/check_all_upgrades.sh
new file mode 100755
index 0000000..d136336
--- /dev/null
+++ b/utils/check_all_upgrades.sh
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+if test -z "$1"; then
+  echo "Usage: $0 <to_version>" >&2
+  exit 1
+fi
+to_version="$1"
+
+BUILDDIR=$PWD
+EXTDIR=`pg_config --sharedir`/extension/
+
+cd $EXTDIR
+'ls' postgis--* | grep -v -- '--.*--' |
+sed 's/^postgis--\(.*\)\.sql/\1/' | while read fname; do
+  from_version="$fname"
+  UPGRADE_PATH="${from_version}--${to_version}"
+  if test -e postgis--${UPGRADE_PATH}.sql; then
+    echo "Testing upgrade $UPGRADE_PATH"
+    export RUNTESTFLAGS="-v --extension --upgrade-path=${UPGRADE_PATH}"
+    make -C ${BUILDDIR}/regress check || exit 1
+  else
+    echo "Missing script for $UPGRADE_PATH upgrade" >&2
+  fi
+done
diff --git a/utils/postgis_proc_upgrade.pl b/utils/postgis_proc_upgrade.pl
index 1dd3097..ebf7cf6 100755
--- a/utils/postgis_proc_upgrade.pl
+++ b/utils/postgis_proc_upgrade.pl
@@ -4,7 +4,7 @@
 # PostGIS - Spatial Types for PostgreSQL
 # http://postgis.net
 #
-# Copyright (C) 2014 Sandro Santilli <strk@keybit.net>
+# Copyright (C) 2014 Sandro Santilli <strk@kbt.io>
 # Copyright (C) 2009-2010 Paul Ramsey <pramsey@opengeo.org>
 # Copyright (C) 2005 Refractions Research Inc.
 #
@@ -378,6 +378,17 @@ EOF
 			last if /\;\s*$/;
 		}
 	}
+	
+	# Always output grant permissions (see ticket #3680)
+	if ( /^grant select\s+(\S+)\s*/i )
+	{
+		print;
+		while(<INPUT>)
+		{
+			print;
+			last if /\;\s*$/;
+		}
+	}
 
 	# Always output create ore replace rule 
 	if ( /^create or replace rule\s+(\S+)\s*/i )
@@ -390,6 +401,37 @@ EOF
 		}
 	}
 
+	# This code handles operator family by creating them if we are doing a major upgrade
+	if ( /^create operator family\s+(\w+)\s+USING\s+(\w+)\s*/i )
+	{
+		my $opfname = $1;
+		my $amname = $2;
+		my $def = $_;
+		my $opfsig = $opfname . " " . $amname;
+		while(<INPUT>)
+		{
+			$def .= $_;
+			last if /\);/;
+		}
+
+	my $last_updated = parse_last_updated($comment);
+	if ( ! $last_updated ) {
+		print STDERR "WARNING: no last updated info for operator family '${opfname}'\n";
+		$last_updated = find_last_updated("opfamilies", $opfsig);
+	}
+	print "-- Operator family ${opfsig} -- LastUpdated: ${last_updated}\n";
+	print <<"EOF";
+DO LANGUAGE 'plpgsql'
+\$postgis_proc_upgrade\$
+BEGIN
+  IF $last_updated > version_from_num FROM _postgis_upgrade_info THEN
+    EXECUTE \$postgis_proc_upgrade_parsed_def\$ $def \$postgis_proc_upgrade_parsed_def\$;
+  END IF;
+END
+\$postgis_proc_upgrade\$;
+EOF
+	}
+
 	# This code handles operator classes by creating them if we are doing a major upgrade
 	if ( /^create operator class\s+(\w+)\s*/i )
 	{
